<!DOCTYPE html><html lang="pt-BR"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Comparison to OCaml · Reason</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="&lt;p&gt;Se você veio da OCaml ou é um recém-chegado lendo um tutorial escrito na OCaml, este guia é para você! Mas não se esqueça de que &lt;a href=&quot;https://github.com/reasonml/reason-tools&quot;&gt; reason-tools&lt;/a&gt; pode converter entre sintaxe OCaml e Reason em tempo real.&lt;/p&gt;
"/><meta name="docsearch:language" content="pt-BR"/><meta property="og:title" content="Comparison to OCaml · Reason"/><meta property="og:type" content="website"/><meta property="og:url" content="https://reasonml.github.io/"/><meta property="og:description" content="&lt;p&gt;Se você veio da OCaml ou é um recém-chegado lendo um tutorial escrito na OCaml, este guia é para você! Mas não se esqueça de que &lt;a href=&quot;https://github.com/reasonml/reason-tools&quot;&gt; reason-tools&lt;/a&gt; pode converter entre sintaxe OCaml e Reason em tempo real.&lt;/p&gt;
"/><meta name="twitter:card" content="summary"/><link rel="shortcut icon" href="/img/icon_50.png"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"/><link rel="alternate" type="application/atom+xml" href="https://reasonml.github.io/blog/atom.xml" title="Reason Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://reasonml.github.io/blog/feed.xml" title="Reason Blog RSS Feed"/><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/pt-BR"><img class="logo" src="/img/dummy.svg" alt="Reason"/></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/docs/pt-BR/what-and-why" target="_self">Docs</a></li><li class=""><a href="/pt-BR/try" target="_self">Try</a></li><li class=""><a href="/api/index" target="_self">API</a></li><li class=""><a href="/docs/pt-BR/community" target="_self">Community</a></li><li class=""><a href="/blog/" target="_self">Blog</a></li><span><li><a id="languages-menu" href="#"><img class="languages-icon" src="/img/language.svg" alt="Languages icon"/>Português (Brasil)</a><div id="languages-dropdown" class="hide"><ul id="languages-dropdown-items"><li><a href="/docs/ja/comparison-to-ocaml">日本語</a></li><li><a href="/docs/en/comparison-to-ocaml">English</a></li><li><a href="/docs/de/comparison-to-ocaml">Deutsch</a></li><li><a href="/docs/es-ES/comparison-to-ocaml">Español</a></li><li><a href="/docs/fr/comparison-to-ocaml">Français</a></li><li><a href="/docs/ko/comparison-to-ocaml">한국어</a></li><li><a href="/docs/ru/comparison-to-ocaml">Русский</a></li><li><a href="/docs/uk/comparison-to-ocaml">Українська</a></li><li><a href="/docs/zh-CN/comparison-to-ocaml">中文</a></li><li><a href="/docs/zh-TW/comparison-to-ocaml">繁體中文</a></li><li><a href="https://crowdin.com/project/reason" target="_blank" rel="noreferrer noopener">Ajude a Traduzir</a></li></ul></div></li><script>
        const languagesMenuItem = document.getElementById("languages-menu");
        const languagesDropDown = document.getElementById("languages-dropdown");
        languagesMenuItem.addEventListener("click", function(event) {
          event.preventDefault();

          if (languagesDropDown.className == "hide") {
            languagesDropDown.className = "visible";
          } else {
            languagesDropDown.className = "hide";
          }
        });
      </script></span><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li><li class=""><a href="https://github.com/facebook/reason" target="_self">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><i></i></div><h2><i>›</i><span>Extra</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Intro</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/pt-BR/what-and-why">What &amp; Why</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Setup</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/pt-BR/installation">Installation</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/editor-plugins">Editor Plugins</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/extra-goodies">Extra Goodies</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Language Basics</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/pt-BR/overview">Overview</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/let-binding">Let Binding</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/type">Type!</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/string-and-char">String &amp; Char</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/boolean">Boolean</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/integer-and-float">Integer &amp; Float</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/tuple">Tuple</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/record">Record</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/variant">Variant!</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/null-undefined-option">Null, Undefined &amp; Option</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/list-and-array">List &amp; Array</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/function">Function</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/if-else">If-Else</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/pipe-first">Pipe First</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/more-on-type">More on Type</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/destructuring">Destructuring</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/pattern-matching">Pattern Matching!</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/mutation">Mutation</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/imperative-loops">Imperative Loops</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/jsx">JSX</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/external">External</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/exception">Exception</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/object">Object</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/module">Module</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/promise">Promise</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">JavaScript</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/pt-BR/interop">Interop</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/syntax-cheatsheet">Syntax Cheatsheet</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/libraries">Libraries</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/converting-from-js">Converting from JS</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Native</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/pt-BR/native">Native</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/quickstart-ocaml">Native Quickstart</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/convert-from-ocaml">Converting from OCaml</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Extra</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/pt-BR/faq">Frequently Asked Questions</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/docs/pt-BR/comparison-to-ocaml">Comparison to OCaml</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/newcomer-examples">Newcomer Examples</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/project-structure">Project Structure</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              const headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                if (event.target.tagName === 'A') {
                  document.body.classList.remove('tocActive');
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://crowdin.com/project/reason/pt-BR" target="_blank" rel="noreferrer noopener">Translate</a><h1 class="postHeaderTitle">Comparison to OCaml</h1></header><article><div><span><p>Se você veio da OCaml ou é um recém-chegado lendo um tutorial escrito na OCaml, este guia é para você! Mas não se esqueça de que <a href="https://github.com/reasonml/reason-tools"> reason-tools</a> pode converter entre sintaxe OCaml e Reason em tempo real.</p>
<h2><a class="anchor" aria-hidden="true" id="comentarios"></a><a href="#comentarios" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Comentários</h2>
<table>
<thead>
<tr><th>OCaml</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td><code>(* OCaml (*nest*) *)</code></td><td><code>/* Reason /*nest*/ */</code></td></tr>
</tbody>
</table>
<h2><a class="anchor" aria-hidden="true" id="renomeando-operadores"></a><a href="#renomeando-operadores" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Renomeando Operadores</h2>
<p>Reason tem todos os operadores infixos da OCaml, mas alguns deles são expressos de maneira diferente. No Reason, igualdade estrutural é escrita com <code>= =</code> e igualdade referencial (física) é escrita com <code>=</code>. No Reason, para obter a correspondente desigualdade, simplesmente troca-se o primeiro caractere por um caractere de <code>!</code> (exclamação). (<code>!=</code> de desigualdade estrutural, e <code>!==</code> para desigualdade de referência).</p>
<table>
<thead>
<tr><th>Igualdade</th><th>OCaml</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td>Estrutural</td><td><code>x = y</code></td><td><code>x == y</code></td></tr>
<tr><td>Referêncial</td><td><code>x == y</code></td><td><code>x === y</code></td></tr>
</tbody>
</table>
<table>
<thead>
<tr><th>Desigualdade</th><th>OCaml</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td>Estrutural</td><td><code>x &lt;&gt; y</code></td><td><code>x != y</code></td></tr>
<tr><td>Referêncial</td><td><code>x != y</code></td><td><code>x !== y</code></td></tr>
</tbody>
</table>
<h2><a class="anchor" aria-hidden="true" id="escopo-local"></a><a href="#escopo-local" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Escopo Local</h2>
<p>O escopo léxico do Reason é exatamente igual a da OCaml, mas deixe as ligações sintaticamente assemelhando-se aos &quot;escopos de bloco&quot;, que são mais familiar para muitos desenvolvedores. No Reason, eles são criados com chaves <code>{}</code>, que podem conter tanto <code>let</code> ligações e comandos imperativos, separados por <code>;</code>. Todos os blocos avaliam a última linha e o ponto e vírgula na última linha é opcional. <code>{}</code> chaves só são necessárias se você tiver mais de um item para encadear via <code>;</code>.</p>
<table>
  <tr>
    <th>
      OCaml
    </th>
<pre><code class="hljs">&lt;th&gt;
  Reason
&lt;/th&gt;
</code></pre>
  </tr>
  <tr>
    <td>
      <pre><code class="hljs">let _ =
  let msg = "Hello" in
  print_string msg;
  let msg2 = "Goodbye" in
  print_string msg2</code></pre>
    </td>
<pre><code class="hljs">&lt;td&gt;
  &lt;pre&gt;&lt;code&gt;{
</code></pre>
<p>let msg = &quot;Hello&quot;;
print_string(msg);
let msg2 = &quot;Goodbye&quot;;
print_string(msg2)
};</code></pre>
</td></p>
  </tr>
</table>
<p>A sintaxe <code>{}</code> do Reason remove muitos pontos de dor (pontos fracos) comummente relatados na sintaxe do OCaml:</p>
<ul>
<li>Os pontos-e-vírgulas duplos foram completamente removidos.</li>
<li><code>início</code>/<code>fim</code> foi removido completamente.</li>
<li>Parâmetros imperiais infames <a href="https://github.com/ocaml/ocaml/pull/278">issue</a> se foram.</li>
<li>Body de módulos e escopo local foram unificados.</li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="escopo-local-vs-corpo-de-modulo"></a><a href="#escopo-local-vs-corpo-de-modulo" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Escopo Local Vs. Corpo de Módulo</h2>
<p>No Reason, tudo que puder ocorrer entre <code>{}</code> nos <a href="#local-scope">Escopos Locais</a> e nos corpos de módulos. Você geralmente pode até cortar/colar código entre os dois contextos. Em OCaml, as sintaxes para os dois contextos são muito diferentes. Escopo local requer <code>in</code> à direita, mas corpos de módulos não e algumas declarações imperativas devem ser atribuídas a <code>_</code> ou <code>()</code>, ou então usam <code>;;</code>.</p>
<table>
  <tr>
    <th>
      OCaml Module Body
    </th>
<pre><code class="hljs">&lt;th&gt;
  Reason Module Body
&lt;/th&gt;
</code></pre>
  </tr>
  <tr>
    <td>
      <pre><code class="hljs">let ten = 10
let () = imperativeFunc ten ten
let () = imperativeFunc 0 0</code></pre>
    </td>
<pre><code class="hljs">&lt;td&gt;
  &lt;pre&gt;&lt;code&gt;let ten = 10;
</code></pre>
<p>imperativeFunc(ten, ten);
imperativeFunc(0, 0);</code></pre>
</td></p>
  </tr>
  <tr>
    <td>
      <pre><code class="hljs">let ten = 10;;
imperativeFunc ten ten;;
imperativeFunc 0 0;;</code></pre>
    </td>
<pre><code class="hljs">&lt;td&gt;
  Same as above
&lt;/td&gt;
</code></pre>
  </tr>
  <tr>
    <th>
      OCaml Local Scope
    </th>
<pre><code class="hljs">&lt;th&gt;
  Reason Local Scope
&lt;/th&gt;
</code></pre>
  </tr>
  <tr>
    <td>
      <pre><code class="hljs">let ten = 10 in
let _ = imperativeFunc ten ten in
imperativeFunc 0 0</code></pre>
    </td>
<pre><code class="hljs">&lt;td&gt;
  Same as above
&lt;/td&gt;
</code></pre>
  </tr>
  <tr>
    <td>
      <pre><code class="hljs">let ten = 10 in begin
  imperativeFunc ten ten;
  imperativeFunc 0 0
end</code></pre>
    </td>
<pre><code class="hljs">&lt;td&gt;
  Same as above
&lt;/td&gt;
</code></pre>
  </tr>
  <tr>
    <td>
      <pre><code class="hljs">let ten = 10 in (
  imperativeFunc ten ten;
  imperativeFunc 0 0
)</code></pre>
    </td>
<pre><code class="hljs">&lt;td&gt;
  Same as above
&lt;/td&gt;
</code></pre>
  </tr>
</table>
<h2><a class="anchor" aria-hidden="true" id="tupla-e-record"></a><a href="#tupla-e-record" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Tupla e Record</h2>
<p>No Reason, tuplas sempre requerem parênteses.</p>
<table>
<thead>
<tr><th>OCaml</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td><code>let tup = 4, 5</code></td><td><code>let tup = (4, 5);</code></td></tr>
<tr><td><code>let tup = ((1: int), (2:int))</code></td><td><code>let tup = (1: int, 2:int);</code></td></tr>
<tr><td><code>fun ((a: int), (b: int)) -&gt; a</code></td><td><code>((a: int, b: int)) =&gt; a;</code></td></tr>
</tbody>
</table>
<p>In Reason, record values resemble JavaScript, using <code>:</code> instead of <code>=</code>.</p>
<table>
  <tr>
    <th>
      OCaml
    </th>
<pre><code class="hljs">&lt;th&gt;
  Reason
&lt;/th&gt;
</code></pre>
  </tr>
  <tr>
    <td>
      <pre><code class="hljs">let myRec = {x = 0; y = 10}</code></pre>
    </td>
<pre><code class="hljs">&lt;td&gt;
  &lt;pre&gt;&lt;code&gt;let myRec = {x: 0, y: 10};&lt;/code&gt;&lt;/pre&gt;
&lt;/td&gt;
</code></pre>
  </tr>
  <tr>
    <td>
      <pre><code class="hljs">let myFuncs = {
  myFun = (fun x -> x + 1);
  your = (fun a b -> a + b);
}</code></pre>
    </td>
<pre><code class="hljs">&lt;td&gt;
  &lt;pre&gt;&lt;code&gt;let myFuncs = {
</code></pre>
<p>myFun: (x) =&gt; x + 1,
your: (a, b) =&gt; a + b
};</code></pre>
</td></p>
  </tr>
</table>
<h2><a class="anchor" aria-hidden="true" id="listas"></a><a href="#listas" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Listas</h2>
<table>
<thead>
<tr><th>OCaml</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td><code>let list = [1; 2; 3]</code></td><td><code>let list = [1, 2, 3]</code></td></tr>
<tr><td><code>let list = hd :: tl</code></td><td><code>let list = [hd, ...tl];</code></td></tr>
</tbody>
</table>
<h2><a class="anchor" aria-hidden="true" id="definicões-de-tipo"></a><a href="#definicões-de-tipo" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Definições de Tipo</h2>
<table>
<thead>
<tr><th>Tupla OCaml</th><th>Tupla Reason</th></tr>
</thead>
<tbody>
<tr><td><code>type tuple = int * int</code></td><td><code>type tuple = (int, int);</code></td></tr>
<tr><td><code>let tup: tuple = (10, 30)</code></td><td><code>let tup: tuple = (10, 30);</code></td></tr>
</tbody>
</table>
<table>
<thead>
<tr><th>Registro de OCaml</th><th>Registro do Reason</th></tr>
</thead>
<tbody>
<tr><td><code>type r = {x: int; y: int}</code></td><td><code>type r = {x: int, y: int};</code></td></tr>
<tr><td><code>let myRec: r = {x = 0; y = 10}</code></td><td><code>let myRec: r = {x: 0, y: 10};</code></td></tr>
</tbody>
</table>
<table>
<thead>
<tr><th>Funções no OCaml</th><th>Funções no Reason</th></tr>
</thead>
<tbody>
<tr><td><code>type func = int -&gt; int</code></td><td><code>type func = int =&gt; int;</code></td></tr>
<tr><td><code>let x: func = fun a -&gt; a + 1</code></td><td><code>let x: func = (a) =&gt; a + 1;</code></td></tr>
</tbody>
</table>
<h2><a class="anchor" aria-hidden="true" id="funcões"></a><a href="#funcões" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Funções</h2>
<table>
<thead>
<tr><th>OCaml</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td><code>let x a b = e</code></td><td><code>let x = (a, b) =&gt; e</code></td></tr>
<tr><td><code>let x = fun a b -&gt; e</code></td><td><code>let x = (a, b) =&gt; e</code></td></tr>
<tr><td><code>let x = fun a -&gt; fun b -&gt; e</code></td><td><code>let x = (a, b) =&gt; e</code></td></tr>
</tbody>
</table>
<h3><a class="anchor" aria-hidden="true" id="funcões-com-casamento-de-argumento-unico"></a><a href="#funcões-com-casamento-de-argumento-unico" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Funções com casamento de argumento único</h3>
<p>OCaml tem uma definição de função (<code>function |</code>) que é considerado como equivalente de <code>function a -&gt; match a with ...</code>. Reason tem o mesmo, mas a sintaxe deixa claro como é na verdade uma extensão da função de argumento único. A correspondência de caso único é uma extensão natural do lambda simples, e o lambda múltiplo é uma extensão natural do lambda de caso único.</p>
<table>
  <tr>
    <th>
      Form
    </th>
<pre><code class="hljs">&lt;th&gt;
  OCaml
&lt;/th&gt;

&lt;th&gt;
  Reason
&lt;/th&gt;
</code></pre>
  </tr>
  <tr>
    <td>
      Lambda
    </td>
<pre><code class="hljs">&lt;td&gt;
  &lt;pre&gt;&lt;code&gt;fun pat -&gt; e&lt;/code&gt;&lt;/pre&gt;
&lt;/td&gt;

&lt;td&gt;
  &lt;pre&gt;&lt;code&gt;fun pat =&gt; e&lt;/code&gt;&lt;/pre&gt;
&lt;/td&gt;
</code></pre>
  </tr>
  <tr>
    <td>
      One match case
    </td>
<pre><code class="hljs">&lt;td&gt;
  &lt;pre&gt;&lt;code&gt;function | pat -&gt; e&lt;/code&gt;&lt;/pre&gt;
&lt;/td&gt;

&lt;td&gt;
  &lt;pre&gt;&lt;code&gt;fun | pat =&gt; e&lt;/code&gt;&lt;/pre&gt;
&lt;/td&gt;
</code></pre>
  </tr>
  <tr>
    <td>
      Many cases
    </td>
<pre><code class="hljs">&lt;td&gt;
  &lt;pre&gt;&lt;code&gt;function | pat -&gt; e
     | pat2 -&gt; e&lt;/code&gt;&lt;/pre&gt;
&lt;/td&gt;

&lt;td&gt;
  &lt;pre&gt;&lt;code&gt;fun | pat =&gt; e
| pat2 =&gt; e&lt;/code&gt;&lt;/pre&gt;
&lt;/td&gt;
</code></pre>
  </tr>
</table>
<h3><a class="anchor" aria-hidden="true" id="anotando-argumentos"></a><a href="#anotando-argumentos" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Anotando Argumentos</h3>
<p>Tanto o Reason como OCaml, argumentos são anotados com tipos por (como acontece com tudo o resto), envolvê-los entre parênteses depois acrescentando <code>: typeAnnotation</code>.</p>
<pre><code class="hljs css language-reason">(arg: tipoDeArg) =&gt; valorDeRetorno;
</code></pre>
<pre><code class="hljs css language-reason">(arg: tipoDeArg) =&gt; (arg2: tipoDeArg2) =&gt; valorDeRetorno;
</code></pre>
<pre><code class="hljs css language-reason">(arg: tipoDeArg, arg2: tipoDeArg2) =&gt; valorDeRetorno;
</code></pre>
<p>Tanto o Reason como OCaml permitem anotar o tipo de retorno, quando usando a forma &quot;super sugared let binding&quot;.</p>
<pre><code class="hljs css language-ocaml"><span class="hljs-comment">(* OCaml *)</span>
<span class="hljs-keyword">let</span> myFunc (a:<span class="hljs-built_in">int</span>) (b:<span class="hljs-built_in">int</span>) :<span class="hljs-built_in">int</span> * <span class="hljs-built_in">int</span> = (a, b)
<span class="hljs-keyword">let</span> myFunc (a:<span class="hljs-built_in">int</span>) (b:<span class="hljs-built_in">int</span>) :<span class="hljs-built_in">int</span> <span class="hljs-built_in">list</span> = [<span class="hljs-number">1</span>]
<span class="hljs-keyword">let</span> myFunc (a:<span class="hljs-built_in">int</span>) (b:<span class="hljs-built_in">int</span>) :<span class="hljs-built_in">int</span> -&gt; <span class="hljs-built_in">int</span> = <span class="hljs-keyword">fun</span> x -&gt; x + a + b
</code></pre>
<pre><code class="hljs css language-reason"><span class="hljs-comment">/* Reason */</span>
<span class="hljs-keyword">let</span> myFunc = (a: int, b: int): (int, int) =&gt; (a, b);
<span class="hljs-keyword">let</span> myFunc = (a: int, b: int): list(int) =&gt; <span class="hljs-literal">[</span><span class="hljs-number">1</span><span class="hljs-literal">]</span>;
<span class="hljs-keyword">let</span> myFunc = (a: int, b: int): (int =&gt; int) =&gt; (x) =&gt; x <span class="hljs-operator">+</span> a <span class="hljs-operator">+</span> b;
</code></pre>
<p>Porque estamos usando <code>=&gt;</code> para todas as funções no Reason, há um caso onde precisamos adicionar um parenteses extra em torno de um tipo de retorno que é em si um tipo de função.</p>
<h3><a class="anchor" aria-hidden="true" id="parametros-de-tipo"></a><a href="#parametros-de-tipo" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Parâmetros de Tipo</h3>
<h4><a class="anchor" aria-hidden="true" id="ocaml"></a><a href="#ocaml" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>OCaml</h4>
<p>Aplicações do tipo do OCaml (pense &quot;genéricas&quot;), são aplicadas na ordem inversa.</p>
<p>Com OCaml, existem algumas consequências não intuitivas para isso.</p>
<pre><code class="hljs css language-ocaml"><span class="hljs-keyword">let</span> x: <span class="hljs-built_in">int</span> <span class="hljs-built_in">list</span> = [<span class="hljs-number">2</span>]

<span class="hljs-keyword">type</span> listaDeListaDeInts = <span class="hljs-built_in">int</span> <span class="hljs-built_in">list</span> <span class="hljs-built_in">list</span>

<span class="hljs-comment">(* Traduzido como: *)</span>
<span class="hljs-keyword">type</span> listaDeListaDeInts = (<span class="hljs-built_in">int</span> <span class="hljs-built_in">list</span>) <span class="hljs-built_in">list</span>
</code></pre>
<p>As coisas ficam ainda mais estranhas quando parâmetros de tipo aceitam parâmetros múltiplos. Argumentos múltiplos requerem parênteses e vírgulas para separar os parâmetros de tipo, mas esses parênteses não representam tuplas. A forma de parênteses/vírgula também deve ser dada ao construir instâncias de tipo tais como <code>(int, string) tupla</code>.</p>
<pre><code class="hljs css language-ocaml"><span class="hljs-keyword">type</span> (<span class="hljs-symbol">'a</span>, <span class="hljs-symbol">'b</span>) tupla = <span class="hljs-symbol">'a</span> * <span class="hljs-symbol">'b</span>

<span class="hljs-keyword">type</span> listaDeTuplasDeStringEInt = (<span class="hljs-built_in">string</span>, <span class="hljs-built_in">int</span>) tupla <span class="hljs-built_in">list</span>

<span class="hljs-comment">(* Que é traduzido como: *)</span>
<span class="hljs-keyword">type</span> listaDeTuplasDeStringEInt = ((<span class="hljs-built_in">string</span>, <span class="hljs-built_in">int</span>) tupla) <span class="hljs-built_in">list</span>

<span class="hljs-comment">(* Que permite uma lista de (tuplas de (string e int)) *)</span>
<span class="hljs-keyword">let</span> tuplas: listaDeTuplasDeStringEInt = [(<span class="hljs-string">"asdf"</span>, <span class="hljs-number">3</span>)]
</code></pre>
<h4><a class="anchor" aria-hidden="true" id="reason"></a><a href="#reason" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Reason</h4>
<p>Em resumo, o Reason unifica quase toda a sintaxe no estilo simples de &quot;aplicação de função&quot;, o que significa que os parâmetros de tipo seguem o mesmo padrão separado por vírgula visto em qualquer outro lugar na sintaxe. Isso resulta em menos padrões sintáticos para aprender.</p>
<p>Por exemplo, você pode imaginar <code>list</code> ser uma &quot;função&quot; para tipos que aceita um tipo e retorna um novo tipo.</p>
<table>
  <tr>
    <th>
      OCaml
    </th>
<pre><code class="hljs">&lt;th&gt;
  Reason
&lt;/th&gt;
</code></pre>
  </tr>
  <tr>
    <td>
      <pre><code class="hljs">let x: int list = [2]
type listOfListOfInts = int list list
type ('a, 'b) tup = ('a * 'b)
type pairs = (int, int) tup list
let tuples: pairs = [(2, 3)]</code></pre>
    </td>
<pre><code class="hljs">&lt;td&gt;
  &lt;pre&gt;&lt;code&gt;let x: list(int) = [2];
</code></pre>
<p>type listOfListOfInts = list(list(int));
type tup('a, 'b) = ('a, 'b);
type pairs = list(tup(int, int));
let tuples: pairs = [(2, 3)];</code></pre>
</td></p>
  </tr>
</table>
<h2><a class="anchor" aria-hidden="true" id="tuplas-como-parametros-de-tipo"></a><a href="#tuplas-como-parametros-de-tipo" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Tuplas Como Parâmetros de Tipo</h2>
<p>Como o OCaml usa parenteses e vírgulas para representar argumentos múltiplos para construtores de tipo, é confuso quando um dos argumentos para um construtor de tipo é uma tupla ele próprio. Na OCaml, é difícil lembrar a diferença entre um construtor de tipos aceitando vários argumentos e um construtor de tipo aceitando um único argumento que acontece de ser um tupla.</p>
<p>Os exemplos a seguir mostram a diferença entre passar *dois * tipos de parâmetros para <code>par</code>, e um parâmetro de tipo <em>single</em> que na verdade é um tuple.</p>
<table>
<thead>
<tr><th>OCaml</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td><code>type intPar = (int, int) pair</code></td><td><code>type intPar = pair(int, int)</code></td></tr>
<tr><td><code>type listaPar = (int * int) list</code></td><td><code>type listaPar = list((int, int))</code></td></tr>
</tbody>
</table>
<ul>
<li>No Reason, sintaxes que representam tuplas ou tipos de tuplas, sempre se parecem com tuplas.</li>
<li>No Reason, sintaxes que representam registros ou tipos de registros, sempre se parecem com registros.</li>
<li>Quase todo o resto usa o padrão sintático de aplicação de função (argumentos separados por vírgula).</li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="variantes"></a><a href="#variantes" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Variantes</h2>
<h5><a class="anchor" aria-hidden="true" id="ocaml-1"></a><a href="#ocaml-1" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>OCaml</h5>
<ul>
<li>OCaml já espera que os tipos de argumentos do construtor sejam especificados no formulário de tuple, por isso fica confuso quando um único construtor espera um argumento único que <em>acontece</em> de ser um tipo de tuple.</li>
<li>O que é ainda mais confuso é que os construtores não <em>realmente</em> aceitam tuplas, ainda que a sintaxe pareça assemelhar-se tuplas.</li>
<li>Às vezes, a sintaxe para instanciar um construtor com vários argumentos sobrepõe a sintaxe para construir uma variante com um único argumento que acontece de ser uma tupla - então parece <em>exatamente</em> que você <em>está</em> fornecendo uma tupla quando você não está realmente fornecendo uma tupla.</li>
</ul>
<h5><a class="anchor" aria-hidden="true" id="reason-1"></a><a href="#reason-1" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Reason</h5>
<ul>
<li>Tipos de construtores de variantes devem ser listados como listas separadas por vírgulas, usando parênteses para preceder grupo (como com ** todo** resto).</li>
<li>Construir instâncias da variante (como você teria adivinhado) segue o estilo de aplicação de função (listas separadas por vírgulas).</li>
<li>Tuplas <strong>sempre</strong> <em>parecem</em> como tuplas e qualquer coisa que se pareça com uma tupla <em>é</em> uma tupla.</li>
</ul>
<table>
  <tr>
    <th>
      OCaml
    </th>
<pre><code class="hljs">&lt;th&gt;
  Reason
&lt;/th&gt;
</code></pre>
  </tr>
  <tr>
    <td>
      <pre><code class="hljs">type myVariant =
  | HasNothing
  | HasSingleInt of int
  | HasSingleTuple of (int * int)
  | HasMultipleInts of int * int
  | HasMultipleTuples of (int * int) * (int * int)</code></pre>
    </td>
<pre><code class="hljs">&lt;td&gt;
  &lt;pre&gt;&lt;code&gt;type myVariant =
</code></pre>
<p>| HasNothing
| HasSingleInt(int)
| HasSingleTuple((int, int))
| HasMultipleInts(int, int)
| HasMultipleTuples((int, int), (int, int));</code></pre>
</td></p>
  </tr>
  <tr>
    <td>
      <pre><code class="hljs">let a = HasSingleInt 10
let a = HasSingleTuple (10, 10)
let a = HasMultipleInts (10, 10)
let a = HasMultipleTuples ((10, 10), (10, 10))</code></pre>
    </td>
<pre><code class="hljs">&lt;td&gt;
  &lt;pre&gt;&lt;code&gt;let a = HasSingleInt(10);
</code></pre>
<p>let a = HasSingleTuple((10, 10));
let a = HasMultipleInts(10, 10);
let a = HasMultipleTuples((10, 10), (10, 10));</code></pre>
</td></p>
  </tr>
  <tr>
    <td>
      <pre><code class="hljs">let res x = match x with
  | HasNothing -> 0
  | HasSingleInt x -> 0
  | HasSingleTuple (x, y) -> 0
  | HasMultipleInts (x, y) -> 0
  | HasMultipleTuples ((x, y), (q, r)) -> 0</code></pre>
    </td>
<pre><code class="hljs">&lt;td&gt;
  &lt;pre&gt;&lt;code&gt;let res = (x) =&gt;
</code></pre>
<p>switch (x) {
| HasNothing =&gt; 0
| HasSingleInt(x) =&gt; 0
| HasSingleTuple((x, y)) =&gt; 0
| HasMultipleInts(x, y) =&gt; 0
| HasMultipleTuples((x, y), (q, r)) =&gt; 0
};</code></pre>
</td></p>
  </tr>
</table>
<h2><a class="anchor" aria-hidden="true" id="casamento-de-padrões"></a><a href="#casamento-de-padrões" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Casamento de Padrões</h2>
<table>
  <tr>
    <th>
      OCaml
    </th>
<pre><code class="hljs">&lt;th&gt;
  Reason
&lt;/th&gt;
</code></pre>
  </tr>
  <tr>
    <td>
      <pre><code class="hljs">let res = match x with
  | A (x, y) -> match y with
    | None -> 0
    | Some i -> 10
  | B (x, y) -> 0</code></pre>
    </td>
<pre><code class="hljs">&lt;td&gt;
  &lt;pre&gt;&lt;code&gt;let res = switch (x) {
</code></pre>
<p>| A((x, y)) =&gt; switch (y) {
| None =&gt; 0
| Some(i) =&gt; 10
}
| B((x, y)) =&gt; 0
};</code></pre>
</td></p>
  </tr>
</table>
<p>Você consegue detectar o erro no exemplo OCaml? Este é um dos erros mais comuns entre os programadores OCaml. O <code>match</code> aninhado <em>deve</em> ser encapsulado entre parênteses, caso contrário o caso <code>Some</code> é analisado como pertencente à correspondência <code>match</code> externo. Visualmente, é na verdade:</p>
<pre><code class="hljs css language-ocaml"><span class="hljs-keyword">let</span> res = <span class="hljs-keyword">match</span> x <span class="hljs-keyword">with</span>
  | <span class="hljs-type">A</span> (x, y) -&gt; <span class="hljs-keyword">match</span> y <span class="hljs-keyword">with</span>
    | <span class="hljs-type">None</span> -&gt; <span class="hljs-number">0</span>
    | <span class="hljs-type">Some</span> i -&gt; <span class="hljs-number">10</span>
    | <span class="hljs-type">B</span> (x, y) -&gt; <span class="hljs-number">0</span>
</code></pre>
<p>Os casos obrigatórios de <code>{}</code> em torno de <code>switch</code> evitam esse problema.</p>
<h2><a class="anchor" aria-hidden="true" id="modulos-e-assinaturas"></a><a href="#modulos-e-assinaturas" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Módulos e Assinaturas</h2>
<h3><a class="anchor" aria-hidden="true" id="definicão"></a><a href="#definicão" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Definição</h3>
<table>
  <tr>
    <th>
      OCaml
    </th>
<pre><code class="hljs">&lt;th&gt;
  Reason
&lt;/th&gt;
</code></pre>
  </tr>
  <tr>
    <td>
      <pre><code class="hljs">module type MySig = sig
  type t = int
  val x: int
end
module MyModule: MySig = struct
  type t = int
  let x = 10
end
module MyModule = struct
  module NestedModule = struct
     let msg = "hello";
  end
end</code></pre>
    </td>
<pre><code class="hljs">&lt;td&gt;
  &lt;pre&gt;&lt;code&gt;module type MySig = {
</code></pre>
<p>type t = int;
let x: int;
};
module MyModule: MySig = {
type t = int;
let x = 10;
};
module MyModule = {
module NestedModule = {
let msg = &quot;hello&quot;;
};
};</code></pre>
</td></p>
  </tr>
</table>
<h3><a class="anchor" aria-hidden="true" id="tipos-de-funtores"></a><a href="#tipos-de-funtores" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Tipos de Funtores</h3>
<table>
  <tr>
    <th>
      OCaml
    </th>
<pre><code class="hljs">&lt;th&gt;
  Reason
&lt;/th&gt;
</code></pre>
  </tr>
  <tr>
    <td>
      <pre><code class="hljs">module type FType =
  functor (A: ASig) ->
  functor (B: BSig) -> Result</code></pre>
    </td>
<pre><code class="hljs">&lt;td&gt;
  &lt;pre&gt;&lt;code&gt;module type FType =
</code></pre>
<p>(A: ASig) =&gt;
(B: BSig) =&gt; Result;</code></pre>
</td></p>
  </tr>
</table>
<h2><a class="anchor" aria-hidden="true" id="funtores"></a><a href="#funtores" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Funtores</h2>
<table>
  <tr>
    <th>
      OCaml
    </th>
<pre><code class="hljs">&lt;th&gt;
  Reason
&lt;/th&gt;
</code></pre>
  </tr>
  <tr>
    <td>
      <pre><code class="hljs">module F =
  functor (A: ASig) ->
  functor (B: BSig) -> struct end</code></pre>
    </td>
<pre><code class="hljs">&lt;td&gt;
  &lt;pre&gt;&lt;code&gt;module F =
</code></pre>
<p>(A: ASig) =&gt;
(B: BSig) =&gt; {};</code></pre>
</td></p>
  </tr>
  <tr>
    <td>
      <pre><code class="hljs">module F = functor (A: ASig) (B: BSig) -> struct end</code></pre>
    </td>
<pre><code class="hljs">&lt;td&gt;
  &lt;pre&gt;&lt;code&gt;module F = (A: ASig, B: BSig) =&gt; {};&lt;/code&gt;&lt;/pre&gt;
&lt;/td&gt;
</code></pre>
  </tr>
  <tr>
    <td>
      <pre><code class="hljs">module F (A: ASig) (B: BSig) = struct end</code></pre>
    </td>
<pre><code class="hljs">&lt;td&gt;
  &lt;pre&gt;&lt;code&gt;module F = (A: ASig, B: BSig) =&gt; {};&lt;/code&gt;&lt;/pre&gt;
&lt;/td&gt;
</code></pre>
  </tr>
  <tr>
    <td>
      <pre><code class="hljs">module Res = F(A)(B)</code></pre>
    </td>
<pre><code class="hljs">&lt;td&gt;
  &lt;pre&gt;&lt;code&gt;module Res = F(A, B);&lt;/code&gt;&lt;/pre&gt;
&lt;/td&gt;
</code></pre>
  </tr>
</table>
<h2><a class="anchor" aria-hidden="true" id="melhorias-variadas"></a><a href="#melhorias-variadas" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Melhorias Variadas</h2>
<p>OCaml não requer parênteses ao redor de sequências <code>(a;b;c;d)</code> ou tuplas <code>(x,y)</code> então isso acaba impedindo a aplicação de várias outras regras sintáticas muito convenientes. Como o Reason sempre usa <code>{}</code> para cercar sequências ou declarações let, e o Reason sempre requer o uso de <code>()</code> cercando tuplas, muitos outros construtos de sintaxe são expressados de forma mais intuitiva, sem precisar de parênteses extras.</p>
<h3><a class="anchor" aria-hidden="true" id="lambdas-como-campos-de-registros-não-precisam-mais-de-parenteses-extras"></a><a href="#lambdas-como-campos-de-registros-não-precisam-mais-de-parenteses-extras" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Lambdas como campos de registros não precisam mais de parênteses extras</h3>
<p>Essa é uma melhoria bem-vinda porque os erros de tipo de OCaml que o usuário veriam eram muito confusos quando o sistema acreditava que o tipo de retorno da função seria uma tupla com vírgula <code>,</code> infixa.</p>
<table>
  <tr>
    <th>
      OCaml
    </th>
<pre><code class="hljs">&lt;th&gt;
  Reason
&lt;/th&gt;
</code></pre>
  </tr>
  <tr>
    <td>
      <pre><code class="hljs">let myFuncs = {
  myFun = (fun x -> x + 1);
  your = (fun a b -> a + b);
}</code></pre>
    </td>
<pre><code class="hljs">&lt;td&gt;
  &lt;pre&gt;&lt;code&gt;let myFuncs = {
</code></pre>
<p>myFun: (x) =&gt; x + 1,
your: (a, b) =&gt; a + b
};</code></pre>
</td></p>
  </tr>
</table>
<h3><a class="anchor" aria-hidden="true" id="lambdas-como-resultado-de-casamento-de-padrões-não-precisam-mais-de-parenteses-extras"></a><a href="#lambdas-como-resultado-de-casamento-de-padrões-não-precisam-mais-de-parenteses-extras" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Lambdas como resultado de casamento de padrões não precisam mais de parênteses extras</h3>
<table>
  <tr>
    <th>
      OCaml
    </th>
<pre><code class="hljs">&lt;th&gt;
  Reason
&lt;/th&gt;
</code></pre>
  </tr>
  <tr>
    <td>
      <pre><code class="hljs">let x = match prnt with
  | None -> fun a -> blah
  (* Extra () required ! *)
  | Some "_" -> (fun a -> ())
  | Some "ml" -> blah</code></pre>
    </td>
<pre><code class="hljs">&lt;td&gt;
  &lt;pre&gt;&lt;code&gt;let x =
</code></pre>
<p>switch (prnt) {
| None =&gt; (a) =&gt; blah
| Some(&quot;_&quot;) =&gt; (a) =&gt; ()
| Some(&quot;ml&quot;) =&gt; blah
};</code></pre>
</td></p>
  </tr>
</table>
<h3><a class="anchor" aria-hidden="true" id="lambdas-e-anotacões-de-tipos-em-tuplas-não-requerem-mais-parenteses-adicionais"></a><a href="#lambdas-e-anotacões-de-tipos-em-tuplas-não-requerem-mais-parenteses-adicionais" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Lambdas e anotações de tipos em tuplas não requerem mais parênteses adicionais</h3>
<table>
<thead>
<tr><th>OCaml</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td><code>let tuple = ((fun x -&gt; x), 20)</code></td><td><code>let tuple = ((x) =&gt; x, 20);</code></td></tr>
<tr><td><code>let tuple = ((&quot;olar&quot;: string), (20: int))</code></td><td><code>let tuple = (&quot;olar&quot;: string, 20: int);</code></td></tr>
</tbody>
</table>
<h2><a class="anchor" aria-hidden="true" id="diferencas-variadas"></a><a href="#diferencas-variadas" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Diferenças Variadas</h2>
<h3><a class="anchor" aria-hidden="true" id="precedencia-de-as"></a><a href="#precedencia-de-as" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Precedência de <code>as</code></h3>
<p>Em Reason, o <code>as</code> tem maior precedência que a <code>|</code> barra. Isso permite criar pseudônimos <code>as</code> para linhas inteiras quando casando padrões.</p>
<table>
  <tr>
    <th>
      OCaml
    </th>
<pre><code class="hljs">&lt;th&gt;
  Reason
&lt;/th&gt;
</code></pre>
  </tr>
  <tr>
    <td>
      <pre><code class="hljs">let ppp = match MyThing 20 with
  | (MyThing x as ppp)
  | (YourThing x as ppp) -> ppp;</code></pre>
    </td>
<pre><code class="hljs">&lt;td&gt;
  &lt;pre&gt;&lt;code&gt;let ppp =
</code></pre>
<p>switch (MyThing(20)) {
| MyThing(x) as ppp
| YourThing(x) as ppp =&gt; ppp
};</code></pre>
</td></p>
  </tr>
</table>
<h3><a class="anchor" aria-hidden="true" id="atualizacões-de-campos-de-registros-mutaveis"></a><a href="#atualizacões-de-campos-de-registros-mutaveis" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Atualizações de Campos de Registros Mutáveis</h3>
<p>Como igualdades e suas negações foram tornadas mais consistentes no Reason, o operador <code>=</code> está disponível para atualização de campos mutáveis.</p>
<table>
<thead>
<tr><th>OCaml</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td><code>myRec.field &lt;- &quot;proximo&quot;</code></td><td><code>myRec.field = &quot;proximo&quot;</code></td></tr>
</tbody>
</table>
<h3><a class="anchor" aria-hidden="true" id="operadores-prefixos"></a><a href="#operadores-prefixos" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Operadores prefixos</h3>
<p>No Reason, o operador <code>!</code> é usado para a negação booleana (<code>not</code>). O derreferenciamento usa o operador pósfixo <code>ˆ</code>.</p>
<table>
<thead>
<tr><th>OCaml</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td><code>let x = !(foo.bar)</code></td><td><code>let x = foo.bar^;</code></td></tr>
<tr><td><code>let x = !(foo#bar)</code></td><td><code>let x = foo#bar^;</code></td></tr>
<tr><td><code>let x = !(!foo.bar)</code></td><td><code>let x = foo^.bar^;</code></td></tr>
<tr><td><code>let x = !(!foo#bar)</code></td><td><code>let x = (foo^)#bar^;</code></td></tr>
<tr><td><code>let x = !(!(foo.bar))</code></td><td><code>let x = foo.bar^ ^;</code></td></tr>
<tr><td><code>let x = !(!(foo#bar))</code></td><td><code>let x = foo#bar^ ^;</code></td></tr>
<tr><td><code>let x = !!(foo.bar)</code></td><td><code>let x = !!foo.bar;</code></td></tr>
<tr><td><code>let x = !!(foo#bar)</code></td><td><code>let x = !!foo#bar;</code></td></tr>
<tr><td><code>let x = !~(foo.bar)</code></td><td><code>let x = !~foo.bar;</code></td></tr>
<tr><td><code>let x = !~(foo#bar)</code></td><td><code>let x = !~foo#bar;</code></td></tr>
</tbody>
</table>
<h3><a class="anchor" aria-hidden="true" id="escapando-comentarios"></a><a href="#escapando-comentarios" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Escapando Comentários</h3>
<p>Como o Reason usa comentários no estilo C, alguns operadores prefixos ou infixos obscuros precisam ser escritos de forma distinta. As regras para operadores prefixos ou infixos são as mesmas que na sintaxe de OCaml, com as seguintes exceções:</p>
<p>Especificamente, se qualquer caractere exceto o primeiro e um operador prefixo ou infixo é um asterisco ou uma barra, esse caractere deve ser escapado com uma barra invertida. Esses operadores serão analisados <em>sem</em> a barra invertida quando adicionados à AST. Quando impressos, as barras invertidas de escape serão adicionadas de volta automaticamente.</p>
<table>
<thead>
<tr><th>OCaml</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td><code>let (/*) a b = a + b</code></td><td><code>let (/\*) = (a, b) =&gt; a + b;</code></td></tr>
<tr><td><code>let x = 12 /-* 23 /-* 12</code></td><td><code>let x = 12 /-* 23 /-* 12;</code></td></tr>
<tr><td><code>let y = (/*) a b</code></td><td><code>let y = a /\* b;</code></td></tr>
<tr><td><code>let (!=*) q r = q + r</code></td><td><code>let ( !=* ) = (q, r) =&gt; q + r;</code></td></tr>
<tr><td><code>let res = q (!=*) r</code></td><td><code>let res = q(( !=* ), r);</code></td></tr>
<tr><td><code>let (!=/*) q r = q + r</code></td><td><code>let ( !=/\* ) = (q, r) =&gt; q + r;</code></td></tr>
<tr><td><code>let res = q (!=/*) r</code></td><td><code>let res = q(( !=/\* ), r);</code></td></tr>
</tbody>
</table>
<h3><a class="anchor" aria-hidden="true" id="renomeando-operadores-1"></a><a href="#renomeando-operadores-1" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Renomeando Operadores</h3>
<p>Se o Reason usa <code>==</code> para representar o <code>=</code> de OCaml, e usa o <code>===</code> para representar o <code>==</code> de OCaml, então como o Reason representaria o <code>===</code> de OCaml (se tal operador fosse definido)? Reason dá um jeito! &quot;Escape&quot; o símbolo de igual triplo!</p>
<table>
<thead>
<tr><th>Identificador</th><th>Significado</th><th>OCaml</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td><code>&quot;===&quot;</code></td><td>Valor personalizado</td><td><code>x === y</code></td><td><code>x \=== y</code></td></tr>
</tbody>
</table>
<h3><a class="anchor" aria-hidden="true" id="repl"></a><a href="#repl" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>REPL</h3>
<p>Na REPL do Reason, <a href="/docs/pt-BR/extra-goodies#repl"><code>rtop</code></a> (Uma versão customizada do <a href="https://github.com/diml/utop"><code>utop</code></a>), cada entrada é submetida usando um único <code>;</code> ponto e vírgula. A REPL do Ocaml precisa de dois pontos e vírgulas <code>;;</code>.</p>
<table>
<thead>
<tr><th>OCaml</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td><code>;;</code></td><td><code>;</code></td></tr>
</tbody>
</table>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/pt-BR/faq"><span class="arrow-prev">← </span><span>Frequently Asked Questions</span></a><a class="docs-next button" href="/docs/pt-BR/newcomer-examples"><span>Newcomer Examples</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#comentarios">Comentários</a></li><li><a href="#renomeando-operadores">Renomeando Operadores</a></li><li><a href="#escopo-local">Escopo Local</a></li><li><a href="#escopo-local-vs-corpo-de-modulo">Escopo Local Vs. Corpo de Módulo</a></li><li><a href="#tupla-e-record">Tupla e Record</a></li><li><a href="#listas">Listas</a></li><li><a href="#definicões-de-tipo">Definições de Tipo</a></li><li><a href="#funcões">Funções</a><ul class="toc-headings"><li><a href="#funcões-com-casamento-de-argumento-unico">Funções com casamento de argumento único</a></li><li><a href="#anotando-argumentos">Anotando Argumentos</a></li><li><a href="#parametros-de-tipo">Parâmetros de Tipo</a></li></ul></li><li><a href="#tuplas-como-parametros-de-tipo">Tuplas Como Parâmetros de Tipo</a></li><li><a href="#variantes">Variantes</a></li><li><a href="#casamento-de-padrões">Casamento de Padrões</a></li><li><a href="#modulos-e-assinaturas">Módulos e Assinaturas</a><ul class="toc-headings"><li><a href="#definicão">Definição</a></li><li><a href="#tipos-de-funtores">Tipos de Funtores</a></li></ul></li><li><a href="#funtores">Funtores</a></li><li><a href="#melhorias-variadas">Melhorias Variadas</a><ul class="toc-headings"><li><a href="#lambdas-como-campos-de-registros-não-precisam-mais-de-parenteses-extras">Lambdas como campos de registros não precisam mais de parênteses extras</a></li><li><a href="#lambdas-como-resultado-de-casamento-de-padrões-não-precisam-mais-de-parenteses-extras">Lambdas como resultado de casamento de padrões não precisam mais de parênteses extras</a></li><li><a href="#lambdas-e-anotacões-de-tipos-em-tuplas-não-requerem-mais-parenteses-adicionais">Lambdas e anotações de tipos em tuplas não requerem mais parênteses adicionais</a></li></ul></li><li><a href="#diferencas-variadas">Diferenças Variadas</a><ul class="toc-headings"><li><a href="#precedencia-de-as">Precedência de <code>as</code></a></li><li><a href="#atualizacões-de-campos-de-registros-mutaveis">Atualizações de Campos de Registros Mutáveis</a></li><li><a href="#operadores-prefixos">Operadores prefixos</a></li><li><a href="#escapando-comentarios">Escapando Comentários</a></li><li><a href="#renomeando-operadores-1">Renomeando Operadores</a></li><li><a href="#repl">REPL</a></li></ul></li></ul></nav></div><span><script src="/js/redirectBlog.js"></script><script src="/js/pjax-api.min.js"></script><script>window.foo = new Pjax({
          areas: [
            // try to use the first query.
            '.mainContainer, .docsNavContainer .toc .navWrapper, .onPageNav',
            // fallback
            'body'
          ],
          link: '.docsNavContainer:not(.docsSliderActive) a',
          update: {
            script: false,
          }
        });
        var languagesMenuItemCopy = document.getElementById("languages-menu");
        languagesMenuItemCopy.addEventListener("click", function(e){
          e.preventDefault();
          e.stopPropagation();
          e.stopImmediatePropagation();
        });</script></span></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                
                apiKey: '966d1e412f67114a07dc0afe44b19b53',
                indexName: 'reason',
                inputSelector: '#search_input_react',
                algoliaOptions: {"facetFilters":["lang:pt-BR"]}
              });
            </script></body></html>