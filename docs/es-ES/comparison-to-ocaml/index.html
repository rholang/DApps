<!DOCTYPE html><html lang="es-ES"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Comparison to OCaml · Reason</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="&lt;p&gt;Si vienes de OCaml o eres un novato que está leyendo un tutorial de OCaml, ¡Esta guía es para ti! Pero no olvides que &lt;a href=&quot;https://github.com/reasonml/reason-tools&quot;&gt;reason-tools&lt;/a&gt; puede convertir la sintaxis entre OCaml y Reason al vuelo.&lt;/p&gt;
"/><meta name="docsearch:language" content="es-ES"/><meta property="og:title" content="Comparison to OCaml · Reason"/><meta property="og:type" content="website"/><meta property="og:url" content="https://reasonml.github.io/"/><meta property="og:description" content="&lt;p&gt;Si vienes de OCaml o eres un novato que está leyendo un tutorial de OCaml, ¡Esta guía es para ti! Pero no olvides que &lt;a href=&quot;https://github.com/reasonml/reason-tools&quot;&gt;reason-tools&lt;/a&gt; puede convertir la sintaxis entre OCaml y Reason al vuelo.&lt;/p&gt;
"/><meta name="twitter:card" content="summary"/><link rel="shortcut icon" href="/img/icon_50.png"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"/><link rel="alternate" type="application/atom+xml" href="https://reasonml.github.io/blog/atom.xml" title="Reason Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://reasonml.github.io/blog/feed.xml" title="Reason Blog RSS Feed"/><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/es-ES"><img class="logo" src="/img/dummy.svg" alt="Reason"/></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/docs/es-ES/what-and-why" target="_self">Docs</a></li><li class=""><a href="/es-ES/try" target="_self">Try</a></li><li class=""><a href="/api/index" target="_self">API</a></li><li class=""><a href="/docs/es-ES/community" target="_self">Community</a></li><li class=""><a href="/blog/" target="_self">Blog</a></li><span><li><a id="languages-menu" href="#"><img class="languages-icon" src="/img/language.svg" alt="Languages icon"/>Español</a><div id="languages-dropdown" class="hide"><ul id="languages-dropdown-items"><li><a href="/docs/ja/comparison-to-ocaml">日本語</a></li><li><a href="/docs/en/comparison-to-ocaml">English</a></li><li><a href="/docs/de/comparison-to-ocaml">Deutsch</a></li><li><a href="/docs/fr/comparison-to-ocaml">Français</a></li><li><a href="/docs/ko/comparison-to-ocaml">한국어</a></li><li><a href="/docs/pt-BR/comparison-to-ocaml">Português (Brasil)</a></li><li><a href="/docs/ru/comparison-to-ocaml">Русский</a></li><li><a href="/docs/uk/comparison-to-ocaml">Українська</a></li><li><a href="/docs/zh-CN/comparison-to-ocaml">中文</a></li><li><a href="/docs/zh-TW/comparison-to-ocaml">繁體中文</a></li><li><a href="https://crowdin.com/project/reason" target="_blank" rel="noreferrer noopener">Ayuda a traducir</a></li></ul></div></li><script>
        const languagesMenuItem = document.getElementById("languages-menu");
        const languagesDropDown = document.getElementById("languages-dropdown");
        languagesMenuItem.addEventListener("click", function(event) {
          event.preventDefault();

          if (languagesDropDown.className == "hide") {
            languagesDropDown.className = "visible";
          } else {
            languagesDropDown.className = "hide";
          }
        });
      </script></span><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li><li class=""><a href="https://github.com/facebook/reason" target="_self">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><i></i></div><h2><i>›</i><span>Extra</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Intro</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/es-ES/what-and-why">What &amp; Why</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Setup</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/es-ES/installation">Installation</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/editor-plugins">Editor Plugins</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/extra-goodies">Extra Goodies</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Language Basics</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/es-ES/overview">Overview</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/let-binding">Let Binding</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/type">Type!</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/string-and-char">String &amp; Char</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/boolean">Boolean</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/integer-and-float">Integer &amp; Float</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/tuple">Tuple</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/record">Record</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/variant">Variant!</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/null-undefined-option">Null, Undefined &amp; Option</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/list-and-array">List &amp; Array</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/function">Function</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/if-else">If-Else</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/pipe-first">Pipe First</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/more-on-type">More on Type</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/destructuring">Destructuring</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/pattern-matching">Pattern Matching!</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/mutation">Mutation</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/imperative-loops">Imperative Loops</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/jsx">JSX</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/external">External</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/exception">Exception</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/object">Object</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/module">Module</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/promise">Promise</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">JavaScript</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/es-ES/interop">Interop</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/syntax-cheatsheet">Syntax Cheatsheet</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/libraries">Libraries</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/converting-from-js">Converting from JS</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Native</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/es-ES/native">Native</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/quickstart-ocaml">Native Quickstart</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/convert-from-ocaml">Converting from OCaml</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Extra</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/es-ES/faq">Frequently Asked Questions</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/docs/es-ES/comparison-to-ocaml">Comparison to OCaml</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/newcomer-examples">Newcomer Examples</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/project-structure">Project Structure</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              const headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                if (event.target.tagName === 'A') {
                  document.body.classList.remove('tocActive');
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://crowdin.com/project/reason/es-ES" target="_blank" rel="noreferrer noopener">Translate</a><h1 class="postHeaderTitle">Comparison to OCaml</h1></header><article><div><span><p>Si vienes de OCaml o eres un novato que está leyendo un tutorial de OCaml, ¡Esta guía es para ti! Pero no olvides que <a href="https://github.com/reasonml/reason-tools">reason-tools</a> puede convertir la sintaxis entre OCaml y Reason al vuelo.</p>
<h2><a class="anchor" aria-hidden="true" id="comentarios"></a><a href="#comentarios" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Comentarios</h2>
<table>
<thead>
<tr><th>OCaml</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td><code>(* OCaml (*nest*) *)</code></td><td><code>/* Reason /*nest*/ */</code></td></tr>
</tbody>
</table>
<h2><a class="anchor" aria-hidden="true" id="renombrar-el-operador"></a><a href="#renombrar-el-operador" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Renombrar el operador</h2>
<p>Reason tiene todo los operadores infijos de Ocaml, pero unos pocos se expresan de manera diferente. En Reason, la igualdad estructural se escribe <code>==</code>, y la igualdad referencial (física) <code>===</code>. En Reason, para obtener la desigualdad correspondiente, simplemente cambia el primer carácter por <code>!</code>. (<code>!=</code> para desigualdad estructural, y <code>!==</code> para desigualdad referencial).</p>
<table>
<thead>
<tr><th>Igualdad</th><th>OCaml</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td>Estructural</td><td><code>x = y</code></td><td><code>x == y</code></td></tr>
<tr><td>Referencial</td><td><code>x == y</code></td><td><code>x === y</code></td></tr>
</tbody>
</table>
<table>
<thead>
<tr><th>Desigualdad</th><th>OCaml</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td>Estructural</td><td><code>x &lt;&gt; y</code></td><td><code>x != y</code></td></tr>
<tr><td>Referencial</td><td><code>x != y</code></td><td><code>x !== y</code></td></tr>
</tbody>
</table>
<h2><a class="anchor" aria-hidden="true" id="ambito-local"></a><a href="#ambito-local" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Ámbito local</h2>
<p>El ámbito léxico de Reason es exactamente igual al de OCaml, pero los enlaces se parecen más sintácticamente a el &quot;ámbito de bloque&quot; que es más familiar para muchos desarrolladores. En Reason, esto son creados con llaves <code>{}</code>, las cuales pueden contener ambos <code>let</code> enlaces y comandos imperativos, separados por <code>;</code>. Todos los bloques son evaluados hasta la última línea y el punto y coma en esta es opcional. Las llaves<code>{}</code> son solo necesarias si tienes más de un ítem que enlazar vía <code>;</code>.</p>
<table>
  <tr>
    <th>
      OCaml
    </th>
<pre><code class="hljs">&lt;th&gt;
  Reason
&lt;/th&gt;
</code></pre>
  </tr>
  <tr>
    <td>
      <pre><code class="hljs">let _ =
  let msg = "Hello" in
  print_string msg;
  let msg2 = "Goodbye" in
  print_string msg2</code></pre>
    </td>
<pre><code class="hljs">&lt;td&gt;
  &lt;pre&gt;&lt;code&gt;{
</code></pre>
<p>let msg = &quot;Hello&quot;;
print_string(msg);
let msg2 = &quot;Goodbye&quot;;
print_string(msg2)
};</code></pre>
</td></p>
  </tr>
</table>
<p>La sintaxis <code>{}</code> de Reason elimina muchos de los aspectos molestos habitualmente comunicados en la sintaxis de Ocaml:</p>
<ul>
<li>Los punto y coma dobles están eliminados totalmente.</li>
<li><code>begin</code>/<code>end</code> están eliminados por completo.</li>
<li>Los infames <a href="https://github.com/ocaml/ocaml/pull/278">problemas</a> con el analizador sintáctico (parsing) imperativo desaparecen.</li>
<li>Los cuerpos de modulos y el ámbito local están unificados.</li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="ambito-local-vs-cuerpo-del-modulo"></a><a href="#ambito-local-vs-cuerpo-del-modulo" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Ámbito Local vs Cuerpo del Módulo</h2>
<p>En Reason, todo lo que puede ir entre <code>{}</code> puede estar en <a href="#local-scope">Ámbito Local</a> y en el cuerpo de los módulos. Habitualmente, hasta puedes cortar/pegar código entre ambos contextos. En OCaml, las sintaxis entre los dos contextos es muy diferente. El ámbito local requiere llevar al final <code>in</code>, pero el cuerpo de los módulos no lo necesita y las declaraciones imperativas deben ser asignadas a <code>_</code> o <code>()</code>, o si no usar doble <code>;;</code>.</p>
<table>
  <tr>
    <th>
      OCaml Module Body
    </th>
<pre><code class="hljs">&lt;th&gt;
  Reason Module Body
&lt;/th&gt;
</code></pre>
  </tr>
  <tr>
    <td>
      <pre><code class="hljs">let ten = 10
let () = imperativeFunc ten ten
let () = imperativeFunc 0 0</code></pre>
    </td>
<pre><code class="hljs">&lt;td&gt;
  &lt;pre&gt;&lt;code&gt;let ten = 10;
</code></pre>
<p>imperativeFunc(ten, ten);
imperativeFunc(0, 0);</code></pre>
</td></p>
  </tr>
  <tr>
    <td>
      <pre><code class="hljs">let ten = 10;;
imperativeFunc ten ten;;
imperativeFunc 0 0;;</code></pre>
    </td>
<pre><code class="hljs">&lt;td&gt;
  Same as above
&lt;/td&gt;
</code></pre>
  </tr>
  <tr>
    <th>
      OCaml Local Scope
    </th>
<pre><code class="hljs">&lt;th&gt;
  Reason Local Scope
&lt;/th&gt;
</code></pre>
  </tr>
  <tr>
    <td>
      <pre><code class="hljs">let ten = 10 in
let _ = imperativeFunc ten ten in
imperativeFunc 0 0</code></pre>
    </td>
<pre><code class="hljs">&lt;td&gt;
  Same as above
&lt;/td&gt;
</code></pre>
  </tr>
  <tr>
    <td>
      <pre><code class="hljs">let ten = 10 in begin
  imperativeFunc ten ten;
  imperativeFunc 0 0
end</code></pre>
    </td>
<pre><code class="hljs">&lt;td&gt;
  Same as above
&lt;/td&gt;
</code></pre>
  </tr>
  <tr>
    <td>
      <pre><code class="hljs">let ten = 10 in (
  imperativeFunc ten ten;
  imperativeFunc 0 0
)</code></pre>
    </td>
<pre><code class="hljs">&lt;td&gt;
  Same as above
&lt;/td&gt;
</code></pre>
  </tr>
</table>
<h2><a class="anchor" aria-hidden="true" id="tupla-y-registro"></a><a href="#tupla-y-registro" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Tupla y Registro</h2>
<p>En Reason, las tuplas siempre requieren paréntesis.</p>
<table>
<thead>
<tr><th>OCaml</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td><code>let tup = 4, 5</code></td><td><code>let tup = (4, 5);</code></td></tr>
<tr><td><code>let tup = ((1: int), (2:int))</code></td><td><code>let tup = (1: int, 2:int);</code></td></tr>
<tr><td><code>fun ((a: int), (b: int)) -&gt; a</code></td><td><code>((a: int, b: int)) =&gt; a;</code></td></tr>
</tbody>
</table>
<p>En Reason, los valores de los registros se parecen a los de JavaScript, usando <code>:</code> en vez de <code>=</code>.</p>
<table>
  <tr>
    <th>
      OCaml
    </th>
<pre><code class="hljs">&lt;th&gt;
  Reason
&lt;/th&gt;
</code></pre>
  </tr>
  <tr>
    <td>
      <pre><code class="hljs">let myRec = {x = 0; y = 10}</code></pre>
    </td>
<pre><code class="hljs">&lt;td&gt;
  &lt;pre&gt;&lt;code&gt;let myRec = {x: 0, y: 10};&lt;/code&gt;&lt;/pre&gt;
&lt;/td&gt;
</code></pre>
  </tr>
  <tr>
    <td>
      <pre><code class="hljs">let myFuncs = {
  myFun = (fun x -> x + 1);
  your = (fun a b -> a + b);
}</code></pre>
    </td>
<pre><code class="hljs">&lt;td&gt;
  &lt;pre&gt;&lt;code&gt;let myFuncs = {
</code></pre>
<p>myFun: (x) =&gt; x + 1,
your: (a, b) =&gt; a + b
};</code></pre>
</td></p>
  </tr>
</table>
<h2><a class="anchor" aria-hidden="true" id="listas"></a><a href="#listas" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Listas</h2>
<table>
<thead>
<tr><th>OCaml</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td><code>let list = [1; 2; 3]</code></td><td><code>let list = [1, 2, 3]</code></td></tr>
<tr><td><code>let list = hd :: tl</code></td><td><code>let list = [hd, ...tl];</code></td></tr>
</tbody>
</table>
<h2><a class="anchor" aria-hidden="true" id="definiciones-de-tipos"></a><a href="#definiciones-de-tipos" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Definiciones de tipos</h2>
<table>
<thead>
<tr><th>Tupla OCaml</th><th>Tupla Reason</th></tr>
</thead>
<tbody>
<tr><td><code>type tuple = int * int</code></td><td><code>type tuple = (int, int);</code></td></tr>
<tr><td><code>let tup: tuple = (10, 30)</code></td><td><code>let tup: tuple = (10, 30);</code></td></tr>
</tbody>
</table>
<table>
<thead>
<tr><th>Registro OCaml</th><th>Registro Reason</th></tr>
</thead>
<tbody>
<tr><td><code>type r = {x: int; y: int}</code></td><td><code>type r = {x: int, y: int};</code></td></tr>
<tr><td><code>let myRec: r = {x = 0; y = 10}</code></td><td><code>let myRec: r = {x: 0, y: 10};</code></td></tr>
</tbody>
</table>
<table>
<thead>
<tr><th>Función Ocaml</th><th>Función Reason</th></tr>
</thead>
<tbody>
<tr><td><code>type func = int -&gt; int</code></td><td><code>type func = int =&gt; int;</code></td></tr>
<tr><td><code>let x: func = fun a -&gt; a + 1</code></td><td><code>let x: func = (a) =&gt; a + 1;</code></td></tr>
</tbody>
</table>
<h2><a class="anchor" aria-hidden="true" id="funciones"></a><a href="#funciones" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Funciones</h2>
<table>
<thead>
<tr><th>OCaml</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td><code>let x a b = e</code></td><td><code>let x = (a, b) =&gt; e</code></td></tr>
<tr><td><code>let x = fun a b -&gt; e</code></td><td><code>let x = (a, b) =&gt; e</code></td></tr>
<tr><td><code>let x = fun a -&gt; fun b -&gt; e</code></td><td><code>let x = (a, b) =&gt; e</code></td></tr>
</tbody>
</table>
<h3><a class="anchor" aria-hidden="true" id="funciones-con-coincidencia-de-argumento-unico"></a><a href="#funciones-con-coincidencia-de-argumento-unico" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Funciones con coincidencia de argumento único</h3>
<p>OCaml tiene una definición de función (<code>function |</code>) que es considerada equivalente a <code>function a -&gt; match a with</code>. Reason tiene lo mismo, pero la sintaxis deja claro que en realidad es una extensión de una función de argumento único. El caso de coincidencia única es una extensión natural de la lambda simple, y el caso múltiple es una extensión natural de la lambda de caso único.</p>
<table>
  <tr>
    <th>
      Form
    </th>
<pre><code class="hljs">&lt;th&gt;
  OCaml
&lt;/th&gt;

&lt;th&gt;
  Reason
&lt;/th&gt;
</code></pre>
  </tr>
  <tr>
    <td>
      Lambda
    </td>
<pre><code class="hljs">&lt;td&gt;
  &lt;pre&gt;&lt;code&gt;fun pat -&gt; e&lt;/code&gt;&lt;/pre&gt;
&lt;/td&gt;

&lt;td&gt;
  &lt;pre&gt;&lt;code&gt;fun pat =&gt; e&lt;/code&gt;&lt;/pre&gt;
&lt;/td&gt;
</code></pre>
  </tr>
  <tr>
    <td>
      One match case
    </td>
<pre><code class="hljs">&lt;td&gt;
  &lt;pre&gt;&lt;code&gt;function | pat -&gt; e&lt;/code&gt;&lt;/pre&gt;
&lt;/td&gt;

&lt;td&gt;
  &lt;pre&gt;&lt;code&gt;fun | pat =&gt; e&lt;/code&gt;&lt;/pre&gt;
&lt;/td&gt;
</code></pre>
  </tr>
  <tr>
    <td>
      Many cases
    </td>
<pre><code class="hljs">&lt;td&gt;
  &lt;pre&gt;&lt;code&gt;function | pat -&gt; e
     | pat2 -&gt; e&lt;/code&gt;&lt;/pre&gt;
&lt;/td&gt;

&lt;td&gt;
  &lt;pre&gt;&lt;code&gt;fun | pat =&gt; e
| pat2 =&gt; e&lt;/code&gt;&lt;/pre&gt;
&lt;/td&gt;
</code></pre>
  </tr>
</table>
<h3><a class="anchor" aria-hidden="true" id="anotando-argumentos"></a><a href="#anotando-argumentos" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Anotando argumentos</h3>
<p>Tanto en Reason como en OCaml, los argumentos son anotados con tipos (como todo lo demás), encerrándolos en paréntesis después de agregar <code>:typeAnnotation</code>.</p>
<pre><code class="hljs css language-reason">(arg: argType) =&gt; returnValue;
</code></pre>
<pre><code class="hljs css language-reason">(arg: argType) =&gt; (arg2: arg2Type) =&gt; returnValue;
</code></pre>
<pre><code class="hljs css language-reason">(arg: argType, arg2: arg2Type) =&gt; returnValue;
</code></pre>
<p>Ambos, Reason y OCaml permiten anotar el tipo de valor de retorno, cuando se usa la forma &quot;super sugared let binding&quot;.</p>
<pre><code class="hljs css language-ocaml"><span class="hljs-comment">(* OCaml *)</span>
<span class="hljs-keyword">let</span> myFunc (a:<span class="hljs-built_in">int</span>) (b:<span class="hljs-built_in">int</span>) :<span class="hljs-built_in">int</span> * <span class="hljs-built_in">int</span> = (a, b)
<span class="hljs-keyword">let</span> myFunc (a:<span class="hljs-built_in">int</span>) (b:<span class="hljs-built_in">int</span>) :<span class="hljs-built_in">int</span> <span class="hljs-built_in">list</span> = [<span class="hljs-number">1</span>]
<span class="hljs-keyword">let</span> myFunc (a:<span class="hljs-built_in">int</span>) (b:<span class="hljs-built_in">int</span>) :<span class="hljs-built_in">int</span> -&gt; <span class="hljs-built_in">int</span> = <span class="hljs-keyword">fun</span> x -&gt; x + a + b
</code></pre>
<pre><code class="hljs css language-reason"><span class="hljs-comment">/* Reason */</span>
<span class="hljs-keyword">let</span> myFunc = (a: int, b: int) :(int, int) =&gt; (a, b);
<span class="hljs-keyword">let</span> myFunc = (a: int, b: int) :list(int) =&gt; <span class="hljs-literal">[</span><span class="hljs-number">1</span><span class="hljs-literal">]</span>;
<span class="hljs-keyword">let</span> myFunc = (a: int, b: int): (int =&gt; int) =&gt; (x) =&gt; x <span class="hljs-operator">+</span> a <span class="hljs-operator">+</span> b;
</code></pre>
<p>Aunque usamos <code>=&gt;</code> para todas las funciones en Reason, hay un caso donde necesitamos agregar un paréntesis extra alrededor del tipo del valor de retorno que es, en sí misma, la función tipo.</p>
<h3><a class="anchor" aria-hidden="true" id="tipado-de-parametros"></a><a href="#tipado-de-parametros" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Tipado de parámetros</h3>
<h4><a class="anchor" aria-hidden="true" id="ocaml"></a><a href="#ocaml" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>OCaml</h4>
<p>Las aplicaciones de tipos en OCaml (piensa en &quot;genéricos&quot;), son aplicados en orden inverso.</p>
<p>Con OCaml, hay algunas consecuencias poco intuitivas.</p>
<pre><code class="hljs css language-ocaml"><span class="hljs-keyword">let</span> x: <span class="hljs-built_in">int</span> <span class="hljs-built_in">list</span> = [<span class="hljs-number">2</span>]

<span class="hljs-keyword">type</span> listOfListOfInts = <span class="hljs-built_in">int</span> <span class="hljs-built_in">list</span> <span class="hljs-built_in">list</span>

<span class="hljs-comment">(* Parsed as: *)</span>
<span class="hljs-keyword">type</span> listOfListOfInts = (<span class="hljs-built_in">int</span> <span class="hljs-built_in">list</span>) <span class="hljs-built_in">list</span>
</code></pre>
<p>Las cosas se ponen aún más extrañas cuando constructores de tipo aceptan parámetros múltiples. Múltiples argumentos requiere paréntesis y comas para separar parámetros de tipo, pero esos parámetros no representan tuplas. La forma paréntesis/comas debe también ser usada cuando se construyen instancias de tipos como <code>(int, string) tuple</code>.</p>
<pre><code class="hljs css language-ocaml"><span class="hljs-keyword">type</span> (<span class="hljs-symbol">'a</span>, <span class="hljs-symbol">'b</span>) tuple = <span class="hljs-symbol">'a</span> * <span class="hljs-symbol">'b</span>

<span class="hljs-keyword">type</span> listOfTuplesOfStringAndInt = (<span class="hljs-built_in">string</span>, <span class="hljs-built_in">int</span>) tuple <span class="hljs-built_in">list</span>

<span class="hljs-comment">(* Which is parsed as: *)</span>
<span class="hljs-keyword">type</span> listOfTuplesOfStringAndInt = ((<span class="hljs-built_in">string</span>, <span class="hljs-built_in">int</span>) tuple) <span class="hljs-built_in">list</span>

<span class="hljs-comment">(* Which allows a list of (tuples of (string and int)) *)</span>
<span class="hljs-keyword">let</span> tuples: listOfTuplesOfStringAndInt = [(<span class="hljs-string">"asdf"</span>, <span class="hljs-number">3</span>)]
</code></pre>
<h4><a class="anchor" aria-hidden="true" id="reason"></a><a href="#reason" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Reason</h4>
<p>En resumen, Reason unifica casi toda la sintaxis en un estilo simple de &quot;aplicación de funciones&quot;, lo que significa que los parámetros tipados siguen el mismo patrón de separación por comas visto en toda la sintaxis. Esto se traduce en menos patrones sintácticos que aprender.</p>
<p>Por ejemplo, puedes imaginar <code>list</code> siendo una &quot;función&quot; para tipos que aceptan un tipo y devuelve un nuevo tipo.</p>
<table>
  <tr>
    <th>
      OCaml
    </th>
<pre><code class="hljs">&lt;th&gt;
  Reason
&lt;/th&gt;
</code></pre>
  </tr>
  <tr>
    <td>
      <pre><code class="hljs">let x: int list = [2]
type listOfListOfInts = int list list
type ('a, 'b) tup = ('a * 'b)
type pairs = (int, int) tup list
let tuples: pairs = [(2, 3)]</code></pre>
    </td>
<pre><code class="hljs">&lt;td&gt;
  &lt;pre&gt;&lt;code&gt;let x: list(int) = [2];
</code></pre>
<p>type listOfListOfInts = list(list(int));
type tup('a, 'b) = ('a, 'b);
type pairs = list(tup(int, int));
let tuples: pairs = [(2, 3)];</code></pre>
</td></p>
  </tr>
</table>
<h2><a class="anchor" aria-hidden="true" id="tuplas-como-parametros-tipados"></a><a href="#tuplas-como-parametros-tipados" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Tuplas como parámetros tipados</h2>
<p>Como OCaml usa paréntesis y comas para representar argumentos múltiples en constructores de tipos, es confuso cuando uno de los argumentos de un constructor de tipos es en sí una tupla. En OCaml, es difícil recordar la diferencia entre un constructor de tipos que acepte múltiples argumentos y un constructor de tipos que acepte un sólo elemento, que pasa a ser una tupla.</p>
<p>Los siguientes ejemplos muestran la diferencia entre pasar <em>dos</em> parámetros de tipos a <code>pair</code>, y un *sólo * parámetro de tipo que resulta ser una tupla.</p>
<table>
<thead>
<tr><th>OCaml</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td><code>type intPair = (int, int) pair</code></td><td><code>type intPair = pair(int, int)</code></td></tr>
<tr><td><code>type pairList = (int * int) list</code></td><td><code>type pairList = list((int, int))</code></td></tr>
</tbody>
</table>
<ul>
<li>En Reason, la sintaxis que representa una tupla o tipos de tupla, siempre asemejan tuplas.</li>
<li>En Reason, la sintaxis que representa los registros o los tipos de registro, siempre se ven como registros.</li>
<li>Casi todo lo demás usa el patrón sintáctico de aplicación de función (argumentos separados por comas).</li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="variantes"></a><a href="#variantes" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Variantes</h2>
<h5><a class="anchor" aria-hidden="true" id="ocaml-1"></a><a href="#ocaml-1" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>OCaml</h5>
<ul>
<li>OCaml prevé tipos de argumentos de construcción que sean especificados en forma de tupla, por lo que es confuso cuando un sólo constructor espera un sólo argumento que también <em>resulta ser</em> un tipo tupla.</li>
<li>Lo que es aún más confuso es que los constructores <em>en realidad</em> no aceptan tuplas, aunque la sintaxis se asemeja a las tuplas.</li>
<li>A veces, la sintaxis para crear una instancia de un constructor con múltiples argumentos solapa la sintaxis para construir una variante con un sólo argumento que resulta ser una tupla - entonces parece <em>exactamente</em> como si <em>estuvieras</em> suministrando una tupla cuando en realidad no lo estas haciendo.</li>
</ul>
<h5><a class="anchor" aria-hidden="true" id="reason-1"></a><a href="#reason-1" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Reason</h5>
<ul>
<li>Los tipos de constructores variantes se espera que sean listados como listas separadas por comas, usando paréntesis para agrupar por precedencia (así como con <strong>todo</strong> lo demás).</li>
<li>Instancias de construcción de la variante (como habrás adivinado) siguen el estilo de aplicación de función (listas separadas por comas).</li>
<li>Tuplas <strong>siempre</strong> <em>parecen</em> tuplas, y cualquier cosa que parezca una tupla <em>es</em> una tupla.</li>
</ul>
<table>
  <tr>
    <th>
      OCaml
    </th>
<pre><code class="hljs">&lt;th&gt;
  Reason
&lt;/th&gt;
</code></pre>
  </tr>
  <tr>
    <td>
      <pre><code class="hljs">type myVariant =
  | HasNothing
  | HasSingleInt of int
  | HasSingleTuple of (int * int)
  | HasMultipleInts of int * int
  | HasMultipleTuples of (int * int) * (int * int)</code></pre>
    </td>
<pre><code class="hljs">&lt;td&gt;
  &lt;pre&gt;&lt;code&gt;type myVariant =
</code></pre>
<p>| HasNothing
| HasSingleInt(int)
| HasSingleTuple((int, int))
| HasMultipleInts(int, int)
| HasMultipleTuples((int, int), (int, int));</code></pre>
</td></p>
  </tr>
  <tr>
    <td>
      <pre><code class="hljs">let a = HasSingleInt 10
let a = HasSingleTuple (10, 10)
let a = HasMultipleInts (10, 10)
let a = HasMultipleTuples ((10, 10), (10, 10))</code></pre>
    </td>
<pre><code class="hljs">&lt;td&gt;
  &lt;pre&gt;&lt;code&gt;let a = HasSingleInt(10);
</code></pre>
<p>let a = HasSingleTuple((10, 10));
let a = HasMultipleInts(10, 10);
let a = HasMultipleTuples((10, 10), (10, 10));</code></pre>
</td></p>
  </tr>
  <tr>
    <td>
      <pre><code class="hljs">let res x = match x with
  | HasNothing -> 0
  | HasSingleInt x -> 0
  | HasSingleTuple (x, y) -> 0
  | HasMultipleInts (x, y) -> 0
  | HasMultipleTuples ((x, y), (q, r)) -> 0</code></pre>
    </td>
<pre><code class="hljs">&lt;td&gt;
  &lt;pre&gt;&lt;code&gt;let res = (x) =&gt;
</code></pre>
<p>switch (x) {
| HasNothing =&gt; 0
| HasSingleInt(x) =&gt; 0
| HasSingleTuple((x, y)) =&gt; 0
| HasMultipleInts(x, y) =&gt; 0
| HasMultipleTuples((x, y), (q, r)) =&gt; 0
};</code></pre>
</td></p>
  </tr>
</table>
<h2><a class="anchor" aria-hidden="true" id="coincidencia-de-patron"></a><a href="#coincidencia-de-patron" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Coincidencia de patrón</h2>
<table>
  <tr>
    <th>
      OCaml
    </th>
<pre><code class="hljs">&lt;th&gt;
  Reason
&lt;/th&gt;
</code></pre>
  </tr>
  <tr>
    <td>
      <pre><code class="hljs">let res = match x with
  | A (x, y) -> match y with
    | None -> 0
    | Some i -> 10
  | B (x, y) -> 0</code></pre>
    </td>
<pre><code class="hljs">&lt;td&gt;
  &lt;pre&gt;&lt;code&gt;let res = switch (x) {
</code></pre>
<p>| A((x, y)) =&gt; switch (y) {
| None =&gt; 0
| Some(i) =&gt; 10
}
| B((x, y)) =&gt; 0
};</code></pre>
</td></p>
  </tr>
</table>
<p>¿Puedes localizar el error en el ejemplo de OCaml? Este es uno de los errores más comunes entre los programadores OCaml. El <code>match</code> anidado <em>debe</em> ser escrito entre paréntesis, si no el caso <code>Some</code> es analizado como si perteneciera a la <code>coincidencia</code> exterior. Visualmente, en realidad es:</p>
<pre><code class="hljs css language-ocaml"><span class="hljs-keyword">let</span> res = <span class="hljs-keyword">match</span> x <span class="hljs-keyword">with</span>
  | <span class="hljs-type">A</span> (x, y) -&gt; <span class="hljs-keyword">match</span> y <span class="hljs-keyword">with</span>
    | <span class="hljs-type">None</span> -&gt; <span class="hljs-number">0</span>
    | <span class="hljs-type">Some</span> i -&gt; <span class="hljs-number">10</span>
    | <span class="hljs-type">B</span> (x, y) -&gt; <span class="hljs-number">0</span>
</code></pre>
<p>Las <code>{}</code> obligatorias en Reason alrededor de casos <code>switch</code> previenen este problema.</p>
<h2><a class="anchor" aria-hidden="true" id="modulos-y-firmas"></a><a href="#modulos-y-firmas" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Módulos y Firmas</h2>
<h3><a class="anchor" aria-hidden="true" id="definicion"></a><a href="#definicion" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Definición</h3>
<table>
  <tr>
    <th>
      OCaml
    </th>
<pre><code class="hljs">&lt;th&gt;
  Reason
&lt;/th&gt;
</code></pre>
  </tr>
  <tr>
    <td>
      <pre><code class="hljs">module type MySig = sig
  type t = int
  val x: int
end
module MyModule: MySig = struct
  type t = int
  let x = 10
end
module MyModule = struct
  module NestedModule = struct
     let msg = "hello";
  end
end</code></pre>
    </td>
<pre><code class="hljs">&lt;td&gt;
  &lt;pre&gt;&lt;code&gt;module type MySig = {
</code></pre>
<p>type t = int;
let x: int;
};
module MyModule: MySig = {
type t = int;
let x = 10;
};
module MyModule = {
module NestedModule = {
let msg = &quot;hello&quot;;
};
};</code></pre>
</td></p>
  </tr>
</table>
<h3><a class="anchor" aria-hidden="true" id="tipos-functor"></a><a href="#tipos-functor" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Tipos Functor</h3>
<table>
  <tr>
    <th>
      OCaml
    </th>
<pre><code class="hljs">&lt;th&gt;
  Reason
&lt;/th&gt;
</code></pre>
  </tr>
  <tr>
    <td>
      <pre><code class="hljs">module type FType =
  functor (A: ASig) ->
  functor (B: BSig) -> Result</code></pre>
    </td>
<pre><code class="hljs">&lt;td&gt;
  &lt;pre&gt;&lt;code&gt;module type FType =
</code></pre>
<p>(A: ASig) =&gt;
(B: BSig) =&gt; Result;</code></pre>
</td></p>
  </tr>
</table>
<h2><a class="anchor" aria-hidden="true" id="functores"></a><a href="#functores" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Functores</h2>
<table>
  <tr>
    <th>
      OCaml
    </th>
<pre><code class="hljs">&lt;th&gt;
  Reason
&lt;/th&gt;
</code></pre>
  </tr>
  <tr>
    <td>
      <pre><code class="hljs">module F =
  functor (A: ASig) ->
  functor (B: BSig) -> struct end</code></pre>
    </td>
<pre><code class="hljs">&lt;td&gt;
  &lt;pre&gt;&lt;code&gt;module F =
</code></pre>
<p>(A: ASig) =&gt;
(B: BSig) =&gt; {};</code></pre>
</td></p>
  </tr>
  <tr>
    <td>
      <pre><code class="hljs">module F = functor (A: ASig) (B: BSig) -> struct end</code></pre>
    </td>
<pre><code class="hljs">&lt;td&gt;
  &lt;pre&gt;&lt;code&gt;module F = (A: ASig, B: BSig) =&gt; {};&lt;/code&gt;&lt;/pre&gt;
&lt;/td&gt;
</code></pre>
  </tr>
  <tr>
    <td>
      <pre><code class="hljs">module F (A: ASig) (B: BSig) = struct end</code></pre>
    </td>
<pre><code class="hljs">&lt;td&gt;
  &lt;pre&gt;&lt;code&gt;module F = (A: ASig, B: BSig) =&gt; {};&lt;/code&gt;&lt;/pre&gt;
&lt;/td&gt;
</code></pre>
  </tr>
  <tr>
    <td>
      <pre><code class="hljs">module Res = F(A)(B)</code></pre>
    </td>
<pre><code class="hljs">&lt;td&gt;
  &lt;pre&gt;&lt;code&gt;module Res = F(A, B);&lt;/code&gt;&lt;/pre&gt;
&lt;/td&gt;
</code></pre>
  </tr>
</table>
<h2><a class="anchor" aria-hidden="true" id="varias-mejoras"></a><a href="#varias-mejoras" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Varias mejoras</h2>
<p>OCaml no requiere paréntesis alrededor de secuencias <code>(a;b;c;d)</code> o tuplas <code>(x,y)</code>, de esta manera descarta un montón de otras reglas de sintaxis muy practicas. Como Reason siempre usa <code>{}</code> para delimitar secuencias o enlaces let, y Reason siempre requiere <code>()</code> alrededor de las tuplas, muchos constructor sintácticos son expresados más intuitivamente, sin requerir escribirlos entre paréntesis adicionales.</p>
<h3><a class="anchor" aria-hidden="true" id="lambdas-como-campos-de-registro-no-necesitan-parentesis-adicionales"></a><a href="#lambdas-como-campos-de-registro-no-necesitan-parentesis-adicionales" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Lambdas como campos de registro no necesitan paréntesis adicionales</h3>
<p>Esta es una mejora bienvenida porque los errores de tipos de OCaml que el usuario vería serían muy confusos al creer que el valor de retorno de la función era una tupla con una <code>,</code> coma infija.</p>
<table>
  <tr>
    <th>
      OCaml
    </th>
<pre><code class="hljs">&lt;th&gt;
  Reason
&lt;/th&gt;
</code></pre>
  </tr>
  <tr>
    <td>
      <pre><code class="hljs">let myFuncs = {
  myFun = (fun x -> x + 1);
  your = (fun a b -> a + b);
}</code></pre>
    </td>
<pre><code class="hljs">&lt;td&gt;
  &lt;pre&gt;&lt;code&gt;let myFuncs = {
</code></pre>
<p>myFun: (x) =&gt; x + 1,
your: (a, b) =&gt; a + b
};</code></pre>
</td></p>
  </tr>
</table>
<h3><a class="anchor" aria-hidden="true" id="lambdas-como-resultados-de-coincidencias-no-requieren-parentesis-adicionales"></a><a href="#lambdas-como-resultados-de-coincidencias-no-requieren-parentesis-adicionales" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Lambdas como resultados de coincidencias no requieren paréntesis adicionales</h3>
<table>
  <tr>
    <th>
      OCaml
    </th>
<pre><code class="hljs">&lt;th&gt;
  Reason
&lt;/th&gt;
</code></pre>
  </tr>
  <tr>
    <td>
      <pre><code class="hljs">let x = match prnt with
  | None -> fun a -> blah
  (* Extra () required ! *)
  | Some "_" -> (fun a -> ())
  | Some "ml" -> blah</code></pre>
    </td>
<pre><code class="hljs">&lt;td&gt;
  &lt;pre&gt;&lt;code&gt;let x =
</code></pre>
<p>switch (prnt) {
| None =&gt; (a) =&gt; blah
| Some(&quot;_&quot;) =&gt; (a) =&gt; ()
| Some(&quot;ml&quot;) =&gt; blah
};</code></pre>
</td></p>
  </tr>
</table>
<h3><a class="anchor" aria-hidden="true" id="lambdas-y-anotaciones-de-tipos-en-tuplas-no-requieren-parentesis-suplementarios"></a><a href="#lambdas-y-anotaciones-de-tipos-en-tuplas-no-requieren-parentesis-suplementarios" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Lambdas y anotaciones de tipos en tuplas no requieren paréntesis suplementarios</h3>
<table>
<thead>
<tr><th>OCaml</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td><code>let tuple = ((fun x -&gt; x), 20)</code></td><td><code>let tuple = ((x) =&gt; x, 20);</code></td></tr>
<tr><td><code>let tuple = ((&quot;hi&quot;: string), (20: int))</code></td><td><code>let tuple = (&quot;hi&quot;: string, 20: int);</code></td></tr>
</tbody>
</table>
<h2><a class="anchor" aria-hidden="true" id="diferencias-varias"></a><a href="#diferencias-varias" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Diferencias varias</h2>
<h3><a class="anchor" aria-hidden="true" id="precedencia-as"></a><a href="#precedencia-as" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>precedencia <code>as</code></h3>
<p>Con Reason, <code>as</code> tiene una mayor precedencia que el simbolo<code>|</code>. Esto permite crear alias de <code>as</code> para filas completas en coincidencias de patrón.</p>
<table>
  <tr>
    <th>
      OCaml
    </th>
<pre><code class="hljs">&lt;th&gt;
  Reason
&lt;/th&gt;
</code></pre>
  </tr>
  <tr>
    <td>
      <pre><code class="hljs">let ppp = match MyThing 20 with
  | (MyThing x as ppp)
  | (YourThing x as ppp) -> ppp;</code></pre>
    </td>
<pre><code class="hljs">&lt;td&gt;
  &lt;pre&gt;&lt;code&gt;let ppp =
</code></pre>
<p>switch (MyThing(20)) {
| MyThing(x) as ppp
| YourThing(x) as ppp =&gt; ppp
};</code></pre>
</td></p>
  </tr>
</table>
<h3><a class="anchor" aria-hidden="true" id="actualizaciones-de-campos-de-registros-mutables"></a><a href="#actualizaciones-de-campos-de-registros-mutables" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Actualizaciones de campos de registros mutables</h3>
<p>Porque igualdades y sus negaciones se han hecho más consistentes en Reason, el operador <code>=</code> esta disponible para actualizar campos mutables.</p>
<table>
<thead>
<tr><th>OCaml</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td><code>myRec.field &lt;- &quot;next&quot;</code></td><td><code>myRec.field = &quot;next&quot;</code></td></tr>
</tbody>
</table>
<h3><a class="anchor" aria-hidden="true" id="operadores-prefijos"></a><a href="#operadores-prefijos" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Operadores prefijos</h3>
<p>El carácter <code>!</code> en Reason se utiliza para la negación <code>not</code> booleana. El deferenciamiento utiliza el postfijo <code>^</code>.</p>
<table>
<thead>
<tr><th>OCaml</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td><code>let x = !(foo.bar)</code></td><td><code>let x = foo.bar^;</code></td></tr>
<tr><td><code>let x = !(foo#bar)</code></td><td><code>let x = foo#bar^;</code></td></tr>
<tr><td><code>let x = !(!foo.bar)</code></td><td><code>let x = foo^.bar^;</code></td></tr>
<tr><td><code>let x = !(!foo#bar)</code></td><td><code>let x = (foo^)#bar^;</code></td></tr>
<tr><td><code>let x = !(!(foo.bar))</code></td><td><code>let x = foo.bar^ ^;</code></td></tr>
<tr><td><code>let x = !(!(foo#bar))</code></td><td><code>let x = foo#bar^ ^;</code></td></tr>
<tr><td><code>let x = !!(foo.bar)</code></td><td><code>let x = !!foo.bar;</code></td></tr>
<tr><td><code>let x = !!(foo#bar)</code></td><td><code>let x = !!foo#bar;</code></td></tr>
<tr><td><code>let x = !~(foo.bar)</code></td><td><code>let x = !~foo.bar;</code></td></tr>
<tr><td><code>let x = !~(foo#bar)</code></td><td><code>let x = !~foo#bar;</code></td></tr>
</tbody>
</table>
<h3><a class="anchor" aria-hidden="true" id="escapando-comentarios"></a><a href="#escapando-comentarios" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Escapando Comentarios</h3>
<p>Como Reason utiliza comentarios estilo C, algunos oscuros operadores prefijo/infijo personalizados deben ser escritos de forma diferente. Las reglas para operadores prefijos/infijos son las mismas que las de el sintaxis de OCaml, pero con las siguientes excepciones:</p>
<p>Específicamente, si algún carácter excepto el primero en un operador prefijo/infijo es un asterisco o una barra inclinada, primero debe ser escapado con una barra inclinada inversa. Estos serán analizados <em>sin</em> la barra inclinada invertida cuando sean añadidos al AST. Cuando se reimpriman, la barra inclinada invertida de escape será añadida de nuevo automáticamente.</p>
<table>
<thead>
<tr><th>OCaml</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td><code>let (/*) a b = a + b</code></td><td><code>let (/\*) = (a, b) =&gt; a + b;</code></td></tr>
<tr><td><code>let x = 12 /-* 23 /-* 12</code></td><td><code>let x = 12 /-* 23 /-* 12;</code></td></tr>
<tr><td><code>let y = (/*) a b</code></td><td><code>let y = a /\* b;</code></td></tr>
<tr><td><code>let (!=*) q r = q + r</code></td><td><code>let ( !=* ) = (q, r) =&gt; q + r;</code></td></tr>
<tr><td><code>let res = q (!=*) r</code></td><td><code>let res = q(( !=* ), r);</code></td></tr>
<tr><td><code>let (!=/*) q r = q + r</code></td><td><code>let ( !=/\* ) = (q, r) =&gt; q + r;</code></td></tr>
<tr><td><code>let res = q (!=/*) r</code></td><td><code>let res = q(( !=/\* ), r);</code></td></tr>
</tbody>
</table>
<h3><a class="anchor" aria-hidden="true" id="renombrando-operadores"></a><a href="#renombrando-operadores" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Renombrando operadores</h3>
<p>Si Reason usa <code>==</code> para representar el <code>=</code> de OCaml, y usa el <code>===</code> para representar el <code>==</code> de OCaml, entonces ¿Como representa Reason el símbolo de OCaml <code>===</code> (si este fuese definido)? ¡Reason proporciona una manera! ¡Triple &quot;Escape&quot; el símbolo igual!</p>
<table>
<thead>
<tr><th>Identificador</th><th>Significado</th><th>OCaml</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td><code>&quot;===&quot;</code></td><td>Valor personalizado</td><td><code>x === y</code></td><td><code>x \=== y</code></td></tr>
</tbody>
</table>
<h3><a class="anchor" aria-hidden="true" id="repl"></a><a href="#repl" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>REPL</h3>
<p>En el REPL de Reason <a href="/docs/es-ES/extra-goodies#repl"><code>rtop</code></a> (un <a href="https://github.com/diml/utop"><code>utop</code></a> personalizado), cada entrada es remitida a través de un único punto y coma <code>;</code>. El REPL de OCaml requiere dos punto y coma <code>;;</code>.</p>
<table>
<thead>
<tr><th>OCaml</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td><code>;;</code></td><td><code>;</code></td></tr>
</tbody>
</table>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/es-ES/faq"><span class="arrow-prev">← </span><span>Frequently Asked Questions</span></a><a class="docs-next button" href="/docs/es-ES/newcomer-examples"><span>Newcomer Examples</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#comentarios">Comentarios</a></li><li><a href="#renombrar-el-operador">Renombrar el operador</a></li><li><a href="#ambito-local">Ámbito local</a></li><li><a href="#ambito-local-vs-cuerpo-del-modulo">Ámbito Local vs Cuerpo del Módulo</a></li><li><a href="#tupla-y-registro">Tupla y Registro</a></li><li><a href="#listas">Listas</a></li><li><a href="#definiciones-de-tipos">Definiciones de tipos</a></li><li><a href="#funciones">Funciones</a><ul class="toc-headings"><li><a href="#funciones-con-coincidencia-de-argumento-unico">Funciones con coincidencia de argumento único</a></li><li><a href="#anotando-argumentos">Anotando argumentos</a></li><li><a href="#tipado-de-parametros">Tipado de parámetros</a></li></ul></li><li><a href="#tuplas-como-parametros-tipados">Tuplas como parámetros tipados</a></li><li><a href="#variantes">Variantes</a></li><li><a href="#coincidencia-de-patron">Coincidencia de patrón</a></li><li><a href="#modulos-y-firmas">Módulos y Firmas</a><ul class="toc-headings"><li><a href="#definicion">Definición</a></li><li><a href="#tipos-functor">Tipos Functor</a></li></ul></li><li><a href="#functores">Functores</a></li><li><a href="#varias-mejoras">Varias mejoras</a><ul class="toc-headings"><li><a href="#lambdas-como-campos-de-registro-no-necesitan-parentesis-adicionales">Lambdas como campos de registro no necesitan paréntesis adicionales</a></li><li><a href="#lambdas-como-resultados-de-coincidencias-no-requieren-parentesis-adicionales">Lambdas como resultados de coincidencias no requieren paréntesis adicionales</a></li><li><a href="#lambdas-y-anotaciones-de-tipos-en-tuplas-no-requieren-parentesis-suplementarios">Lambdas y anotaciones de tipos en tuplas no requieren paréntesis suplementarios</a></li></ul></li><li><a href="#diferencias-varias">Diferencias varias</a><ul class="toc-headings"><li><a href="#precedencia-as">precedencia <code>as</code></a></li><li><a href="#actualizaciones-de-campos-de-registros-mutables">Actualizaciones de campos de registros mutables</a></li><li><a href="#operadores-prefijos">Operadores prefijos</a></li><li><a href="#escapando-comentarios">Escapando Comentarios</a></li><li><a href="#renombrando-operadores">Renombrando operadores</a></li><li><a href="#repl">REPL</a></li></ul></li></ul></nav></div><span><script src="/js/redirectBlog.js"></script><script src="/js/pjax-api.min.js"></script><script>window.foo = new Pjax({
          areas: [
            // try to use the first query.
            '.mainContainer, .docsNavContainer .toc .navWrapper, .onPageNav',
            // fallback
            'body'
          ],
          link: '.docsNavContainer:not(.docsSliderActive) a',
          update: {
            script: false,
          }
        });
        var languagesMenuItemCopy = document.getElementById("languages-menu");
        languagesMenuItemCopy.addEventListener("click", function(e){
          e.preventDefault();
          e.stopPropagation();
          e.stopImmediatePropagation();
        });</script></span></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                
                apiKey: '966d1e412f67114a07dc0afe44b19b53',
                indexName: 'reason',
                inputSelector: '#search_input_react',
                algoliaOptions: {"facetFilters":["lang:es-ES"]}
              });
            </script></body></html>