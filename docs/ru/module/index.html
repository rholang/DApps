<!DOCTYPE html><html lang="ru"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Модули · Reason</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="&lt;h2&gt;&lt;a class=&quot;anchor&quot; aria-hidden=&quot;true&quot; id=&quot;базовые-сведения&quot;&gt;&lt;/a&gt;&lt;a href=&quot;#базовые-сведения&quot; aria-hidden=&quot;true&quot; class=&quot;hash-link&quot;&gt;&lt;svg class=&quot;hash-link-icon&quot; aria-hidden=&quot;true&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Базовые сведения&lt;/h2&gt;
"/><meta name="docsearch:language" content="ru"/><meta property="og:title" content="Модули · Reason"/><meta property="og:type" content="website"/><meta property="og:url" content="https://reasonml.github.io/"/><meta property="og:description" content="&lt;h2&gt;&lt;a class=&quot;anchor&quot; aria-hidden=&quot;true&quot; id=&quot;базовые-сведения&quot;&gt;&lt;/a&gt;&lt;a href=&quot;#базовые-сведения&quot; aria-hidden=&quot;true&quot; class=&quot;hash-link&quot;&gt;&lt;svg class=&quot;hash-link-icon&quot; aria-hidden=&quot;true&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Базовые сведения&lt;/h2&gt;
"/><meta name="twitter:card" content="summary"/><link rel="shortcut icon" href="/img/icon_50.png"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"/><link rel="alternate" type="application/atom+xml" href="https://reasonml.github.io/blog/atom.xml" title="Reason Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://reasonml.github.io/blog/feed.xml" title="Reason Blog RSS Feed"/><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/ru"><img class="logo" src="/img/dummy.svg" alt="Reason"/></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/docs/ru/what-and-why" target="_self">Документация</a></li><li class=""><a href="/ru/try" target="_self">Попробовать</a></li><li class=""><a href="/api/index" target="_self">API</a></li><li class=""><a href="/docs/ru/community" target="_self">Сообщество</a></li><li class=""><a href="/blog/" target="_self">Блог</a></li><span><li><a id="languages-menu" href="#"><img class="languages-icon" src="/img/language.svg" alt="Languages icon"/>Русский</a><div id="languages-dropdown" class="hide"><ul id="languages-dropdown-items"><li><a href="/docs/ja/module">日本語</a></li><li><a href="/docs/en/module">English</a></li><li><a href="/docs/de/module">Deutsch</a></li><li><a href="/docs/es-ES/module">Español</a></li><li><a href="/docs/fr/module">Français</a></li><li><a href="/docs/ko/module">한국어</a></li><li><a href="/docs/pt-BR/module">Português (Brasil)</a></li><li><a href="/docs/uk/module">Українська</a></li><li><a href="/docs/zh-CN/module">中文</a></li><li><a href="/docs/zh-TW/module">繁體中文</a></li><li><a href="https://crowdin.com/project/reason" target="_blank" rel="noreferrer noopener">Помочь с переводом</a></li></ul></div></li><script>
        const languagesMenuItem = document.getElementById("languages-menu");
        const languagesDropDown = document.getElementById("languages-dropdown");
        languagesMenuItem.addEventListener("click", function(event) {
          event.preventDefault();

          if (languagesDropDown.className == "hide") {
            languagesDropDown.className = "visible";
          } else {
            languagesDropDown.className = "hide";
          }
        });
      </script></span><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li><li class=""><a href="https://github.com/facebook/reason" target="_self">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><i></i></div><h2><i>›</i><span>Основы языка</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Введение</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/ru/what-and-why">Что и зачем</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Установка</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/ru/installation">Установка</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/editor-plugins">Плагины для редакторов и IDE</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/extra-goodies">Дополнительные инструменты</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Основы языка</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/ru/overview">Обзор</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/let-binding">Связывание с использованием let</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/type">Типы!</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/string-and-char">Строки и символы</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/boolean">Логическое значение</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/integer-and-float">Integer и Float</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/tuple">Кортежи</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/record">Запись</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/variant">Variant!</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/null-undefined-option">Null, Undefined и Option</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/list-and-array">Список и массив</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/function">Функции</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/if-else">If-Else</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/pipe-first">Pipe First</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/more-on-type">Больше о типах</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/destructuring">Деструктуризация</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/pattern-matching">Паттерн-матчинг!</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/mutation">Мутации</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/imperative-loops">Императивные циклы</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/jsx">JSX</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/external">External</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/exception">Исключения</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/object">Объекты</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/docs/ru/module">Модули</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/promise">Promise</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">JavaScript</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/ru/interop">Взаимодействие с JavaScript</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/syntax-cheatsheet">Шпаргалка по синтаксису</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/libraries">Библиотеки</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/converting-from-js">Конвертация из JS</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Native</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/ru/native">Native</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/quickstart-ocaml">Native Quickstart</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/convert-from-ocaml">Конвертация из OCaml</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Дополнительно</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/ru/faq">Часто задаваемые вопросы (FAQ)</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/comparison-to-ocaml">Сравнение с OCaml</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/newcomer-examples">Примеры для начинающих</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/project-structure">Структура проекта</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              const headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                if (event.target.tagName === 'A') {
                  document.body.classList.remove('tocActive');
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://crowdin.com/project/reason/ru" target="_blank" rel="noreferrer noopener">Translate</a><h1 class="postHeaderTitle">Модули</h1></header><article><div><span><h2><a class="anchor" aria-hidden="true" id="базовые-сведения"></a><a href="#базовые-сведения" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Базовые сведения</h2>
<p><strong>Модели похожи на мини файлы</strong>! Они могут содержать объявления типов, <code>let</code> привязки, вложенные модули и так далее.</p>
<h3><a class="anchor" aria-hidden="true" id="создание"></a><a href="#создание" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Создание</h3>
<p>Для создания используйте ключевое слово <code>module</code>. The module name must start with a <strong>capital letter</strong>. Все что вы обычно можете поместить в файл <code>.re</code>, вы можете поместить и в тело модуля внутри фигурных скобок.</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">module</span> <span class="hljs-module-identifier">School</span> = {
  <span class="hljs-keyword">type</span> profession = <span class="hljs-constructor">Teacher</span> | <span class="hljs-constructor">Director</span>;

  <span class="hljs-keyword">let</span> person1 = <span class="hljs-constructor">Teacher</span>;
  <span class="hljs-keyword">let</span> getProfession = (person) =&gt;
    <span class="hljs-keyword">switch</span> (person) {
    | <span class="hljs-constructor">Teacher</span> =&gt; <span class="hljs-string">"A teacher"</span>
    | <span class="hljs-constructor">Director</span> =&gt; <span class="hljs-string">"A director"</span>
    };
};
</code></pre>
<p>Содержимое модуля (включая типы) может быть доступно с использованием точки. Это делает модули удобным инструментом для создания пространства имен.</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> anotherPerson: <span class="hljs-module-identifier">School</span>.profession = <span class="hljs-module-identifier">School</span>.<span class="hljs-constructor">Teacher</span>;
print_endline(<span class="hljs-module-identifier">School</span>.getProfession(anotherPerson)); <span class="hljs-comment">/* "A teacher" */</span>
</code></pre>
<p>Вложенные модули работают так же.</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">module</span> <span class="hljs-module-identifier">MyModule</span> = {
  <span class="hljs-keyword">module</span> <span class="hljs-module-identifier">NestedModule</span> = {
    <span class="hljs-keyword">let</span> message = <span class="hljs-string">"hello"</span>;
  };
};

<span class="hljs-keyword">let</span> message = <span class="hljs-module-identifier">MyModule</span>.<span class="hljs-module-identifier">NestedModule</span>.message;
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="открытие-open-модуля"></a><a href="#открытие-open-модуля" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Открытие (<code>open</code>) модуля</h3>
<p>Constantly referring to a value/type in a module can be tedious. Instead, we can &quot;open&quot; a module and refer to its contents without always prepending them with the module's name. Instead of writing:</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> p: <span class="hljs-module-identifier">School</span>.profession = <span class="hljs-module-identifier">School</span>.getProfession(<span class="hljs-module-identifier">School</span>.person1);
</code></pre>
<p>We can write:</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">open</span> <span class="hljs-module-identifier">School</span>;
<span class="hljs-keyword">let</span> p: profession = getProfession(person1);
</code></pre>
<p>The content of <code>School</code> module are made visible (<strong>not</strong> copied into the file, but simply made visible!) in scope. <code>profession</code>, <code>getProfession</code> and <code>person1</code> will thus correctly be found.</p>
<p><strong>Use <code>open</code> this sparingly, it's convenient, but makes it hard to know where some values come from</strong>. You should usually use <code>open</code> in a local scope:</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> p = {
  <span class="hljs-keyword">open</span> <span class="hljs-module-identifier">School</span>;
  getProfession(person1);
};
<span class="hljs-comment">/* School's content isn't visible here anymore */</span>
</code></pre>
<p>For an <code>open</code> followed by a single expression, we have a dedicated syntax sugar:</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> p = <span class="hljs-module-identifier">School</span>.(getProfession(person1));
</code></pre>
<p>Anything else needs to be written in the first way:</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> p = {
  <span class="hljs-keyword">open</span> <span class="hljs-module-identifier">School</span>;
  print_endline(<span class="hljs-string">"hello!"</span>);
  getProfession(person1);
};
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="расширение-моделей"></a><a href="#расширение-моделей" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Расширение моделей</h3>
<p>Using <code>include</code> in a module statically &quot;spreads&quot; a module's content into a new one, thus often fulfill the role of &quot;inheritance&quot; or &quot;mixin&quot;.</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">module</span> <span class="hljs-module-identifier">BaseComponent</span> = {
  <span class="hljs-keyword">let</span> defaultGreeting = <span class="hljs-string">"Hello"</span>;
  <span class="hljs-keyword">let</span> getAudience = (~excited) =&gt; excited ? <span class="hljs-string">"world!"</span> : <span class="hljs-string">"world"</span>;
};

<span class="hljs-keyword">module</span> <span class="hljs-module-identifier">ActualComponent</span> = {
  <span class="hljs-comment">/* the content is copied over */</span>
  <span class="hljs-keyword">include</span> <span class="hljs-module-identifier">BaseComponent</span>;
  <span class="hljs-comment">/* overrides BaseComponent.defaultGreeting */</span>
  <span class="hljs-keyword">let</span> defaultGreeting = <span class="hljs-string">"Hey"</span>;
  <span class="hljs-keyword">let</span> render = () =&gt; defaultGreeting <span class="hljs-operator">++</span> <span class="hljs-string">" "</span> <span class="hljs-operator">++</span> getAudience(~excited=<span class="hljs-literal">true</span>);
};
</code></pre>
<p><strong>Note</strong>: <code>open</code> and <code>include</code> are very different! The former brings a module's content into your current scope, so that you don't have to refer to a value by prefixing it with the module's name every time. The latter <strong>copies over</strong> the definition of a module statically, then also do an <code>open</code>.</p>
<h3><a class="anchor" aria-hidden="true" id="каждый-re-файл-является-модулем"></a><a href="#каждый-re-файл-является-модулем" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Каждый <code>.re</code> файл является модулем</h3>
<p>An OCaml/Reason file maps to a module; this unlocks some interesting expressivity that'd previously require code generation in other languages. The file <code>React.re</code> implicitly forms a module <code>React</code>, which can be seen by other source files.</p>
<pre><code class="hljs css language-reason"><span class="hljs-comment">/* FileA.re. This typically compiles to module FileA below */</span>
<span class="hljs-keyword">let</span> a = <span class="hljs-number">1</span>;
<span class="hljs-keyword">let</span> b = <span class="hljs-number">2</span>;

<span class="hljs-comment">/* FileB.re */</span>
<span class="hljs-comment">/* Maps FileA's implementation to a new API */</span>
<span class="hljs-keyword">let</span> alpha = <span class="hljs-module-identifier">FileA</span>.a;
<span class="hljs-keyword">let</span> beta = <span class="hljs-module-identifier">FileA</span>.b;
</code></pre>
<p>This contrived snippet expresses &quot;copying&quot; a file:</p>
<pre><code class="hljs css language-reason"><span class="hljs-comment">/* FileA.re. This typically compiles to module FileA below */</span>
<span class="hljs-keyword">let</span> a = <span class="hljs-number">1</span>;
<span class="hljs-keyword">let</span> b = <span class="hljs-number">2</span>;

<span class="hljs-comment">/* FileB.re */</span>
<span class="hljs-comment">/* compiles to exactly fileA.re's content with no runtime overhead! */</span>
<span class="hljs-keyword">include</span> <span class="hljs-module-identifier">FileA</span>;
</code></pre>
<p><strong>Note</strong>: Because files are modules, file names should, by convention, be capitalized so they match their module names. Uncapitalized file names are not invalid, but will be transformed into a capitalized module name. I.e. <code>file.re</code> will be compiled into the module <code>File</code>. To simplify and minimize the disconnect here, the convention is therefore to capitalize file names too.</p>
<h2><a class="anchor" aria-hidden="true" id="сигнатуры"></a><a href="#сигнатуры" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Сигнатуры</h2>
<p>A module's type is called a &quot;signature&quot;, and can be written explicitly. If a module is like a <code>.re</code> (implementation) file, then a module's signature is like a <code>.rei</code> (interface) file.</p>
<h3><a class="anchor" aria-hidden="true" id="создание-1"></a><a href="#создание-1" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Создание</h3>
<p>To create a signature, use the <code>module type</code> keyword. The signature name must start with a <strong>capital letter</strong>. Whatever you could place in a <code>.rei</code> file, you may place inside a signature definition's <code>{}</code> block.</p>
<pre><code class="hljs css language-reason"><span class="hljs-comment">/* Picking up previous section's example */</span>
<span class="hljs-keyword">module</span> <span class="hljs-keyword">type</span> <span class="hljs-module-identifier">EstablishmentType</span> = {
  <span class="hljs-keyword">type</span> profession;
  <span class="hljs-keyword">let</span> getProfession: profession =&gt; string;
};
</code></pre>
<p>A signature defines the list of requirements that a module must satisfy in order for that module to match the signature. Those requirements are of the form:</p>
<ul>
<li><code>let x: int;</code> requires a <code>let</code> binding named <code>x</code>, of type <code>int</code>.</li>
<li><code>type t = someType;</code> requires a type field <code>t</code> to be equal to <code>someType</code>.</li>
<li><code>type t;</code> requires a type field <code>t</code>, but without imposing any requirements on the actual, concrete type of <code>t</code>. We'd use <code>t</code> in other entries in the signature to describe relationships, e.g. <code>let makePair: t =&gt; (t, t)</code> but we cannot, for example, assume that <code>t</code> is an <code>int</code>. This gives us great, enforced abstraction abilities.</li>
</ul>
<p>To illustrate the various kinds of type entries, consider the above signature <code>EstablishmentType</code> which requires that a module:</p>
<ul>
<li>Объявить тип <code>profession</code>.</li>
<li>Must include a function that takes in a value of the type <code>profession</code> and returns a string.</li>
</ul>
<p><strong>Note</strong>:</p>
<p>Modules of the type <code>EstablishmentType</code> can contain more fields than the signature declares, just like the module <code>School</code> in the previous section (if we choose to assign it the type <code>EstablishmentType</code>. Otherwise, <code>School</code> exposes every field). This effectively makes the <code>person1</code> field an enforced implementation detail! Outsiders can't access it, since it's not present in the signature; the signature <strong>constrained</strong> what others can access.</p>
<p>The type <code>EstablishmentType.profession</code> is <strong>abstract</strong>: it doesn't have a concrete type; it's saying &quot;I don't care what the actual type is, but it's used as input to <code>getProfession</code>&quot;. This is useful to fit many modules under the same interface:</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">module</span> <span class="hljs-module-identifier">Company</span>: <span class="hljs-module-identifier">EstablishmentType</span> = {
  <span class="hljs-keyword">type</span> profession = <span class="hljs-constructor">CEO</span> | <span class="hljs-constructor">Designer</span> | <span class="hljs-constructor">Engineer</span> | <span class="hljs-operator">...</span>;

  <span class="hljs-keyword">let</span> getProfession = (person) =&gt; <span class="hljs-operator">...</span>;
  <span class="hljs-keyword">let</span> person1 = <span class="hljs-operator">...</span>;
  <span class="hljs-keyword">let</span> person2 = <span class="hljs-operator">...</span>;
};
</code></pre>
<p>It's also useful to hide the underlying type as an implementation detail others can't rely on. If you ask what the type of <code>Company.profession</code> is, instead of exposing the variant, it'll only tell you &quot;it's <code>Company.profession</code>&quot;.</p>
<h3><a class="anchor" aria-hidden="true" id="extending-module-signatures"></a><a href="#extending-module-signatures" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Extending module signatures</h3>
<p>Like modules themselves, module signatures can also be extended by other module signatures using <code>include</code>:</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">module</span> <span class="hljs-keyword">type</span> <span class="hljs-module-identifier">BaseComponent</span> = {
  <span class="hljs-keyword">let</span> defaultGreeting: string;
  <span class="hljs-keyword">let</span> getAudience: (~excited: bool) =&gt; string;
};

<span class="hljs-keyword">module</span> <span class="hljs-keyword">type</span> <span class="hljs-module-identifier">ActualComponent</span> = {
  <span class="hljs-comment">/* the BaseComponent signature is copied over */</span>
  <span class="hljs-keyword">include</span> <span class="hljs-module-identifier">BaseComponent</span>;
  <span class="hljs-keyword">let</span> render: unit =&gt; string;
};
</code></pre>
<p><strong>Note</strong>: <code>BaseComponent</code> is a module <strong>type</strong>, not an actual module itself!</p>
<p>If you do not have a defined module type, you can extract it from an actual module using <code>include (module type of ActualModuleName)</code>. For example, we can extend the <code>List</code> module from the OCaml standard library, which does not define a module type.</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">module</span> <span class="hljs-keyword">type</span> <span class="hljs-module-identifier">MyList</span> = {
  <span class="hljs-keyword">include</span> (<span class="hljs-keyword">module</span> <span class="hljs-keyword">type</span> <span class="hljs-keyword">of</span> <span class="hljs-module-identifier">List</span>);
  <span class="hljs-keyword">let</span> myListFun: list('a) =&gt; list('a);
};
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="каждый-rei-файл-является-сигнатурой"></a><a href="#каждый-rei-файл-является-сигнатурой" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Каждый <code>.rei</code> файл является сигнатурой</h3>
<p>Similar to how a <code>React.re</code> file implicitly defines a module <code>React</code>, a file <code>React.rei</code> implicitly defines a signature for <code>React</code>. If <code>React.rei</code> isn't provided, the signature of <code>React.re</code> defaults to exposing all the fields of the module. Because they don't contain implementation files, <code>.rei</code> files are used in the ecosystem to also document the public API of their corresponding modules.</p>
<pre><code class="hljs css language-reason"><span class="hljs-comment">/* file React.re (implementation. Compiles to module React) */</span>
<span class="hljs-keyword">type</span> state = int;
<span class="hljs-keyword">let</span> render = (str) =&gt; str;
</code></pre>
<pre><code class="hljs css language-reason"><span class="hljs-comment">/* file React.rei (interface. Compiles to signature of module React) */</span>
<span class="hljs-keyword">type</span> state = int;
<span class="hljs-keyword">let</span> render: str =&gt; str;
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="функции-модулей-функторы"></a><a href="#функции-модулей-функторы" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Функции модулей (функторы)</h2>
<p>Modules can be passed to functions! It would be the equivalent of passing a file as a first-class item. However, modules are at a different &quot;layer&quot; of the language than other common concepts, so we can't pass them to <em>regular</em> functions. Instead, we pass them to special functions called &quot;functors&quot;.</p>
<p>The syntax for defining and using functors is very much like the syntax for defining and using regular functions. The primary differences are:</p>
<ul>
<li>Функторы используют ключевое слово <code>module</code> вместо <code>let</code>.</li>
<li>Функтор принимает модуль как аргумент и возвращает модуль.</li>
<li>Функторы <em>требуют</em> аннотации аргументов.</li>
<li>Functors must start with a capital letter (just like modules/signatures).</li>
</ul>
<p>Here's an example <code>MakeSet</code> functor, that takes in a module of the type <code>Comparable</code> and returns a new set that can contain such comparable items.</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">module</span> <span class="hljs-keyword">type</span> <span class="hljs-module-identifier">Comparable</span> = {
  <span class="hljs-keyword">type</span> t;
  <span class="hljs-keyword">let</span> equal: (t, t) =&gt; bool;
};

<span class="hljs-keyword">module</span> <span class="hljs-module-identifier">MakeSet</span> = (<span class="hljs-module-identifier">Item</span>: <span class="hljs-module-identifier">Comparable</span>) =&gt; {
  <span class="hljs-comment">/* let's use a list as our naive backing data structure */</span>
  <span class="hljs-keyword">type</span> backingType = list(<span class="hljs-module-identifier">Item</span>.t);
  <span class="hljs-keyword">let</span> empty = <span class="hljs-literal">[</span><span class="hljs-literal">]</span>;
  <span class="hljs-keyword">let</span> add = (currentSet: backingType, newItem: <span class="hljs-module-identifier">Item</span>.t) : backingType =&gt;
    <span class="hljs-comment">/* if item exists */</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-module-identifier">List</span>.exists((x) =&gt; <span class="hljs-module-identifier">Item</span>.equal(x, newItem), currentSet)) {
      currentSet <span class="hljs-comment">/* return the same (immutable) set (a list really) */</span>
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-literal">[</span>
        newItem,
        <span class="hljs-operator">...</span>currentSet <span class="hljs-comment">/* prepend to the set and return it */</span>
      <span class="hljs-literal">]</span>
    };
};
</code></pre>
<p>Functors can be applied using function application syntax. In this case, we're creating a set, whose items are pairs of integers.</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">module</span> <span class="hljs-module-identifier">IntPair</span> = {
  <span class="hljs-keyword">type</span> t = (int, int);
  <span class="hljs-keyword">let</span> equal = ((x1, y1), (x2, y2)) =&gt; x1 <span class="hljs-operator">==</span> x2 <span class="hljs-operator">&amp;&amp;</span> y1 <span class="hljs-operator">==</span> y2;
  <span class="hljs-keyword">let</span> create = (x, y) =&gt; (x, y);
};

<span class="hljs-comment">/* IntPair abides by the Comparable signature required by MakeSet */</span>
<span class="hljs-keyword">module</span> <span class="hljs-module-identifier">SetOfIntPairs</span> = <span class="hljs-module-identifier">MakeSet</span>(<span class="hljs-module-identifier">IntPair</span>);
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="типы-функторов"></a><a href="#типы-функторов" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Типы функторов</h3>
<p>Like with module types, functor types also act to constrain and hide what we may assume about functors. The syntax for functor types are consistent with those for function types, but with types capitalized to represent the signatures of modules the functor accepts as arguments and return values. In the previous example, we're exposing the backing type of a set; by giving <code>MakeSet</code> a functor signature, we can hide the underlying data structure!</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">module</span> <span class="hljs-keyword">type</span> <span class="hljs-module-identifier">Comparable</span> = <span class="hljs-operator">...</span>

<span class="hljs-keyword">module</span> <span class="hljs-keyword">type</span> <span class="hljs-module-identifier">MakeSetType</span> = (<span class="hljs-module-identifier">Item</span>: <span class="hljs-module-identifier">Comparable</span>) =&gt; {
  <span class="hljs-keyword">type</span> backingType;
  <span class="hljs-keyword">let</span> empty: backingType;
  <span class="hljs-keyword">let</span> add: (backingType, <span class="hljs-module-identifier">Item</span>.t) =&gt; backingType;
};

<span class="hljs-keyword">module</span> <span class="hljs-module-identifier">MakeSet</span>: <span class="hljs-module-identifier">MakeSetType</span> = (<span class="hljs-module-identifier">Item</span>: <span class="hljs-module-identifier">Comparable</span>) =&gt; {
  <span class="hljs-operator">...</span>
};
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="tips-tricks"></a><a href="#tips-tricks" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Tips &amp; Tricks</h2>
<p>Modules and functors are at a different &quot;layer&quot; of language than the rest (functions, let bindings, data structures, etc.). For example, you can't easily pass them into a tuple or record. Use them judiciously, if ever! Lots of times, just a record or a function is enough.</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/ru/object"><span class="arrow-prev">← </span><span>Объекты</span></a><a class="docs-next button" href="/docs/ru/promise"><span>Promise</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#базовые-сведения">Базовые сведения</a><ul class="toc-headings"><li><a href="#создание">Создание</a></li><li><a href="#открытие-open-модуля">Открытие (<code>open</code>) модуля</a></li><li><a href="#расширение-моделей">Расширение моделей</a></li><li><a href="#каждый-re-файл-является-модулем">Каждый <code>.re</code> файл является модулем</a></li></ul></li><li><a href="#сигнатуры">Сигнатуры</a><ul class="toc-headings"><li><a href="#создание-1">Создание</a></li><li><a href="#extending-module-signatures">Extending module signatures</a></li><li><a href="#каждый-rei-файл-является-сигнатурой">Каждый <code>.rei</code> файл является сигнатурой</a></li></ul></li><li><a href="#функции-модулей-функторы">Функции модулей (функторы)</a><ul class="toc-headings"><li><a href="#типы-функторов">Типы функторов</a></li></ul></li><li><a href="#tips-tricks">Tips &amp; Tricks</a></li></ul></nav></div><span><script src="/js/redirectBlog.js"></script><script src="/js/pjax-api.min.js"></script><script>window.foo = new Pjax({
          areas: [
            // try to use the first query.
            '.mainContainer, .docsNavContainer .toc .navWrapper, .onPageNav',
            // fallback
            'body'
          ],
          link: '.docsNavContainer:not(.docsSliderActive) a',
          update: {
            script: false,
          }
        });
        var languagesMenuItemCopy = document.getElementById("languages-menu");
        languagesMenuItemCopy.addEventListener("click", function(e){
          e.preventDefault();
          e.stopPropagation();
          e.stopImmediatePropagation();
        });</script></span></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                
                apiKey: '966d1e412f67114a07dc0afe44b19b53',
                indexName: 'reason',
                inputSelector: '#search_input_react',
                algoliaOptions: {"facetFilters":["lang:ru"]}
              });
            </script></body></html>