<!DOCTYPE html><html lang="ru"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Variant! · Reason</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="&lt;p&gt;Трепещите! Драгоценность среди структур данных Reason!&lt;/p&gt;
"/><meta name="docsearch:language" content="ru"/><meta property="og:title" content="Variant! · Reason"/><meta property="og:type" content="website"/><meta property="og:url" content="https://reasonml.github.io/"/><meta property="og:description" content="&lt;p&gt;Трепещите! Драгоценность среди структур данных Reason!&lt;/p&gt;
"/><meta name="twitter:card" content="summary"/><link rel="shortcut icon" href="/img/icon_50.png"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"/><link rel="alternate" type="application/atom+xml" href="https://reasonml.github.io/blog/atom.xml" title="Reason Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://reasonml.github.io/blog/feed.xml" title="Reason Blog RSS Feed"/><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/ru"><img class="logo" src="/img/dummy.svg" alt="Reason"/></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/docs/ru/what-and-why" target="_self">Документация</a></li><li class=""><a href="/ru/try" target="_self">Попробовать</a></li><li class=""><a href="/api/index" target="_self">API</a></li><li class=""><a href="/docs/ru/community" target="_self">Сообщество</a></li><li class=""><a href="/blog/" target="_self">Блог</a></li><span><li><a id="languages-menu" href="#"><img class="languages-icon" src="/img/language.svg" alt="Languages icon"/>Русский</a><div id="languages-dropdown" class="hide"><ul id="languages-dropdown-items"><li><a href="/docs/ja/variant">日本語</a></li><li><a href="/docs/en/variant">English</a></li><li><a href="/docs/de/variant">Deutsch</a></li><li><a href="/docs/es-ES/variant">Español</a></li><li><a href="/docs/fr/variant">Français</a></li><li><a href="/docs/ko/variant">한국어</a></li><li><a href="/docs/pt-BR/variant">Português (Brasil)</a></li><li><a href="/docs/uk/variant">Українська</a></li><li><a href="/docs/zh-CN/variant">中文</a></li><li><a href="/docs/zh-TW/variant">繁體中文</a></li><li><a href="https://crowdin.com/project/reason" target="_blank" rel="noreferrer noopener">Помочь с переводом</a></li></ul></div></li><script>
        const languagesMenuItem = document.getElementById("languages-menu");
        const languagesDropDown = document.getElementById("languages-dropdown");
        languagesMenuItem.addEventListener("click", function(event) {
          event.preventDefault();

          if (languagesDropDown.className == "hide") {
            languagesDropDown.className = "visible";
          } else {
            languagesDropDown.className = "hide";
          }
        });
      </script></span><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li><li class=""><a href="https://github.com/facebook/reason" target="_self">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><i></i></div><h2><i>›</i><span>Основы языка</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Введение</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/ru/what-and-why">Что и зачем</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Установка</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/ru/installation">Установка</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/editor-plugins">Плагины для редакторов и IDE</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/extra-goodies">Дополнительные инструменты</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Основы языка</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/ru/overview">Обзор</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/let-binding">Связывание с использованием let</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/type">Типы!</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/string-and-char">Строки и символы</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/boolean">Логическое значение</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/integer-and-float">Integer и Float</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/tuple">Кортежи</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/record">Запись</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/docs/ru/variant">Variant!</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/null-undefined-option">Null, Undefined и Option</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/list-and-array">Список и массив</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/function">Функции</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/if-else">If-Else</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/pipe-first">Pipe First</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/more-on-type">Больше о типах</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/destructuring">Деструктуризация</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/pattern-matching">Паттерн-матчинг!</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/mutation">Мутации</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/imperative-loops">Императивные циклы</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/jsx">JSX</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/external">External</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/exception">Исключения</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/object">Объекты</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/module">Модули</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/promise">Promise</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">JavaScript</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/ru/interop">Взаимодействие с JavaScript</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/syntax-cheatsheet">Шпаргалка по синтаксису</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/libraries">Библиотеки</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/converting-from-js">Конвертация из JS</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Native</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/ru/native">Native</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/quickstart-ocaml">Native Quickstart</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/convert-from-ocaml">Конвертация из OCaml</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Дополнительно</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/ru/faq">Часто задаваемые вопросы (FAQ)</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/comparison-to-ocaml">Сравнение с OCaml</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/newcomer-examples">Примеры для начинающих</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/project-structure">Структура проекта</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              const headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                if (event.target.tagName === 'A') {
                  document.body.classList.remove('tocActive');
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://crowdin.com/project/reason/ru" target="_blank" rel="noreferrer noopener">Translate</a><h1 class="postHeaderTitle">Variant!</h1></header><article><div><span><p>Трепещите! Драгоценность среди структур данных Reason!</p>
<p>Большая часть структур данных в большинстве языков об этом <strong>и</strong> том. Вариант позволяет нам выразить это <strong>или</strong> то.</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">type</span> myResponseVariant =
  | <span class="hljs-constructor">Yes</span>
  | <span class="hljs-constructor">No</span>
  | <span class="hljs-constructor">PrettyMuch</span>;

<span class="hljs-keyword">let</span> areYouCrushingIt = <span class="hljs-constructor">Yes</span>;
</code></pre>
<p><code>Yes</code>, <code>No</code> и <code>PrettyMuch</code> не строки и не ссылки, а некий специальный тип. Они называются &quot;конструкторами&quot; (или &quot;тегами&quot;). Символ <code>|</code> разделяет каждый конструктор.</p>
<p><strong>Важно</strong>: имена конструкторов должны начинаться с заглавной буквы.</p>
<h2><a class="anchor" aria-hidden="true" id="использование"></a><a href="#использование" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Использование</h2>
<p>Вместе с вариантом идет одна из важнейших фич Reason — <code>switch</code> выражение.</p>
<p><code>switch</code> в Reason визуально очень похож на <code>switch</code> в других языках (или на цепочку <code>if/elseif/elseif...</code>). Оно позволяет проверять все возможные комбинации варианта. Для использования перечислите все конструкторы варианта, который хотите использовать, указав после <code>=&gt;</code> и выражение для конкретного случая.</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> message =
  <span class="hljs-keyword">switch</span> (areYouCrushingIt) {
  | <span class="hljs-constructor">No</span> =&gt; <span class="hljs-string">"No worries. Keep going!"</span>
  | <span class="hljs-constructor">Yes</span> =&gt; <span class="hljs-string">"Great!"</span>
  | <span class="hljs-constructor">PrettyMuch</span> =&gt; <span class="hljs-string">"Nice!"</span>
  };
<span class="hljs-comment">/* message is "Great!" */</span>
</code></pre>
<p>Варианты имеют огромную поддержку со стороны системы типов. Например, она выдаст ошибку, если вы забудете покрыть один из случаем варианта, или если два случая будут взаимозаменяемы. Обязательно прочитайте об этой конструкции и паттер-матчинге в <a href="/docs/ru/pattern-matching">последующей секции</a>!</p>
<h3><a class="anchor" aria-hidden="true" id="вариантам-необходимо-явное-определение"></a><a href="#вариантам-необходимо-явное-определение" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Вариантам необходимо явное определение</h3>
<p>Если вы используете вариант из другого файла, то принесите его в область видимости как вы делаете это <a href="/docs/ru/record#record-needs-an-explicit-definition">для записи</a>:</p>
<pre><code class="hljs css language-reason"><span class="hljs-comment">/* Zoo.re */</span>

<span class="hljs-keyword">type</span> animal = <span class="hljs-constructor">Dog</span> | <span class="hljs-constructor">Cat</span> | <span class="hljs-constructor">Bird</span>;
</code></pre>
<pre><code class="hljs css language-reason"><span class="hljs-comment">/* example.re */</span>

<span class="hljs-keyword">let</span> pet: <span class="hljs-module-identifier">Zoo</span>.animal = <span class="hljs-constructor">Dog</span>; <span class="hljs-comment">/* предпочтительный способ */</span>
<span class="hljs-comment">/* or */</span>
<span class="hljs-keyword">let</span> pet = <span class="hljs-module-identifier">Zoo</span>.<span class="hljs-constructor">Dog</span>;
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="аргументы-конструктора"></a><a href="#аргументы-конструктора" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Аргументы конструктора</h3>
<p>Конструкторы вариантов могут содержать дополнительные данные, разделенные пробелом.</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">type</span> account =
  | <span class="hljs-constructor">None</span>
  | <span class="hljs-constructor">Instagram</span>(string)
  | <span class="hljs-constructor">Facebook</span>(string, int);
</code></pre>
<p>Здесь <code>Instagram</code> содержит <code>string</code>, а <code>Facebook</code> содержит <code>string</code> и <code>int</code>. Использование:</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> myAccount = <span class="hljs-constructor">Facebook</span>(<span class="hljs-string">"Josh"</span>, <span class="hljs-number">26</span>);
<span class="hljs-keyword">let</span> friendAccount = <span class="hljs-constructor">Instagram</span>(<span class="hljs-string">"Jenny"</span>);
</code></pre>
<p><strong>Заметили, что использование конструктора похоже на вызов функции</strong>? Как если бы <code>Facebook</code> был функцией, принимающей два аргумента. Это не случайность, есть основания почему дополнительные данные называются &quot;аргументами конструктора&quot;.</p>
<p>Используя <code>switch</code>, вы можете сопоставлять с образцом (опять же, описано в следующем разделе) аргументы конструктора:</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> greeting =
  <span class="hljs-keyword">switch</span> (myAccount) {
  | <span class="hljs-constructor">None</span> =&gt; <span class="hljs-string">"Hi!"</span>
  | <span class="hljs-constructor">Facebook</span>(name, age) =&gt; <span class="hljs-string">"Hi "</span> <span class="hljs-operator">++</span> name <span class="hljs-operator">++</span> <span class="hljs-string">", you're "</span> <span class="hljs-operator">++</span> string_of_int(age) <span class="hljs-operator">++</span> <span class="hljs-string">"-year-old."</span>
  | <span class="hljs-constructor">Instagram</span>(name) =&gt; <span class="hljs-string">"Hello "</span> <span class="hljs-operator">++</span> name <span class="hljs-operator">++</span> <span class="hljs-string">"!"</span>
  };
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="важные-замечания"></a><a href="#важные-замечания" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Важные замечания</h3>
<p><a href="/api/index.html">Стандартная библиотека</a> предоставляет два важных варианта, которые вы будете часто встречать.</p>
<h4><a class="anchor" aria-hidden="true" id="option"></a><a href="#option" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>option</code></h4>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">type</span> option('a) = <span class="hljs-constructor">None</span> | <span class="hljs-constructor">Some</span>('a);
</code></pre>
<p>Это принятый способ симулировать &quot;нулевой&quot; (<code>undefined</code>, <code>null</code>) тип в других языках. Благодаря этому в Reason нет может быть значений, которые могут оказаться нулевыми. Тип <code>int</code> всегда будет целым и никогда &quot;<code>int</code> <strong>или</strong> <code>null</code> <strong>или</strong> <code>undefined</code>&quot;. Если вам нужно выразить &quot;nullable int&quot;, вы можете использовать <code>option(int)</code>, чье возможное значение <code>None</code> или <code>Some(int)</code>. <code>switch</code> принудит проверить оба случая, <strong>программа на Reason не имеет ошибок связанных с null</strong>.</p>
<h4><a class="anchor" aria-hidden="true" id="list"></a><a href="#list" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>list</code></h4>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">type</span> list('a) = <span class="hljs-constructor">Empty</span> | <span class="hljs-constructor">Head</span>('a, list('a));
</code></pre>
<p><em>Это не настоящий тип, просто иллюстрация</em>.</p>
<p>Это значит: &quot;список, который содержит значение типа <code>a</code> (неважно что это за тип) является или пустым списком или содержит значение + еще список&quot;.</p>
<p>Reason имеет синтаксический сахар <code>list</code>. <code>[1, 2, 3]</code> это эквивалент <code>Head(1, Head(2, Head(3, Empty)))</code>. И опять, <code>switch</code> принудит проверить все случаи, включая <code>Empty</code> (то есть <code>[]</code>). <strong>Это устаняет другую большую категорию багов</strong>.</p>
<h4><a class="anchor" aria-hidden="true" id="другие-типы-похожие-на-варианты"></a><a href="#другие-типы-похожие-на-варианты" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Другие типы, похожие на варианты</h4>
<p>А вы знаете, что можете использовать <code>switch</code> на числах, строках и большинстве структур данных? Попробуйте!</p>
<h2><a class="anchor" aria-hidden="true" id="советы-и-трюки"></a><a href="#советы-и-трюки" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Советы и трюки</h2>
<p><strong>Будте внимательны</strong>: не путайте конструктор, который использует два аргумента с конструктором, который использует кортеж из двух элементов:</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">type</span> account =
  | <span class="hljs-constructor">Facebook</span>(string, int) <span class="hljs-comment">/* два аргумента */</span>;
<span class="hljs-keyword">type</span> account2 =
  | <span class="hljs-constructor">Instagram</span>((string, int)) <span class="hljs-comment">/* один аргумент — кортеж из двух элементов */</span>;
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="варианты-обязаны-иметь-конструкторы"></a><a href="#варианты-обязаны-иметь-конструкторы" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Варианты обязаны иметь конструкторы</h3>
<p>Если вы пришли из нетипизированного языка, то у вас может возникнуть соблазн попробовать <code>type foo = int | string</code>. Это невозможно в Reason. Вы должны дать каждой ветке конструктор <code>type foo = Int(int) | String(string)</code>. Хотя обычно это считается анти-паттерном. Подробные объяснения ниже в разделе «Решения по дизайну».</p>
<h3><a class="anchor" aria-hidden="true" id="взаимодействие-с-javascript"></a><a href="#взаимодействие-с-javascript" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Взаимодействие с JavaScript</h3>
<p><em>Этот раздел подразумевает знание <a href="https://bucklescript.github.io/docs/en/interop-overview.html">FFI</a>. Пропустите этот раздел, если вы еще не испытывали желания использовать перенос функций JS</em>.</p>
<p>Многие JS библиотеки используют функции, которые могут принимать разные типы аргументов. В таких случаях заманчиво моделировать аргументы как варианты. Например, представим что есть функция <code>myLibrary.draw</code> в JS, которая принимает <code>number</code> или <code>string</code>. Вы можете сделать так:</p>
<pre><code class="hljs css language-reason"><span class="hljs-comment">/* reserved for internal usage */</span>
<span class="hljs-attribute">[@bs.module "myLibrary"]</span> <span class="hljs-keyword">external</span> draw : 'a =&gt; unit = <span class="hljs-string">"draw"</span>;

<span class="hljs-keyword">type</span> animal =
  | <span class="hljs-constructor">MyFloat</span>(float)
  | <span class="hljs-constructor">MyString</span>(string);

<span class="hljs-keyword">let</span> betterDraw = (animal) =&gt;
  <span class="hljs-keyword">switch</span> (animal) {
  | <span class="hljs-constructor">MyFloat</span>(f) =&gt; draw(f)
  | <span class="hljs-constructor">MyString</span>(s) =&gt; draw(s)
  };
</code></pre>
<p>Но есть лучший способ! Например, просто два <code>external</code> которые компилируются в один JS вызов:</p>
<pre><code class="hljs css language-reason"><span class="hljs-attribute">[@bs.module "myLibrary"]</span> <span class="hljs-keyword">external</span> drawFloat : float =&gt; unit = <span class="hljs-string">"draw"</span>;
<span class="hljs-attribute">[@bs.module "myLibrary"]</span> <span class="hljs-keyword">external</span> drawString : string =&gt; unit = <span class="hljs-string">"draw"</span>;
</code></pre>
<p>BuckleScript также предоставляет <a href="https://bucklescript.github.io/docs/en/function.html#modeling-polymorphic-function">несколько других способов</a> сделать это.</p>
<h3><a class="anchor" aria-hidden="true" id="типы-вариантов-выводятся-из-имен-полей"></a><a href="#типы-вариантов-выводятся-из-имен-полей" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Типы вариантов выводятся из имен полей</h3>
<p>Пожалуйста, обратитесь к <a href="/docs/ru/record#record-types-are-found-by-field-name">разделу Record</a>. Variant такой же: функция не может принять произвольный конструктор, совместно используемый двумя различными вариантами. Опять же, такая особенность существует, она называется полиморфным вариантом. Мы поговорим об этом в будущем =).</p>
<h2><a class="anchor" aria-hidden="true" id="проектные-решения"></a><a href="#проектные-решения" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Проектные решения</h2>
<p>Варианты в различных формах (полиморфные, открытые, GADT, и так далее), возможно, основная фича таких систем типов как в Reason. Вышеупомянутый вариант <code>option</code>, например убирает необходимость использовать nullable типы. Философски говоря, проблема состоит и множества веток и условий. Ошибки в формировании этих условиях являются основным источником багов в других языках. <strong>Система типов не устраняет баги магическим образом. Она указвывает на необработанные случаи и просить закрыть их</strong>*. Способность языка моделировать идею &quot;это или то&quot; имеет решающее значение для этого.</p>
<p>Например, некоторые люди задаются вопросом, как система типов может безопасно исключить плохо отформатированный JSON от распространения дальше в программу. Она не может сделать это самостоятельно! Это можно сделать если парсер будет возвращать тип <code>option</code>, то есть <code>None | Some(actualData)</code>, тогда все что нужно — это обработать случай с <code>None</code>. Это все, что у нас есть.</p>
<p>К тому же вариант может значительно ускорить логику вашей программы. Возьмем кусок JS кода:</p>
<pre><code class="hljs css language-js"><span class="hljs-keyword">let</span> data = <span class="hljs-string">'dog'</span>;
<span class="hljs-keyword">if</span> (data === <span class="hljs-string">'dog'</span>) {
  ...
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (data === <span class="hljs-string">'cat'</span>) {
  ...
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (data === <span class="hljs-string">'bird'</span>) {
  ...
}
</code></pre>
<p>Тут существует линейное количество проверок (<code>O(n)</code>). Сравните с подобным кодом на Reason:</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">type</span> animal = <span class="hljs-constructor">Dog</span> | <span class="hljs-constructor">Cat</span> | <span class="hljs-constructor">Bird</span>;
<span class="hljs-keyword">let</span> data = <span class="hljs-constructor">Dog</span>;
<span class="hljs-keyword">switch</span> (data) {
| <span class="hljs-constructor">Dog</span> =&gt; <span class="hljs-operator">...</span>
| <span class="hljs-constructor">Cat</span> =&gt; <span class="hljs-operator">...</span>
| <span class="hljs-constructor">Bird</span> =&gt; <span class="hljs-operator">...</span>
}
</code></pre>
<p>Компилятор видит вариант и потом:</p>
<ol>
<li>Превращает его в <code>type animal = 0 | 1 | 2</code></li>
<li>Компилирует <code>switch</code> в формат с константным временем (<code>O(1)</code>).</li>
</ol>
<p>Вы можете задаться вопросом, почему типизированные функциональные языки используются так часто для синтаксического анализа. Переключение большого дерева эффективно и безопасно - это в значительной степени лучший сценарий для использования вариантов.</p>
<!-- TODO: playground link -->
<p>Ваш мозг уже кипит? Варианты имеют глубокую связь с другими областями математики; <a href="https://codewords.recurse.com/issues/three/algebra-and-calculus-of-algebraic-data-types">Посмотрите тут</a> если интересно.</p>
<p>* Всегда лучше проектировать систему так, чтобы избежать подводных камней, а не надеяться на систему типов; Однако, в реальности, сложно сделать это для каждой проблемы. Более того не всегда удается понять проблему полностью, чтобы спроектировать решение сразу. Система типов позволяет внести разнообразные изменения в кодовую базу без необходимости понимать все целиком. Это отлично подходит для управляемого исследования. В связи с эти типы позволяют не затрачивать много времени на дизайн API чтобы обойти простые ошибки, вызванные вызывающей стороной. Они уменьшают уровень абстракций, необходимый для достижения цели, что уменьшает когнитивную нагрузку.</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/ru/record"><span class="arrow-prev">← </span><span>Запись</span></a><a class="docs-next button" href="/docs/ru/null-undefined-option"><span>Null, Undefined и Option</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#использование">Использование</a><ul class="toc-headings"><li><a href="#вариантам-необходимо-явное-определение">Вариантам необходимо явное определение</a></li><li><a href="#аргументы-конструктора">Аргументы конструктора</a></li><li><a href="#важные-замечания">Важные замечания</a></li></ul></li><li><a href="#советы-и-трюки">Советы и трюки</a><ul class="toc-headings"><li><a href="#варианты-обязаны-иметь-конструкторы">Варианты обязаны иметь конструкторы</a></li><li><a href="#взаимодействие-с-javascript">Взаимодействие с JavaScript</a></li><li><a href="#типы-вариантов-выводятся-из-имен-полей">Типы вариантов выводятся из имен полей</a></li></ul></li><li><a href="#проектные-решения">Проектные решения</a></li></ul></nav></div><span><script src="/js/redirectBlog.js"></script><script src="/js/pjax-api.min.js"></script><script>window.foo = new Pjax({
          areas: [
            // try to use the first query.
            '.mainContainer, .docsNavContainer .toc .navWrapper, .onPageNav',
            // fallback
            'body'
          ],
          link: '.docsNavContainer:not(.docsSliderActive) a',
          update: {
            script: false,
          }
        });
        var languagesMenuItemCopy = document.getElementById("languages-menu");
        languagesMenuItemCopy.addEventListener("click", function(e){
          e.preventDefault();
          e.stopPropagation();
          e.stopImmediatePropagation();
        });</script></span></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                
                apiKey: '966d1e412f67114a07dc0afe44b19b53',
                indexName: 'reason',
                inputSelector: '#search_input_react',
                algoliaOptions: {"facetFilters":["lang:ru"]}
              });
            </script></body></html>