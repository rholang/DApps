<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Record · Reason</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="&lt;p&gt;JavaScript의 오브젝트와 닮았지만, 레코드는 이런 점이 다릅니다.&lt;/p&gt;
"/><meta name="docsearch:language" content="ko"/><meta property="og:title" content="Record · Reason"/><meta property="og:type" content="website"/><meta property="og:url" content="https://reasonml.github.io/"/><meta property="og:description" content="&lt;p&gt;JavaScript의 오브젝트와 닮았지만, 레코드는 이런 점이 다릅니다.&lt;/p&gt;
"/><meta name="twitter:card" content="summary"/><link rel="shortcut icon" href="/img/icon_50.png"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"/><link rel="alternate" type="application/atom+xml" href="https://reasonml.github.io/blog/atom.xml" title="Reason Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://reasonml.github.io/blog/feed.xml" title="Reason Blog RSS Feed"/><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/ko"><img class="logo" src="/img/dummy.svg" alt="Reason"/></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/docs/ko/what-and-why" target="_self">문서</a></li><li class=""><a href="/ko/try" target="_self">해보기</a></li><li class=""><a href="/api/index" target="_self">API</a></li><li class=""><a href="/docs/ko/community" target="_self">커뮤니티</a></li><li class=""><a href="/blog/" target="_self">블로그</a></li><span><li><a id="languages-menu" href="#"><img class="languages-icon" src="/img/language.svg" alt="Languages icon"/>한국어</a><div id="languages-dropdown" class="hide"><ul id="languages-dropdown-items"><li><a href="/docs/ja/record">日本語</a></li><li><a href="/docs/en/record">English</a></li><li><a href="/docs/de/record">Deutsch</a></li><li><a href="/docs/es-ES/record">Español</a></li><li><a href="/docs/fr/record">Français</a></li><li><a href="/docs/pt-BR/record">Português (Brasil)</a></li><li><a href="/docs/ru/record">Русский</a></li><li><a href="/docs/uk/record">Українська</a></li><li><a href="/docs/zh-CN/record">中文</a></li><li><a href="/docs/zh-TW/record">繁體中文</a></li><li><a href="https://crowdin.com/project/reason" target="_blank" rel="noreferrer noopener">번역 돕기</a></li></ul></div></li><script>
        const languagesMenuItem = document.getElementById("languages-menu");
        const languagesDropDown = document.getElementById("languages-dropdown");
        languagesMenuItem.addEventListener("click", function(event) {
          event.preventDefault();

          if (languagesDropDown.className == "hide") {
            languagesDropDown.className = "visible";
          } else {
            languagesDropDown.className = "hide";
          }
        });
      </script></span><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li><li class=""><a href="https://github.com/facebook/reason" target="_self">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><i></i></div><h2><i>›</i><span>언어 기본</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Intro</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/ko/what-and-why">What &amp; Why</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Setup</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/ko/installation">Installation</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/editor-plugins">에디터 플러그인</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/extra-goodies">추가적으로 매력적인 것들</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">언어 기본</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/ko/overview">개요</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/let-binding">Let 바인딩</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/type">타입!</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/string-and-char">문자열 &amp; 문자</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/boolean">부울</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/integer-and-float">정수 &amp; 실수</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/tuple">튜플</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/docs/ko/record">Record</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/variant">Variant!</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/null-undefined-option">Null, Undefined &amp; Option</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/list-and-array">리스트 &amp; 배열</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/function">함수</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/if-else">If-Else</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/pipe-first">Pipe First</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/more-on-type">More on Type</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/destructuring">비구조화</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/pattern-matching">패턴 매칭!</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/mutation">Mutation</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/imperative-loops">Imperative Loops</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/jsx">JSX</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/external">외부 접근</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/exception">예외</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/object">Object</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/module">모듈</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/promise">프라미스</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">JavaScript</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/ko/interop">연동</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/syntax-cheatsheet">문법 치트시트</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/libraries">라이브러리</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/converting-from-js">JS에서 변환</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Native</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/ko/native">Native</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/quickstart-ocaml">Native Quickstart</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/convert-from-ocaml">OCaml에서 변환</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Extra</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/ko/faq">자주 물어보는 질문</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/comparison-to-ocaml">OCaml과 비교</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/newcomer-examples">신입들을 위한 예시</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/project-structure">프로젝트 구조</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              const headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                if (event.target.tagName === 'A') {
                  document.body.classList.remove('tocActive');
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://crowdin.com/project/reason/ko" target="_blank" rel="noreferrer noopener">Translate</a><h1 class="postHeaderTitle">Record</h1></header><article><div><span><p>JavaScript의 오브젝트와 닮았지만, 레코드는 이런 점이 다릅니다.</p>
<ul>
<li>가벼움</li>
<li>기본으로 불변</li>
<li>타입과 필드명이 고정적임</li>
<li>매우 빠름</li>
<li>강한 타입 검사</li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="사용"></a><a href="#사용" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>사용</h2>
<p>타입 (필수):</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">type</span> person = {
  age: int,
  name: string
};
</code></pre>
<p>값 (이는 <code>person</code> 타입으로 추론됨):</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> me = {
  age: <span class="hljs-number">5</span>,
  name: <span class="hljs-string">"Big Reason"</span>
};
</code></pre>
<p>접근 (친숙한 온점 표기법):</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> name = me.name;
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="레코드는-명시적-정의가-필요합니다"></a><a href="#레코드는-명시적-정의가-필요합니다" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>레코드는 명시적 정의가 필요합니다</h3>
<p>만약 위의 어딘가에 명시적인 선언 없이 <code>{age: 5, name: &quot;Baby Reason&quot;}</code> 를 작성한다면, 타입 시스템은 에러를 발생시킵니다. 만약 타입 정의가 다른 파일에 존재하면, 파일을 명시적으로 표시해야 합니다.</p>
<pre><code class="hljs css language-reason"><span class="hljs-comment">/* School.re */</span>

<span class="hljs-keyword">type</span> person = {age: int, name: string};
</code></pre>
<pre><code class="hljs css language-reason"><span class="hljs-comment">/* example.re */</span>

<span class="hljs-keyword">let</span> me: <span class="hljs-module-identifier">School</span>.person = {age: <span class="hljs-number">20</span>, name: <span class="hljs-string">"Big Reason"</span>};
<span class="hljs-comment">/* or */</span>
<span class="hljs-keyword">let</span> me = <span class="hljs-module-identifier">School</span>.{age: <span class="hljs-number">20</span>, name: <span class="hljs-string">"Big Reason"</span>};
<span class="hljs-comment">/* or */</span>
<span class="hljs-keyword">let</span> me = {<span class="hljs-module-identifier">School</span>.age: <span class="hljs-number">20</span>, name: <span class="hljs-string">"Big Reason"</span>};
</code></pre>
<p>위의 세 가지 모두 &quot;이 레코드의 정의는 School 파일에 있습니다&quot; 라고 합니다. 표준 타입 명시인 첫 번째가 좋습니다.</p>
<h3><a class="anchor" aria-hidden="true" id="immutable-update"></a><a href="#immutable-update" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Immutable Update</h3>
<p>New records can be created from old records with the <code>...</code> spread operator. The original record isn't mutated.</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> meNextYear = {<span class="hljs-operator">...</span>me, age: me.age <span class="hljs-operator">+</span> <span class="hljs-number">1</span>};
</code></pre>
<p>This update is very efficient! Try a few in our <a href="/try.html">playground</a> to see how records are compiled.</p>
<p><strong>Note</strong>: spread cannot add new fields, as a record's shape is fixed by its type.</p>
<h3><a class="anchor" aria-hidden="true" id="mutable-update"></a><a href="#mutable-update" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Mutable Update</h3>
<p>Record fields can optionally be mutable. This allows you to update those fields in-place with the <code>=</code> operator.</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">type</span> person = {
  name: string,
  <span class="hljs-keyword">mutable</span> age: int
};
<span class="hljs-keyword">let</span> baby = {name: <span class="hljs-string">"Baby Reason"</span>, age: <span class="hljs-number">5</span>};
baby.age = baby.age <span class="hljs-operator">+</span> <span class="hljs-number">1</span>; <span class="hljs-comment">/* alter `baby`. Happy birthday! */</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="syntax-shorthand"></a><a href="#syntax-shorthand" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Syntax shorthand</h2>
<p>To reduce redundancy, we provide <strong>punning</strong> for a record's types and values. Punning refers to the syntax shorthand you can use when the name of a field matches the name of its value/type:</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">type</span> horsePower = {power: int, metric: bool};

<span class="hljs-keyword">let</span> metric = <span class="hljs-literal">true</span>;
<span class="hljs-keyword">let</span> someHorsePower = {power: <span class="hljs-number">10</span>, metric};
<span class="hljs-comment">/* same as the value {power: 10, metric: metric}; */</span>

<span class="hljs-keyword">type</span> car = {name: string, horsePower};
<span class="hljs-comment">/* same as the type {name: string, horsePower: horsePower}; */</span>
</code></pre>
<p><strong>Note that there's no punning for a single record field</strong>! <code>{foo}</code> doesn't do what you expect (it's a block that returns the value <code>foo</code>).</p>
<h2><a class="anchor" aria-hidden="true" id="팁-트릭"></a><a href="#팁-트릭" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>팁 &amp; 트릭</h2>
<h3><a class="anchor" aria-hidden="true" id="javascript와의-연동"></a><a href="#javascript와의-연동" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>JavaScript와의 연동</h3>
<p>If you're working with JavaScript, the record syntax &amp; operations should feel familiar, and you might be tempted to interop with JS by converting a JS object to a record, and vice-versa. This is fine, but we have an <strong>even better way without conversion overhead</strong>! See <a href="https://bucklescript.github.io/docs/en/object.html#record-mode">here</a></p>
<h3><a class="anchor" aria-hidden="true" id="record-types-are-found-by-field-name"></a><a href="#record-types-are-found-by-field-name" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Record Types Are Found By Field Name</h3>
<p>With records, you <strong>cannot</strong> say &quot;I'd like this function to take any record type, as long as they have the field <code>age</code>&quot;. The following <em>works</em>, but not as expected:</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">type</span> person = {age: int, name: string};
<span class="hljs-keyword">type</span> monster = {age: int, hasTentacles: bool};

<span class="hljs-keyword">let</span> getAge = (entity) =&gt; entity.age;
</code></pre>
<p>The last line's function will infer that the parameter <code>entity</code> must be of type <code>monster</code>. The following code's last line fails:</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> kraken = {age: <span class="hljs-number">9999</span>, hasTentacles: <span class="hljs-literal">true</span>};
<span class="hljs-keyword">let</span> me = {age: <span class="hljs-number">5</span>, name: <span class="hljs-string">"Baby Reason"</span>};

getAge(kraken);
getAge(me);
</code></pre>
<p>The type system will complain that <code>me</code> is a <code>person</code>, and that <code>getAge</code> only works on <code>monster</code>. If you need such capability, use Reason objects, described <a href="/docs/ko/object">here</a>.</p>
<h2><a class="anchor" aria-hidden="true" id="디자인-결정"></a><a href="#디자인-결정" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>디자인 결정</h2>
<p>After reading the constraints in the previous sections, and if you're coming from a dynamic language background, you might be wondering why one would bother with record in the first place instead of straight using object, since the former needs explicit typing and doesn't allow different records with the same field name to be passed to the same function, etc.</p>
<ol>
<li>The truth is that most of the times in your app, your data's shape is actually fixed, and if it's not, it can potentially be better represented as a combination of variant (introduced next) + record instead*.</li>
<li>Record, since its fields are fixed, is compiled to an array with array index accesses instead of JS object (try it in the playground!). On native, it compiles to basically a region of memory where a field access is just one field lookup + one actual access, aka <strong>2 assembly instructions</strong>. The good old days where folks measured in nanoseconds...</li>
<li>Finally, since a record type is resolved through finding that single explicit type declaration (we call this &quot;nominal typing&quot;), the type error messages end up better than the counterpart (&quot;structural typing&quot;, like for tuples). This makes refactoring easier; changing a record type's fields naturally allows the compiler to know that it's still the same record, just misused in some places. Otherwise, under structural typing, it might get hard to tell whether the definition site or the usage site is wrong.</li>
</ol>
<p>* And we're not just finding excuses for ourselves! Reason objects do support these features.</p>
<!--TODO: sharable playground for 2 --></span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/ko/tuple"><span class="arrow-prev">← </span><span>튜플</span></a><a class="docs-next button" href="/docs/ko/variant"><span>Variant!</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#사용">사용</a><ul class="toc-headings"><li><a href="#레코드는-명시적-정의가-필요합니다">레코드는 명시적 정의가 필요합니다</a></li><li><a href="#immutable-update">Immutable Update</a></li><li><a href="#mutable-update">Mutable Update</a></li></ul></li><li><a href="#syntax-shorthand">Syntax shorthand</a></li><li><a href="#팁-트릭">팁 &amp; 트릭</a><ul class="toc-headings"><li><a href="#javascript와의-연동">JavaScript와의 연동</a></li><li><a href="#record-types-are-found-by-field-name">Record Types Are Found By Field Name</a></li></ul></li><li><a href="#디자인-결정">디자인 결정</a></li></ul></nav></div><span><script src="/js/redirectBlog.js"></script><script src="/js/pjax-api.min.js"></script><script>window.foo = new Pjax({
          areas: [
            // try to use the first query.
            '.mainContainer, .docsNavContainer .toc .navWrapper, .onPageNav',
            // fallback
            'body'
          ],
          link: '.docsNavContainer:not(.docsSliderActive) a',
          update: {
            script: false,
          }
        });
        var languagesMenuItemCopy = document.getElementById("languages-menu");
        languagesMenuItemCopy.addEventListener("click", function(e){
          e.preventDefault();
          e.stopPropagation();
          e.stopImmediatePropagation();
        });</script></span></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                
                apiKey: '966d1e412f67114a07dc0afe44b19b53',
                indexName: 'reason',
                inputSelector: '#search_input_react',
                algoliaOptions: {"facetFilters":["lang:ko"]}
              });
            </script></body></html>