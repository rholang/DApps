<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>자주 물어보는 질문 · Reason</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="&lt;h3&gt;&lt;a class=&quot;anchor&quot; aria-hidden=&quot;true&quot; id=&quot;reason과-ocaml-중-뭘-먼저-배워야-할까요&quot;&gt;&lt;/a&gt;&lt;a href=&quot;#reason과-ocaml-중-뭘-먼저-배워야-할까요&quot; aria-hidden=&quot;true&quot; class=&quot;hash-link&quot;&gt;&lt;svg class=&quot;hash-link-icon&quot; aria-hidden=&quot;true&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Reason과 OCaml 중 뭘 먼저 배워야 할까요?&lt;/h3&gt;
"/><meta name="docsearch:language" content="ko"/><meta property="og:title" content="자주 물어보는 질문 · Reason"/><meta property="og:type" content="website"/><meta property="og:url" content="https://reasonml.github.io/"/><meta property="og:description" content="&lt;h3&gt;&lt;a class=&quot;anchor&quot; aria-hidden=&quot;true&quot; id=&quot;reason과-ocaml-중-뭘-먼저-배워야-할까요&quot;&gt;&lt;/a&gt;&lt;a href=&quot;#reason과-ocaml-중-뭘-먼저-배워야-할까요&quot; aria-hidden=&quot;true&quot; class=&quot;hash-link&quot;&gt;&lt;svg class=&quot;hash-link-icon&quot; aria-hidden=&quot;true&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Reason과 OCaml 중 뭘 먼저 배워야 할까요?&lt;/h3&gt;
"/><meta name="twitter:card" content="summary"/><link rel="shortcut icon" href="/img/icon_50.png"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"/><link rel="alternate" type="application/atom+xml" href="https://reasonml.github.io/blog/atom.xml" title="Reason Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://reasonml.github.io/blog/feed.xml" title="Reason Blog RSS Feed"/><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/ko"><img class="logo" src="/img/dummy.svg" alt="Reason"/></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/docs/ko/what-and-why" target="_self">문서</a></li><li class=""><a href="/ko/try" target="_self">해보기</a></li><li class=""><a href="/api/index" target="_self">API</a></li><li class=""><a href="/docs/ko/community" target="_self">커뮤니티</a></li><li class=""><a href="/blog/" target="_self">블로그</a></li><span><li><a id="languages-menu" href="#"><img class="languages-icon" src="/img/language.svg" alt="Languages icon"/>한국어</a><div id="languages-dropdown" class="hide"><ul id="languages-dropdown-items"><li><a href="/docs/ja/faq">日本語</a></li><li><a href="/docs/en/faq">English</a></li><li><a href="/docs/de/faq">Deutsch</a></li><li><a href="/docs/es-ES/faq">Español</a></li><li><a href="/docs/fr/faq">Français</a></li><li><a href="/docs/pt-BR/faq">Português (Brasil)</a></li><li><a href="/docs/ru/faq">Русский</a></li><li><a href="/docs/uk/faq">Українська</a></li><li><a href="/docs/zh-CN/faq">中文</a></li><li><a href="/docs/zh-TW/faq">繁體中文</a></li><li><a href="https://crowdin.com/project/reason" target="_blank" rel="noreferrer noopener">번역 돕기</a></li></ul></div></li><script>
        const languagesMenuItem = document.getElementById("languages-menu");
        const languagesDropDown = document.getElementById("languages-dropdown");
        languagesMenuItem.addEventListener("click", function(event) {
          event.preventDefault();

          if (languagesDropDown.className == "hide") {
            languagesDropDown.className = "visible";
          } else {
            languagesDropDown.className = "hide";
          }
        });
      </script></span><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li><li class=""><a href="https://github.com/facebook/reason" target="_self">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><i></i></div><h2><i>›</i><span>Extra</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Intro</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/ko/what-and-why">What &amp; Why</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Setup</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/ko/installation">Installation</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/editor-plugins">에디터 플러그인</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/extra-goodies">추가적으로 매력적인 것들</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">언어 기본</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/ko/overview">개요</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/let-binding">Let 바인딩</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/type">타입!</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/string-and-char">문자열 &amp; 문자</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/boolean">부울</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/integer-and-float">정수 &amp; 실수</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/tuple">튜플</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/record">Record</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/variant">Variant!</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/null-undefined-option">Null, Undefined &amp; Option</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/list-and-array">리스트 &amp; 배열</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/function">함수</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/if-else">If-Else</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/pipe-first">Pipe First</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/more-on-type">More on Type</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/destructuring">비구조화</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/pattern-matching">패턴 매칭!</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/mutation">Mutation</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/imperative-loops">Imperative Loops</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/jsx">JSX</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/external">외부 접근</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/exception">예외</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/object">Object</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/module">모듈</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/promise">프라미스</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">JavaScript</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/ko/interop">연동</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/syntax-cheatsheet">문법 치트시트</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/libraries">라이브러리</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/converting-from-js">JS에서 변환</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Native</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/ko/native">Native</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/quickstart-ocaml">Native Quickstart</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/convert-from-ocaml">OCaml에서 변환</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Extra</h3><ul class=""><li class="navListItem navListItemActive"><a class="navItem" href="/docs/ko/faq">자주 물어보는 질문</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/comparison-to-ocaml">OCaml과 비교</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/newcomer-examples">신입들을 위한 예시</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/project-structure">프로젝트 구조</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              const headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                if (event.target.tagName === 'A') {
                  document.body.classList.remove('tocActive');
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://crowdin.com/project/reason/ko" target="_blank" rel="noreferrer noopener">Translate</a><h1 class="postHeaderTitle">자주 물어보는 질문</h1></header><article><div><span><h3><a class="anchor" aria-hidden="true" id="reason과-ocaml-중-뭘-먼저-배워야-할까요"></a><a href="#reason과-ocaml-중-뭘-먼저-배워야-할까요" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Reason과 OCaml 중 뭘 먼저 배워야 할까요?</h3>
<p>고를 필요 없습니다! Reason과 OCaml은 정확히 같은 (예를 들어 코드를 어떻게 실행하는가와 같은) 구조를 공유합니다. 오직 문법만 다를 뿐입니다. <a href="https://github.com/reasonml/reason-tools">Reason-도구</a>를 사용해서 두 언어의 코드를 자유롭게 변환할 수 있습니다. Reason의 튜토리얼은 OCaml의 튜토리얼이고, 역으로도 성립합니다. In the terminal, you can have these aliases:</p>
<pre><code class="hljs css language-sh"><span class="hljs-comment"># converts ocaml code into reason</span>
<span class="hljs-built_in">alias</span> mlre=<span class="hljs-string">"pbpaste | refmt --parse ml --print re --interface false | pbcopy"</span>
<span class="hljs-comment"># converts reason code into ocaml</span>
<span class="hljs-built_in">alias</span> reml=<span class="hljs-string">"pbpaste | refmt --parse re --print ml --interface false | pbcopy"</span>
</code></pre>
<p>They'll take your code from the (macOS) clipboard, convert it, and paste it back into your clipboard! Swap out pbpaste/pbcopy with your system's clipboard functions.</p>
<h3><a class="anchor" aria-hidden="true" id="reason으로-뭘-해야할지-모르겠습니다"></a><a href="#reason으로-뭘-해야할지-모르겠습니다" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Reason으로 뭘 해야할지 모르겠습니다.</h3>
<p>Think of what project you'd usually make if it was pure JavaScript; try porting/writing that in Reason + BuckleScript instead! We recommend trying to make concrete, end-user projects (e.g. a little command line util) rather than infra-level projects (e.g. a boilerplate generator). The latter category requires expertise and understanding idiomatic Reason code.</p>
<h3><a class="anchor" aria-hidden="true" id="reason-bucklescript-그리고-ocaml-사이의-관계는-뭐죠"></a><a href="#reason-bucklescript-그리고-ocaml-사이의-관계는-뭐죠" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Reason, BuckleScript 그리고 OCaml 사이의 관계는 뭐죠?</h3>
<p>Reason's a syntax for OCaml and supports all its features. BuckleScript compiles OCaml/Reason code into JavaScript.</p>
<h3><a class="anchor" aria-hidden="true" id="where-do-all-these-print_endline-string_of_int-functions-come-from"></a><a href="#where-do-all-these-print_endline-string_of_int-functions-come-from" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Where do all these <code>print_endline</code>, <code>string_of_int</code> functions come from?</h3>
<p>They're from the standard library, pre-<code>open</code>ed during the compilation of your file. This is why you see them in scope.</p>
<p>You can read more about the Pervasives library in the api documentation:</p>
<p><a href="https://reasonml.github.io/api/Pervasives.html">https://reasonml.github.io/api/Pervasives.html</a></p>
<h3><a class="anchor" aria-hidden="true" id="임의의-데이터-구조를-출력하는-함수가-있나요"></a><a href="#임의의-데이터-구조를-출력하는-함수가-있나요" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>임의의 데이터 구조를 출력하는 함수가 있나요?</h3>
<p>만약 BuckleScript를 통해 JavaScript로 컴파일한다면, <a href="https://bucklescript.github.io/bucklescript/api/Js.html#VALlog"><code>JS.log</code></a>를 통해 JS의 <code>console.log</code>를 쓸 수 있습니다. If you're compiling to native, you'll need something like <a href="https://github.com/diml/ppx_show">ppx_show</a>. A future OCaml feature (called modular implicit) will solve this directly in the language.</p>
<h3><a class="anchor" aria-hidden="true" id="왜-는-정수의-덧셈에-사용되고-은-실수의-덧셈에-사용되나요"></a><a href="#왜-는-정수의-덧셈에-사용되고-은-실수의-덧셈에-사용되나요" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>왜 +는 정수의 덧셈에 사용되고 +. 은 실수의 덧셈에 사용되나요?</h3>
<p><a href="/docs/ko/integer-and-float#design-decisions">여기</a>를 참조하세요.</p>
<h3><a class="anchor" aria-hidden="true" id="reason에서-___-라이브러리가-작동하나요"></a><a href="#reason에서-___-라이브러리가-작동하나요" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Reason에서 ___ 라이브러리가 작동하나요?</h3>
<p>Most JS libraries should easily work under Reason + BuckleScript. On the native side, since Reason's just a syntax transform: yes, they work with Reason too. But the native workflow is currently work-in-progress and needs polish.</p>
<h3><a class="anchor" aria-hidden="true" id="what-s-the-server-side-story-should-i-compile-to-native-or-to-js-and-use-nodejs"></a><a href="#what-s-the-server-side-story-should-i-compile-to-native-or-to-js-and-use-nodejs" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>What's the server-side story? Should I compile to native or to JS and use node.js?</h3>
<p>We do compile to native, but the native workflow is currently work-in-progress. At this time, we recommend compiling to JS through BuckleScript and use the JS wrappers at <a href="https://github.com/reasonml-community">reasonml-community</a> or somewhere else.</p>
<h3><a class="anchor" aria-hidden="true" id="what-s-bucklescript-s-async-story"></a><a href="#what-s-bucklescript-s-async-story" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>What's BuckleScript's async story?</h3>
<p>First, if you're not interfacing with any library that uses promises, you can simply use callbacks. Everyone gets them and they're performant.</p>
<p>If you need to bind to a JS library that uses promises, or communicate with such library, you can use BS's <a href="http://bucklescript.github.io/bucklescript/api/Js.Promise.html">Js.Promise</a>. There's also potential to have some syntactic sugar in the future. In the long run, we'd like to implement a spec-compliant promises implementation in OCaml/Reason proper, so that the compiler optimizations could kick in.</p>
<p>For a more idiomatic OCaml solution: on the native OCaml side, we have <a href="http://ocsigen.org/lwt/">lwt</a> and <a href="https://ocaml.janestreet.com/ocaml-core/111.03.00/doc/async/#Std">Async</a>. We don't use them in web right now, but we might in the future.</p>
<h3><a class="anchor" aria-hidden="true" id="what-s-the-unit-test-story"></a><a href="#what-s-the-unit-test-story" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>What's the (unit) test story?</h3>
<p>Some of OCaml's language features (not just types) might be able to defer the need for unit testing until later. In the meantime, for compilation to JS, we're working on <a href="https://github.com/BuckleTypes/bs-jest">Jest wrapper</a>. We'll look into using Jest for native too, if Jest is written using Reason in the future (no concrete plan yet). <a href="http://ounit.forge.ocamlcore.org">OUnit</a> is a good, small native OCaml testing library right now.</p>
<h3><a class="anchor" aria-hidden="true" id="내-프로젝트에-있는-merlin-파일은-뭔가요"></a><a href="#내-프로젝트에-있는-merlin-파일은-뭔가요" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>내 프로젝트에 있는 <code>.merlin</code> 파일은 뭔가요?</h3>
<p><a href="/docs/ko/editor-plugins">편집기 지원</a>을 위한 메타데이터 파일입니다. 일반적으로 당신을 위해 만들어지며, 살펴 볼 필요도, 버전 제어를 할 필요도, 수동 수정을 할 필요도 없습니다.</p>
<h3><a class="anchor" aria-hidden="true" id="저는-import-나-require-를-코드에서-본-적이-없습니다-모듈이-어떻게-작동할-수-있는거죠"></a><a href="#저는-import-나-require-를-코드에서-본-적이-없습니다-모듈이-어떻게-작동할-수-있는거죠" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>저는 <code>import</code> 나 <code>require</code>를 코드에서 본 적이 없습니다. 모듈이 어떻게 작동할 수 있는거죠?</h3>
<p>Reason/OCaml에서는 어떤 가져오기도 쓸 필요 없습니다. 프로젝트 안 파일에서 찾아 자동으로 모듈을 연결해줍니다. Specifically, a module <code>Hello</code> asks the compiler to look for the file <code>hello.re</code> or <code>hello.ml</code> (and their corresponding <a href="/docs/ko/module#signatures">interface file</a>, <code>hello.rei</code> or <code>hello.mli</code>, if available).</p>
<p>A module name is the file name, capitalized. It has to be unique per project; this abstracts away the file system and allows you to move files around without changing code.</p>
<h3><a class="anchor" aria-hidden="true" id="is-some-none-contents-array-list-and-all-of-these-special-where-do-they-come-from"></a><a href="#is-some-none-contents-array-list-and-all-of-these-special-where-do-they-come-from" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Is <code>Some | None</code>, <code>contents</code>, <code>Array</code>, <code>List</code> and all of these special? Where do they come from?</h3>
<p>They're ordinary variants/records/module definitions that come with the <a href="/api/index.html">standard library</a>, <code>open</code>ed by default during compilation out of convenience.</p>
<h3><a class="anchor" aria-hidden="true" id="밑줄로-시작하는-인수예를-들어-_-혹은-_foo-는-무엇을-의미하죠"></a><a href="#밑줄로-시작하는-인수예를-들어-_-혹은-_foo-는-무엇을-의미하죠" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>밑줄로 시작하는 인수(예를 들어 <code>_</code> 혹은 <code>_foo</code>)는 무엇을 의미하죠?</h3>
<p><code>List.map(item =&gt; 1, myList);</code> 라는 코드가 있다고 합시다. 인수 <code>item</code>은 쓰이지 않고, 컴파일러가 이에 대해 경고를 줄 겁니다. 위 코드 대신 <code>_ =&gt; 1</code>을 쓰면 의도적으로 값을 받고 무시한다는 것을 알려주며, 경고를 없앨 수 있습니다. <code>_item =&gt; 1</code> 역시 같은 효과입니다. 하지만 어떤 것을 무시하는지 더 자세히 나타내주죠.</p>
<h3><a class="anchor" aria-hidden="true" id="what-s-this-mymodulet-i-keep-seeing"></a><a href="#what-s-this-mymodulet-i-keep-seeing" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>What's this <code>MyModule.t</code> I keep seeing?</h3>
<p>Assuming <code>MyModule</code> is a module's name, <code>t</code> is a community convention that indicates &quot;the type that represents that module, whatever that means&quot;. For example, for the <a href="http://bucklescript.github.io/bucklescript/api/Js.String.html"><code>Js.String</code></a> module, <a href="http://bucklescript.github.io/bucklescript/api/Js.String.html#TYPEt"><code>String.t</code></a> is the type carried around and representing &quot;a string&quot;.</p>
<h3><a class="anchor" aria-hidden="true" id="why-is-there-a-js_promise-http-bucklescriptgithubio-bucklescript-api-js_promisehtml-and-then-a-jspromise-http-bucklescriptgithubio-bucklescript-api-jspromisehtml-what-about-js_array-http-bucklescriptgithubio-bucklescript-api-js_arrayhtml-js_string-http-bucklescriptgithubio-bucklescript-api-js_stringhtml-and-whatever-else"></a><a href="#why-is-there-a-js_promise-http-bucklescriptgithubio-bucklescript-api-js_promisehtml-and-then-a-jspromise-http-bucklescriptgithubio-bucklescript-api-jspromisehtml-what-about-js_array-http-bucklescriptgithubio-bucklescript-api-js_arrayhtml-js_string-http-bucklescriptgithubio-bucklescript-api-js_stringhtml-and-whatever-else" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Why is there a <a href="http://bucklescript.github.io/bucklescript/api/Js_promise.html"><code>Js_promise</code></a> and then a <a href="http://bucklescript.github.io/bucklescript/api/Js.Promise.html"><code>Js.Promise</code></a>? What about <a href="http://bucklescript.github.io/bucklescript/api/Js_array.html"><code>Js_array</code></a>, <a href="http://bucklescript.github.io/bucklescript/api/Js_string.html"><code>Js_string</code></a> and whatever else?</h3>
<p>As a convention, <code>Js_foo</code> is the actual module, and <code>Js.Foo</code> is just an alias for it. They're <a href="https://github.com/bloomberg/bucklescript/blob/7bc37f387a726ba1ae4afeefe02b9c82577d9e10/jscomp/runtime/js.ml#L124-L138">equivalent</a>. Prefer <code>Js.Foo</code>, because that's the official, public module name.</p>
<h3><a class="anchor" aria-hidden="true" id="when-will-modular-implicit-multicore-algebraic-effects-be-ready"></a><a href="#when-will-modular-implicit-multicore-algebraic-effects-be-ready" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>When will modular implicit &amp; multicore &amp; algebraic effects be ready?</h3>
<p>They will one day. In the meantime, help us ship more Reason code! The popularity will help funnel more OCaml contributions. The less the OCaml folks need to worry about low-hanging fruits, the more they can focus on great research and execution!</p>
<h3><a class="anchor" aria-hidden="true" id="왜-bucklescript와-bsb가-이리-빠르죠-어떻게-하면-느려지죠"></a><a href="#왜-bucklescript와-bsb가-이리-빠르죠-어떻게-하면-느려지죠" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>왜 BuckleScript와 bsb가 이리 빠르죠? 어떻게 하면 느려지죠?</h3>
<p>BuckleScript is optimized for performance across the whole stack. You can try slowing it down by adding a dozen layers of indirections and metaprogramming. Try:</p>
<ul>
<li>여기저기에 끝나지 않는 반복문 넣기</li>
<li>Stuffing a JavaScript build tool in the pipeline.</li>
<li>hello world 만드는 데에 의존성 잔뜩 끌어오기.</li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="i-m-seeing-a-weird-cmi-cmx-cmj-cma-file-referenced-in-a-compiler-error-where-do-these-files-come-from-"></a><a href="#i-m-seeing-a-weird-cmi-cmx-cmj-cma-file-referenced-in-a-compiler-error-where-do-these-files-come-from-" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>I'm seeing a weird .cmi/.cmx/.cmj/.cma file referenced in a compiler error. Where do these files come from?</h3>
<p>The OCaml community frequently uses file extensions to distinguish between types of source, artifacts, and metadata, depending on your build target (native/bytecode/JavaScript). The following is a overview of some of the file extensions you may come across:</p>
<h4><a class="anchor" aria-hidden="true" id="소스-파일"></a><a href="#소스-파일" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>소스 파일</h4>
<ul>
<li><code>.ml</code>: OCaml 소스 파일</li>
<li><code>.mli</code>: OCaml interface file; determines which parts of the matching <code>.ml</code> file are visible to the outside world</li>
<li><code>.re</code>: Reason 소스 파일. <code>.ml</code>과 비슷하지만 Reason만을 위합니다</li>
<li><code>.rei</code>: Reason 인터페이스 파일. <code>.mli</code>와 비슷하지만, Reason만을 위합니다</li>
</ul>
<h4><a class="anchor" aria-hidden="true" id="컴파일된-파일"></a><a href="#컴파일된-파일" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>컴파일된 파일</h4>
<ul>
<li><code>.cmi</code>: 컴파일된 인터페이스 (.rei/mli) 파일</li>
<li><code>.cmx</code>: Compiled object file for native output (via ocamlopt)</li>
<li><code>.cmo</code>: Compiled object file for bytecode output</li>
<li><code>.cmj</code>: Compiled object file for web (via BuckleScript)</li>
<li><code>.cma</code>: Library file for bytecode output (equivalent to C's .a files)</li>
<li><code>.cmxa</code>: Library file for native output</li>
<li><code>.cmt</code>: Contains a &quot;Typedtree&quot; – basically the AST with all type info</li>
<li><code>.cmti</code>: .cmt 파일과 비슷하지만, 인터페이스 전용입니다</li>
<li><code>.cmxs</code>: Dynamically loaded plugin (for native compilation)</li>
<li><code>.o</code>: 컴파일된 네이티브 오브젝트 파일</li>
<li><code>.out</code>: Conventional name/extension for final output produced by ocamlc/ocamlopt (e.g. <code>ocamlc -o myExecutable.out</code>)</li>
</ul>
<h4><a class="anchor" aria-hidden="true" id="다른-ocaml-생태계의-파일"></a><a href="#다른-ocaml-생태계의-파일" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>다른 OCaml 생태계의 파일</h4>
<ul>
<li><code>.mll</code>: ocamllex lexical analyzer definition file</li>
<li><code>.mly</code>: ocamlyacc parser generator definition file</li>
<li><code>.mldylib</code>: Contains a list of module paths that will be compiled and archived together to build a corresponding <code>.cmxs</code> target (native plugin)</li>
<li><code>.mliv</code>: Batteries-specific files for some <a href="https://github.com/ocaml-batteries-team/batteries-included/blob/f019927b9503ec65ef816f02315de78d4bae3481/src/batArray.mliv">custom preprocessing</a>.</li>
<li><code>.mllib</code>: OCaml library (cma and cmxa)</li>
<li><code>.mlpack</code>: OCaml package (cmo built with the -pack flag)</li>
<li><code>.mlpp</code>: <a href="https://github.com/ygrek/ocaml-extlib">Extlib</a>-specific files for some custom preprocessing</li>
<li><code>.mltop</code>: <a href="https://shonkychef.wordpress.com/2009/07/28/making-an-ocaml-toplevel-with-ocamlbuild/">OCamlbuild top-level file</a>, used by OCamlbuild to generate a .top file</li>
<li><code>.odocl</code>: OCaml documentation file</li>
</ul>
<p>If some of those explanations are still a bit cryptic, here are expansions on some of the terms used above: - <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">AST</a>: Abstract Syntax Tree. The data structure coming from the source code, that the compiler operates on. - <a href="https://en.wikipedia.org/wiki/Linker_(computing)">Linking</a>: The step where the compiler takes many intermediate compiled files and assembles them together. E.g. linking A with B, because A's original source file referred to B. - Native: Builds that run on bare metal assembly instructions of the platform in question. - <a href="https://en.wikipedia.org/wiki/Bytecode">Bytecode</a>: Like native code, but more portable and less performant - <a href="https://en.wikipedia.org/wiki/Object_file">Object file</a>: Contains machine code that is not directly runnable.</p>
<p>There is more information and context for many of these file extensions <a href="https://ocaml.org/learn/tutorials/filenames.html">on the OCaml site</a> and in <a href="http://caml.inria.fr/pub/ml-archives/caml-list/2008/09/2bc9b38171177af5dc0d832a365d290d.en.html">this mailing list post</a>. There are also deeper dives on <a href="https://caml.inria.fr/pub/docs/manual-ocaml/native.html">native</a> and <a href="http://caml.inria.fr/pub/docs/manual-ocaml/comp.html">bytecode</a> compilation that contain more detailed descriptions in the OCaml manual.</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/ko/convert-from-ocaml"><span class="arrow-prev">← </span><span>OCaml에서 변환</span></a><a class="docs-next button" href="/docs/ko/comparison-to-ocaml"><span>OCaml과 비교</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"></nav></div><span><script src="/js/redirectBlog.js"></script><script src="/js/pjax-api.min.js"></script><script>window.foo = new Pjax({
          areas: [
            // try to use the first query.
            '.mainContainer, .docsNavContainer .toc .navWrapper, .onPageNav',
            // fallback
            'body'
          ],
          link: '.docsNavContainer:not(.docsSliderActive) a',
          update: {
            script: false,
          }
        });
        var languagesMenuItemCopy = document.getElementById("languages-menu");
        languagesMenuItemCopy.addEventListener("click", function(e){
          e.preventDefault();
          e.stopPropagation();
          e.stopImmediatePropagation();
        });</script></span></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                
                apiKey: '966d1e412f67114a07dc0afe44b19b53',
                indexName: 'reason',
                inputSelector: '#search_input_react',
                algoliaOptions: {"facetFilters":["lang:ko"]}
              });
            </script></body></html>