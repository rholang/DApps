<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Variant! · Reason</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="&lt;p&gt;보아라, Reason의 크라운 주얼 같은 데이터 구조를!&lt;/p&gt;
"/><meta name="docsearch:language" content="ko"/><meta property="og:title" content="Variant! · Reason"/><meta property="og:type" content="website"/><meta property="og:url" content="https://reasonml.github.io/"/><meta property="og:description" content="&lt;p&gt;보아라, Reason의 크라운 주얼 같은 데이터 구조를!&lt;/p&gt;
"/><meta name="twitter:card" content="summary"/><link rel="shortcut icon" href="/img/icon_50.png"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"/><link rel="alternate" type="application/atom+xml" href="https://reasonml.github.io/blog/atom.xml" title="Reason Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://reasonml.github.io/blog/feed.xml" title="Reason Blog RSS Feed"/><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/ko"><img class="logo" src="/img/dummy.svg" alt="Reason"/></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/docs/ko/what-and-why" target="_self">문서</a></li><li class=""><a href="/ko/try" target="_self">해보기</a></li><li class=""><a href="/api/index" target="_self">API</a></li><li class=""><a href="/docs/ko/community" target="_self">커뮤니티</a></li><li class=""><a href="/blog/" target="_self">블로그</a></li><span><li><a id="languages-menu" href="#"><img class="languages-icon" src="/img/language.svg" alt="Languages icon"/>한국어</a><div id="languages-dropdown" class="hide"><ul id="languages-dropdown-items"><li><a href="/docs/ja/variant">日本語</a></li><li><a href="/docs/en/variant">English</a></li><li><a href="/docs/de/variant">Deutsch</a></li><li><a href="/docs/es-ES/variant">Español</a></li><li><a href="/docs/fr/variant">Français</a></li><li><a href="/docs/pt-BR/variant">Português (Brasil)</a></li><li><a href="/docs/ru/variant">Русский</a></li><li><a href="/docs/uk/variant">Українська</a></li><li><a href="/docs/zh-CN/variant">中文</a></li><li><a href="/docs/zh-TW/variant">繁體中文</a></li><li><a href="https://crowdin.com/project/reason" target="_blank" rel="noreferrer noopener">번역 돕기</a></li></ul></div></li><script>
        const languagesMenuItem = document.getElementById("languages-menu");
        const languagesDropDown = document.getElementById("languages-dropdown");
        languagesMenuItem.addEventListener("click", function(event) {
          event.preventDefault();

          if (languagesDropDown.className == "hide") {
            languagesDropDown.className = "visible";
          } else {
            languagesDropDown.className = "hide";
          }
        });
      </script></span><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li><li class=""><a href="https://github.com/facebook/reason" target="_self">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><i></i></div><h2><i>›</i><span>언어 기본</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Intro</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/ko/what-and-why">What &amp; Why</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Setup</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/ko/installation">Installation</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/editor-plugins">에디터 플러그인</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/extra-goodies">추가적으로 매력적인 것들</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">언어 기본</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/ko/overview">개요</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/let-binding">Let 바인딩</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/type">타입!</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/string-and-char">문자열 &amp; 문자</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/boolean">부울</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/integer-and-float">정수 &amp; 실수</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/tuple">튜플</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/record">Record</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/docs/ko/variant">Variant!</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/null-undefined-option">Null, Undefined &amp; Option</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/list-and-array">리스트 &amp; 배열</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/function">함수</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/if-else">If-Else</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/pipe-first">Pipe First</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/more-on-type">More on Type</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/destructuring">비구조화</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/pattern-matching">패턴 매칭!</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/mutation">Mutation</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/imperative-loops">Imperative Loops</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/jsx">JSX</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/external">외부 접근</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/exception">예외</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/object">Object</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/module">모듈</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/promise">프라미스</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">JavaScript</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/ko/interop">연동</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/syntax-cheatsheet">문법 치트시트</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/libraries">라이브러리</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/converting-from-js">JS에서 변환</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Native</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/ko/native">Native</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/quickstart-ocaml">Native Quickstart</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/convert-from-ocaml">OCaml에서 변환</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Extra</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/ko/faq">자주 물어보는 질문</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/comparison-to-ocaml">OCaml과 비교</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/newcomer-examples">신입들을 위한 예시</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/project-structure">프로젝트 구조</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              const headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                if (event.target.tagName === 'A') {
                  document.body.classList.remove('tocActive');
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://crowdin.com/project/reason/ko" target="_blank" rel="noreferrer noopener">Translate</a><h1 class="postHeaderTitle">Variant!</h1></header><article><div><span><p>보아라, Reason의 크라운 주얼 같은 데이터 구조를!</p>
<p>대다수의 언어가 &quot;이것<strong>과</strong> 저것&quot;이라는 데이터 구조를 갖습니다. variant는 우리가 &quot;이것<strong>이나</strong> 저것&quot;을 나타내게 해줍니다.</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">type</span> myResponseVariant =
  | <span class="hljs-constructor">Yes</span>
  | <span class="hljs-constructor">No</span>
  | <span class="hljs-constructor">PrettyMuch</span>;

<span class="hljs-keyword">let</span> areYouCrushingIt = <span class="hljs-constructor">Yes</span>;
</code></pre>
<p><code>Yes</code>, <code>No</code>, 그리고 <code>PrettyMuch</code>는 문자열이 아닙니다, 참조 변수도, 특별한 데이터 타입이지도 않습니다. 그들은 &quot;생성자&quot; (혹은 &quot;태그&quot;) 라고 불립니다. 특수 문자 <code>|</code> 은 각 생성자를 분리합니다.</p>
<p><strong>주의</strong>: variant의 생성자는 대소문자를 구분합니다.</p>
<h2><a class="anchor" aria-hidden="true" id="사용"></a><a href="#사용" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>사용</h2>
<p>Along with a variant comes one of the most important features of Reason, the <code>switch</code> expression.</p>
<p>Reason의 <code>switch</code>는 다른 언어의 <code>switch</code> (<code>if/elseif/elseif</code>의 반복처럼) 와 비슷하게 보입니다. 그러나 switch는 variant에 명시된 가능한 모든 경우를 확인하는 기능을 갖고 있습니다. 이 기능을 사용하기 위해서는 variant의 생성자 중에서 사용하고 싶은 것을 적고, 그 뒤에 <code>=&gt;</code>를 적은 다음에 식을 적으면 됩니다.</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> message =
  <span class="hljs-keyword">switch</span> (areYouCrushingIt) {
  | <span class="hljs-constructor">No</span> =&gt; <span class="hljs-string">"No worries. Keep going!"</span>
  | <span class="hljs-constructor">Yes</span> =&gt; <span class="hljs-string">"Great!"</span>
  | <span class="hljs-constructor">PrettyMuch</span> =&gt; <span class="hljs-string">"Nice!"</span>
  };
<span class="hljs-comment">/* message 는 "Great!" 입니다 */</span>
</code></pre>
<p>A variant has an extremely rich amount of type system assistance. For example, we'll give you a type error if you've forgotten to cover a case of your variant, or if two cases are redundant. Be sure to check out switch and pattern-matching in a <a href="/docs/ko/pattern-matching">later section</a>!</p>
<h3><a class="anchor" aria-hidden="true" id="variant-needs-an-explicit-definition"></a><a href="#variant-needs-an-explicit-definition" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Variant Needs an Explicit Definition</h3>
<p>If the variant you're using is in a different file, bring it into scope like you'd do <a href="/docs/ko/record#record-needs-an-explicit-definition">for a record</a>:</p>
<pre><code class="hljs css language-reason"><span class="hljs-comment">/* Zoo.re */</span>

<span class="hljs-keyword">type</span> animal = <span class="hljs-constructor">Dog</span> | <span class="hljs-constructor">Cat</span> | <span class="hljs-constructor">Bird</span>;
</code></pre>
<pre><code class="hljs css language-reason"><span class="hljs-comment">/* example.re */</span>

<span class="hljs-keyword">let</span> pet: <span class="hljs-module-identifier">Zoo</span>.animal = <span class="hljs-constructor">Dog</span>; <span class="hljs-comment">/* preferred */</span>
<span class="hljs-comment">/* or */</span>
<span class="hljs-keyword">let</span> pet = <span class="hljs-module-identifier">Zoo</span>.<span class="hljs-constructor">Dog</span>;
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="생성자-인자"></a><a href="#생성자-인자" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>생성자 인자</h3>
<p>Variant의 생성자는 쉼표로 구분된 추가 데이터를 저장할 수 있습니다.</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">type</span> account =
  | <span class="hljs-constructor">None</span>
  | <span class="hljs-constructor">Instagram</span>(string)
  | <span class="hljs-constructor">Facebook</span>(string, int);
</code></pre>
<p>이렇게 하면 <code>Instagram</code> 은 <code>string</code>을 갖고, <code>Facebook</code>은 <code>string</code>과 <code>int</code>를 가집니다. 또 이는 다음과 같이 사용합니다:</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> myAccount = <span class="hljs-constructor">Facebook</span>(<span class="hljs-string">"Josh"</span>, <span class="hljs-number">26</span>);
<span class="hljs-keyword">let</span> friendAccount = <span class="hljs-constructor">Instagram</span>(<span class="hljs-string">"Jenny"</span>);
</code></pre>
<p><strong>Notice how using a constructor is like calling a function</strong>? It's as if <code>Facebook</code> was a function that accepts two arguments. This isn't a coincidence; there's a reason why a constructor's data is called &quot;constructor argument&quot;.</p>
<p>Using <code>switch</code>, you can pattern-match (again, described in a later section) a constructor's arguments:</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> greeting =
  <span class="hljs-keyword">switch</span> (myAccount) {
  | <span class="hljs-constructor">None</span> =&gt; <span class="hljs-string">"Hi!"</span>
  | <span class="hljs-constructor">Facebook</span>(name, age) =&gt; <span class="hljs-string">"Hi "</span> <span class="hljs-operator">++</span> name <span class="hljs-operator">++</span> <span class="hljs-string">", you're "</span> <span class="hljs-operator">++</span> string_of_int(age) <span class="hljs-operator">++</span> <span class="hljs-string">"-year-old."</span>
  | <span class="hljs-constructor">Instagram</span>(name) =&gt; <span class="hljs-string">"Hello "</span> <span class="hljs-operator">++</span> name <span class="hljs-operator">++</span> <span class="hljs-string">"!"</span>
  };
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="명예로운-언급"></a><a href="#명예로운-언급" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>명예로운 언급</h3>
<p><a href="/api/index.html">표준 라이브러리</a>는 많이 사용되는 두 개의 중요한 variant를 제공합니다.</p>
<h4><a class="anchor" aria-hidden="true" id="option"></a><a href="#option" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>option</code></h4>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">type</span> option('a) = <span class="hljs-constructor">None</span> | <span class="hljs-constructor">Some</span>('a);
</code></pre>
<p>이는 다른 언어에서 &quot;nullable&quot; (<code>undefined</code> 나 <code>null</code>이 값이 될 수 있는) 값을 사용하는 코드를 대체하기 위해 사용됩니다. 이 편리한 타입 정의 덕분에, Reason은 기본적으로 모든 값을 nullable하지 않게 할 수 있었습니다. <code>int</code>는 언제나 정수여야하고, &quot;<code>int</code><strong>거나</strong> <code>null</code><strong>이거나</strong> <code>undefined</code>&quot;여서는 안됩니다. 만약 당신이 &quot;nullable한 int&quot;를 나타내길 원한다면 당신은 <code>option(int)</code>를 사용할 수 있습니다. 이 타입이 나타내는 값은 <code>None</code> 혹은 <code>Some(int)</code>입니다. <code>switch</code>는 당신이 모든 경우를 처리하도록 강제합니다. 따라서 <strong>순수한 Reason 프로그램은 null 에러를 띄우지 않습니다</strong>.</p>
<h4><a class="anchor" aria-hidden="true" id="list"></a><a href="#list" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>list</code></h4>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">type</span> list('a) = <span class="hljs-constructor">Empty</span> | <span class="hljs-constructor">Head</span>('a, list('a));
</code></pre>
<p><em>Not the actual type definition. Just an illustration</em>.</p>
<p>This says: &quot;a list that holds a value of type <code>a</code> (whatever it is) is either empty, or holds that value plus another list&quot;.</p>
<p>Reason gave <code>list</code> a syntax sugar. <code>[1, 2, 3]</code> is conceptually equivalent to <code>Head(1, Head(2, Head(3, Empty)))</code>. Once again, <code>switch</code> forces you to handle every case of this variant, including <code>Empty</code> (aka <code>[]</code>). <strong>This eliminates another big category of access bugs</strong>.</p>
<h4><a class="anchor" aria-hidden="true" id="다른-variant-같은-타입들"></a><a href="#다른-variant-같은-타입들" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>다른 Variant 같은 타입들</h4>
<p>당신은 string, int, float, array, 그리고 대부분의 데이터 구조에 <code>switch</code>를 사용할 수 있다는 것을 알고 있었나요? 한번 직접 해보세요!</p>
<h2><a class="anchor" aria-hidden="true" id="팁-트릭"></a><a href="#팁-트릭" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>팁 &amp; 트릭</h2>
<p>2개의 인자를 가진 생성자와 하나의 튜플을 가진 생성자를 <strong>혼동하지 마세요</strong>:</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">type</span> account =
  | <span class="hljs-constructor">Facebook</span>(string, int) <span class="hljs-comment">/* 2개의 인자 */</span>;
<span class="hljs-keyword">type</span> account2 =
  | <span class="hljs-constructor">Instagram</span>((string, int)) <span class="hljs-comment">/* 1개의 인자 - 2개의 값을 가진 튜플 요구*/</span>;
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="variant는-무조건-생성자를-요구합니다"></a><a href="#variant는-무조건-생성자를-요구합니다" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Variant는 무조건 생성자를 요구합니다</h3>
<p>만약 당신이 타입이 없는 언어에서 왔다면 <code>type foo = int | string</code>을 시도했을지도 모릅니다. 이는 Reason에서 불가능합니다. 당신은 생성자에 각각 값을 넣어야합니다. 다음과 같이 말입니다: <code>type foo = Int(int) | String(string)</code> 일반적으로, 이는 안티 패턴이 될 수도 있습니다. 디자인 결정에서 더 자세한 설명을 확인해보세요.</p>
<h3><a class="anchor" aria-hidden="true" id="javascript와의-연동"></a><a href="#javascript와의-연동" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>JavaScript와의 연동</h3>
<p><em>이 섹션은 BuckleScript의 <a href="https://bucklescript.github.io/docs/en/interop-overview.html">FFI</a>에 대한 지식이 필요합니다. Skip this if you haven't felt the itch to use variants for wrapping JS functions yet</em>.</p>
<p>Quite a few JS libraries use functions that can accept many types of arguments. In these cases, it's very tempting to model them as variants. For example, suppose there's a <code>myLibrary.draw</code> JS function that takes in either a <code>number</code> or a <code>string</code>. You might be tempted to bind it like so:</p>
<pre><code class="hljs css language-reason"><span class="hljs-comment">/* reserved for internal usage */</span>
<span class="hljs-attribute">[@bs.module "myLibrary"]</span> <span class="hljs-keyword">external</span> draw : 'a =&gt; unit = <span class="hljs-string">"draw"</span>;

<span class="hljs-keyword">type</span> animal =
  | <span class="hljs-constructor">MyFloat</span>(float)
  | <span class="hljs-constructor">MyString</span>(string);

<span class="hljs-keyword">let</span> betterDraw = (animal) =&gt;
  <span class="hljs-keyword">switch</span> (animal) {
  | <span class="hljs-constructor">MyFloat</span>(f) =&gt; draw(f)
  | <span class="hljs-constructor">MyString</span>(s) =&gt; draw(s)
  };
</code></pre>
<p>You could definitely do that, but there are better ways! For example, simply two <code>external</code>s that both compile to the same JS call:</p>
<pre><code class="hljs css language-reason"><span class="hljs-attribute">[@bs.module "myLibrary"]</span> <span class="hljs-keyword">external</span> drawFloat : float =&gt; unit = <span class="hljs-string">"draw"</span>;
<span class="hljs-attribute">[@bs.module "myLibrary"]</span> <span class="hljs-keyword">external</span> drawString : string =&gt; unit = <span class="hljs-string">"draw"</span>;
</code></pre>
<p>BuckleScript also provides <a href="https://bucklescript.github.io/docs/en/function.html#modeling-polymorphic-function">a few other ways</a> to do this.</p>
<h3><a class="anchor" aria-hidden="true" id="variant-types-are-found-by-field-name"></a><a href="#variant-types-are-found-by-field-name" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Variant Types Are Found By Field Name</h3>
<p><a href="/docs/ko/record#record-types-are-found-by-field-name">레코드 섹션</a>을 참조하세요. Variants are the same: a function can't accept an arbitrary constructor shared by two different variants. Again, such feature exists, it's called a polymorphic variant. We'll talk about this in the future =).</p>
<h2><a class="anchor" aria-hidden="true" id="디자인-결정"></a><a href="#디자인-결정" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>디자인 결정</h2>
<p>Variants, in their many forms (polymorphic variant, open variant, GADT, etc.), are likely <em>the</em> feature of a type system such as Reason's. The aforementioned <code>option</code> variant, for example, obliterates the need for nullable types, a major source of bugs in other languages. Philosophically speaking, a problem is composed of many possible branches/conditions. Mishandling these conditions is the majority of what we call bugs. <strong>A type system doesn't magically eliminate bugs; it points out the unhandled conditions and asks you to cover them</strong>*. The ability to model &quot;this or that&quot; correctly is crucial.</p>
<p>For example, some folks wonder how the type system can safely eliminate badly formatted JSON data from propagating into their program. They don't, not by themselves! But if the parser returns the <code>option</code> type <code>None | Some(actualData)</code>, then you'd have to handle the <code>None</code> case explicitly in later call sites. That's all there is.</p>
<p>Performance-wise, a variant can potentially tremendously speed up your program's logic. Here's a piece of JavaScript:</p>
<pre><code class="hljs css language-js"><span class="hljs-keyword">let</span> data = <span class="hljs-string">'dog'</span>;
<span class="hljs-keyword">if</span> (data === <span class="hljs-string">'dog'</span>) {
  ...
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (data === <span class="hljs-string">'cat'</span>) {
  ...
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (data === <span class="hljs-string">'bird'</span>) {
  ...
}
</code></pre>
<p>There's a linear amount of branch checking here (<code>O(n)</code>). Compare this to using a Reason variant:</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">type</span> animal = <span class="hljs-constructor">Dog</span> | <span class="hljs-constructor">Cat</span> | <span class="hljs-constructor">Bird</span>;
<span class="hljs-keyword">let</span> data = <span class="hljs-constructor">Dog</span>;
<span class="hljs-keyword">switch</span> (data) {
| <span class="hljs-constructor">Dog</span> =&gt; <span class="hljs-operator">...</span>
| <span class="hljs-constructor">Cat</span> =&gt; <span class="hljs-operator">...</span>
| <span class="hljs-constructor">Bird</span> =&gt; <span class="hljs-operator">...</span>
}
</code></pre>
<p>컴파일러가 variant를 확인하면</p>
<ol>
<li>conceptually turns them into <code>type animal = 0 | 1 | 2</code></li>
<li>compiles <code>switch</code> to a constant-time format (<code>O(1)</code>).</li>
</ol>
<p>You might wonder why typed functional languages are used so often for parsing; switching on a large tree efficiently and safely is pretty much the best-case scenario for variants.</p>
<!-- TODO: playground link -->
<p>Mind blown yet? Variants have a deep connection to other fields of mathematics; <a href="https://codewords.recurse.com/issues/three/algebra-and-calculus-of-algebraic-data-types">See here</a> for an interesting exploration.</p>
<p>* It's always nicer to design away the problem rather than resorting to a type system to cover the pitfalls; In reality, it's unrealistic to do so for every problem, or even just to understand every problem fully in order to design a solution. A type system allows you to safely make a big category of changes to codebases without needing to understand the whole thing upfront. This is great for guided exploration. In this regard, types also allows us not needing to overly design an API just to circumvent callers' simple pitfalls. They reduce the layers of abstractions needed to &quot;get things done&quot;, which in return reduces callers' cognitive burden.</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/ko/record"><span class="arrow-prev">← </span><span>Record</span></a><a class="docs-next button" href="/docs/ko/null-undefined-option"><span>Null, Undefined &amp; Option</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#사용">사용</a><ul class="toc-headings"><li><a href="#variant-needs-an-explicit-definition">Variant Needs an Explicit Definition</a></li><li><a href="#생성자-인자">생성자 인자</a></li><li><a href="#명예로운-언급">명예로운 언급</a></li></ul></li><li><a href="#팁-트릭">팁 &amp; 트릭</a><ul class="toc-headings"><li><a href="#variant는-무조건-생성자를-요구합니다">Variant는 무조건 생성자를 요구합니다</a></li><li><a href="#javascript와의-연동">JavaScript와의 연동</a></li><li><a href="#variant-types-are-found-by-field-name">Variant Types Are Found By Field Name</a></li></ul></li><li><a href="#디자인-결정">디자인 결정</a></li></ul></nav></div><span><script src="/js/redirectBlog.js"></script><script src="/js/pjax-api.min.js"></script><script>window.foo = new Pjax({
          areas: [
            // try to use the first query.
            '.mainContainer, .docsNavContainer .toc .navWrapper, .onPageNav',
            // fallback
            'body'
          ],
          link: '.docsNavContainer:not(.docsSliderActive) a',
          update: {
            script: false,
          }
        });
        var languagesMenuItemCopy = document.getElementById("languages-menu");
        languagesMenuItemCopy.addEventListener("click", function(e){
          e.preventDefault();
          e.stopPropagation();
          e.stopImmediatePropagation();
        });</script></span></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                
                apiKey: '966d1e412f67114a07dc0afe44b19b53',
                indexName: 'reason',
                inputSelector: '#search_input_react',
                algoliaOptions: {"facetFilters":["lang:ko"]}
              });
            </script></body></html>