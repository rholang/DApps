<!DOCTYPE html><html lang="de"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Pattern Matching! · Reason</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="&lt;p&gt;&lt;em&gt;Stelle sicher, dass du zuerst über &lt;a href=&quot;/docs/de/variant&quot;&gt;Varianten&lt;/a&gt; liest&lt;/em&gt;.&lt;/p&gt;
"/><meta name="docsearch:language" content="de"/><meta property="og:title" content="Pattern Matching! · Reason"/><meta property="og:type" content="website"/><meta property="og:url" content="https://reasonml.github.io/"/><meta property="og:description" content="&lt;p&gt;&lt;em&gt;Stelle sicher, dass du zuerst über &lt;a href=&quot;/docs/de/variant&quot;&gt;Varianten&lt;/a&gt; liest&lt;/em&gt;.&lt;/p&gt;
"/><meta name="twitter:card" content="summary"/><link rel="shortcut icon" href="/img/icon_50.png"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"/><link rel="alternate" type="application/atom+xml" href="https://reasonml.github.io/blog/atom.xml" title="Reason Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://reasonml.github.io/blog/feed.xml" title="Reason Blog RSS Feed"/><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/de"><img class="logo" src="/img/dummy.svg" alt="Reason"/></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/docs/de/what-and-why" target="_self">Docs</a></li><li class=""><a href="/de/try" target="_self">Try</a></li><li class=""><a href="/api/index" target="_self">API</a></li><li class=""><a href="/docs/de/community" target="_self">Community</a></li><li class=""><a href="/blog/" target="_self">Blog</a></li><span><li><a id="languages-menu" href="#"><img class="languages-icon" src="/img/language.svg" alt="Languages icon"/>Deutsch</a><div id="languages-dropdown" class="hide"><ul id="languages-dropdown-items"><li><a href="/docs/ja/pattern-matching">日本語</a></li><li><a href="/docs/en/pattern-matching">English</a></li><li><a href="/docs/es-ES/pattern-matching">Español</a></li><li><a href="/docs/fr/pattern-matching">Français</a></li><li><a href="/docs/ko/pattern-matching">한국어</a></li><li><a href="/docs/pt-BR/pattern-matching">Português (Brasil)</a></li><li><a href="/docs/ru/pattern-matching">Русский</a></li><li><a href="/docs/uk/pattern-matching">Українська</a></li><li><a href="/docs/zh-CN/pattern-matching">中文</a></li><li><a href="/docs/zh-TW/pattern-matching">繁體中文</a></li><li><a href="https://crowdin.com/project/reason" target="_blank" rel="noreferrer noopener">Beim Übersetzen helfen</a></li></ul></div></li><script>
        const languagesMenuItem = document.getElementById("languages-menu");
        const languagesDropDown = document.getElementById("languages-dropdown");
        languagesMenuItem.addEventListener("click", function(event) {
          event.preventDefault();

          if (languagesDropDown.className == "hide") {
            languagesDropDown.className = "visible";
          } else {
            languagesDropDown.className = "hide";
          }
        });
      </script></span><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li><li class=""><a href="https://github.com/facebook/reason" target="_self">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><i></i></div><h2><i>›</i><span>Language Basics</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Intro</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/de/what-and-why">What &amp; Why</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Setup</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/de/installation">Installation</a></li><li class="navListItem"><a class="navItem" href="/docs/de/editor-plugins">Editor Plugins</a></li><li class="navListItem"><a class="navItem" href="/docs/de/extra-goodies">Extra Goodies</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Language Basics</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/de/overview">Overview</a></li><li class="navListItem"><a class="navItem" href="/docs/de/let-binding">Let Binding</a></li><li class="navListItem"><a class="navItem" href="/docs/de/type">Type!</a></li><li class="navListItem"><a class="navItem" href="/docs/de/string-and-char">String &amp; Char</a></li><li class="navListItem"><a class="navItem" href="/docs/de/boolean">Boolean</a></li><li class="navListItem"><a class="navItem" href="/docs/de/integer-and-float">Integer &amp; Float</a></li><li class="navListItem"><a class="navItem" href="/docs/de/tuple">Tuple</a></li><li class="navListItem"><a class="navItem" href="/docs/de/record">Record</a></li><li class="navListItem"><a class="navItem" href="/docs/de/variant">Variant!</a></li><li class="navListItem"><a class="navItem" href="/docs/de/null-undefined-option">Null, Undefined &amp; Option</a></li><li class="navListItem"><a class="navItem" href="/docs/de/list-and-array">List &amp; Array</a></li><li class="navListItem"><a class="navItem" href="/docs/de/function">Function</a></li><li class="navListItem"><a class="navItem" href="/docs/de/if-else">If-Else</a></li><li class="navListItem"><a class="navItem" href="/docs/de/pipe-first">Pipe First</a></li><li class="navListItem"><a class="navItem" href="/docs/de/more-on-type">More on Type</a></li><li class="navListItem"><a class="navItem" href="/docs/de/destructuring">Destructuring</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/docs/de/pattern-matching">Pattern Matching!</a></li><li class="navListItem"><a class="navItem" href="/docs/de/mutation">Mutation</a></li><li class="navListItem"><a class="navItem" href="/docs/de/imperative-loops">Imperative Loops</a></li><li class="navListItem"><a class="navItem" href="/docs/de/jsx">JSX</a></li><li class="navListItem"><a class="navItem" href="/docs/de/external">External</a></li><li class="navListItem"><a class="navItem" href="/docs/de/exception">Exception</a></li><li class="navListItem"><a class="navItem" href="/docs/de/object">Object</a></li><li class="navListItem"><a class="navItem" href="/docs/de/module">Module</a></li><li class="navListItem"><a class="navItem" href="/docs/de/promise">Promise</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">JavaScript</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/de/interop">Interop</a></li><li class="navListItem"><a class="navItem" href="/docs/de/syntax-cheatsheet">Syntax Cheatsheet</a></li><li class="navListItem"><a class="navItem" href="/docs/de/libraries">Libraries</a></li><li class="navListItem"><a class="navItem" href="/docs/de/converting-from-js">Converting from JS</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Native</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/de/native">Native</a></li><li class="navListItem"><a class="navItem" href="/docs/de/quickstart-ocaml">Native Quickstart</a></li><li class="navListItem"><a class="navItem" href="/docs/de/convert-from-ocaml">Converting from OCaml</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Extra</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/de/faq">Frequently Asked Questions</a></li><li class="navListItem"><a class="navItem" href="/docs/de/comparison-to-ocaml">Comparison to OCaml</a></li><li class="navListItem"><a class="navItem" href="/docs/de/newcomer-examples">Newcomer Examples</a></li><li class="navListItem"><a class="navItem" href="/docs/de/project-structure">Project Structure</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              const headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                if (event.target.tagName === 'A') {
                  document.body.classList.remove('tocActive');
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://crowdin.com/project/reason/de" target="_blank" rel="noreferrer noopener">Translate</a><h1 class="postHeaderTitle">Pattern Matching!</h1></header><article><div><span><p><em>Stelle sicher, dass du zuerst über <a href="/docs/de/variant">Varianten</a> liest</em>.</p>
<p><strong>Wir sind endlich hier</strong>! Pattern-Matching ist eins <em>der</em> besten Features der Sprache. Es ist wie Destrukturierung, bringt aber noch mehr Hilfe des Typsystems mit sich.</p>
<h2><a class="anchor" aria-hidden="true" id="verwendung"></a><a href="#verwendung" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Verwendung</h2>
<p>Betrachte eine Variante:</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">type</span> payload =
  | <span class="hljs-constructor">BadResult</span>(int)
  | <span class="hljs-constructor">GoodResult</span>(string)
  | <span class="hljs-constructor">NoResult</span>;
</code></pre>
<p>Durch Anwendung des <code>switch</code>-Ausrucks kannst du sie „destrukturieren“:</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> data = <span class="hljs-constructor">GoodResult</span>(<span class="hljs-string">"Product shipped!"</span>);

<span class="hljs-keyword">let</span> message =
  <span class="hljs-keyword">switch</span> (data) {
  | <span class="hljs-constructor">GoodResult</span>(theMessage) =&gt; <span class="hljs-string">"Success! "</span> <span class="hljs-operator">++</span> theMessage
  | <span class="hljs-constructor">BadResult</span>(errorCode) =&gt; <span class="hljs-string">"Something's wrong. The error code is: "</span> <span class="hljs-operator">++</span> string_of_int(errorCode)
  };
</code></pre>
<p>Beachte wie wir <code>data</code> während der Behandlung jedes unterschiedlichen Falles destrukturiert haben. Obiges <code>switch</code> wird dir eine Compiler-Warnung geben:</p>
<pre><code class="hljs">Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
NoResult
</code></pre>
<p>Ist dies nicht großartig? Beim Abgleich der Form deiner warnt dich das Typsystem über einen nicht behandelten Fall. Dieser <strong>Bedingungs</strong>-Aspekt ist das, wodurch Pattern-Matching statt findet und nicht nur Destrukturierung. Die meisten Datenstrukturen mit einem „<strong>wenn dies, dann das</strong>“-Aspekt funktionieren damit:</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">switch</span> (myList) {
| <span class="hljs-literal">[</span><span class="hljs-literal">]</span> =&gt; print_endline(<span class="hljs-string">"Empty list"</span>)
| <span class="hljs-literal">[</span>a, <span class="hljs-operator">...</span>theRest<span class="hljs-literal">]</span> =&gt; print_endline(<span class="hljs-string">"list with the head value "</span> <span class="hljs-operator">++</span> a)
};

<span class="hljs-keyword">switch</span> (myArray) {
| <span class="hljs-literal">[|</span><span class="hljs-number">1</span>, <span class="hljs-number">2</span><span class="hljs-literal">|]</span> =&gt; print_endline(<span class="hljs-string">"This is an array with item 1 and 2"</span>)
| <span class="hljs-literal">[|</span><span class="hljs-literal">|]</span> =&gt; print_endline(<span class="hljs-string">"This array has no element"</span>)
| _ =&gt; print_endline(<span class="hljs-string">"This is an array"</span>)
};
</code></pre>
<p>Der <code>_</code>-Fall ist ein Spezialfall, der es erlaubt, alle unbehandelten Bedingungen zu diesem Zweig zu leiten.</p>
<p>Du kannst switch sogar mit string, int und anderen verwenden. Du kannst sogar viele Patterns zum gleichen Ergebnis führen!</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> reply =
  <span class="hljs-keyword">switch</span> (message) {
  | <span class="hljs-string">"Reason's pretty cool"</span> =&gt; <span class="hljs-string">"Yep"</span>
  | <span class="hljs-string">"good night"</span> =&gt; <span class="hljs-string">"See ya!"</span>
  | <span class="hljs-string">"hello"</span> | <span class="hljs-string">"hi"</span> | <span class="hljs-string">"heya"</span> | <span class="hljs-string">"hey"</span> =&gt; <span class="hljs-string">"hello to you too!"</span>
  | _ =&gt; <span class="hljs-string">"Nice to meet you!"</span>
  };
</code></pre>
<p>Kombiniert mit anderen Datenstrukturen kann Pattern-Matching extrem prägnanten, compiler-verifizierten, performanten Code erzeugen:</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> message =
  <span class="hljs-keyword">switch</span> (data) {
  | <span class="hljs-constructor">GoodResult</span>(theMessage) =&gt; <span class="hljs-string">"Success! "</span> <span class="hljs-operator">++</span> theMessage
  | <span class="hljs-constructor">BadResult</span>(<span class="hljs-number">0</span> | <span class="hljs-number">1</span> | <span class="hljs-number">5</span>) =&gt; <span class="hljs-string">"Something's wrong. It's a server side problem."</span>
  | <span class="hljs-constructor">BadResult</span>(errorCode) =&gt; <span class="hljs-string">"Unknown error occurred. Code: "</span> <span class="hljs-operator">++</span> string_of_int(errorCode)
  | <span class="hljs-constructor">NoResult</span> =&gt; <span class="hljs-string">"Things look fine"</span>
  };
</code></pre>
<p><strong>Bemerkung</strong>: du kannst nur Literale (d. h. konkrete Werte) an Patterns übergeben und nicht Namen von let-Bindungen oder andere Dinge. Folgendes funktioniert nicht wie erwartet:</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> myMessage = <span class="hljs-string">"Hello"</span>;
<span class="hljs-keyword">switch</span> (greeting) {
| myMessage =&gt; print_endline(<span class="hljs-string">"Hi to you"</span>)
};
</code></pre>
<p>Stattdessen würde hier angenommen, dass du in dem <code>switch</code>-Fall mit einem beliebigen String abgleichst und ihn an den Namen <code>myMessage</code> bindest, was nicht das ist, was du wolltest.</p>
<h3><a class="anchor" aria-hidden="true" id="when-klauseln"></a><a href="#when-klauseln" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>When-Klauseln</h3>
<p>Wenn du wirklich beliebige Logik mit einer ansonsten sauberen Pattern-Matching-Anwendung verwenden musst, kannst du einige <code>when</code>-Klauseln unterschieben, die im Prinzip syntaktischen Zucker für <code>if</code> darstellen:</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> message =
  <span class="hljs-keyword">switch</span> (data) {
  | <span class="hljs-constructor">GoodResult</span>(theMessage) =&gt; <span class="hljs-operator">...</span>
  | <span class="hljs-constructor">BadResult</span>(errorCode) when isServerError(errorCode) =&gt; <span class="hljs-operator">...</span>
  | <span class="hljs-constructor">BadResult</span>(errorCode) =&gt; <span class="hljs-operator">...</span> <span class="hljs-comment">/* otherwise */</span>
  | <span class="hljs-constructor">NoResult</span> =&gt; <span class="hljs-operator">...</span>
  };
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="pattern-matching-mit-exceptions"></a><a href="#pattern-matching-mit-exceptions" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Pattern-Matching mit Exceptions</h3>
<p>Wenn die Funktion eine Exception auslöst (wird später behandelt), kannst du auch <em>das</em> mit Pattern-Matching behandeln, zusätzlich zu den normalerweise zurückgelieferten Werten der Funktion.</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">switch</span> (<span class="hljs-module-identifier">List</span>.find((i) =&gt; i <span class="hljs-operator">===</span> theItem, myItems)) {
| item =&gt; print_endline(item)
| <span class="hljs-keyword">exception</span> <span class="hljs-constructor">Not_found</span> =&gt; print_endline(<span class="hljs-string">"No such item found!"</span>)
};
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="verschachteltes-pattern-matching"></a><a href="#verschachteltes-pattern-matching" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Verschachteltes Pattern-Matching</h3>
<p>Verschachtelte <code>|</code> funktionieren wie vorgesehen:</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">switch</span> (student) {
| {name: <span class="hljs-string">"Jane"</span> | <span class="hljs-string">"Joe"</span>} =&gt; <span class="hljs-operator">...</span>
| {name: <span class="hljs-string">"Bob"</span>, <span class="hljs-constructor">Job</span>: <span class="hljs-constructor">Programmer</span>({fullTime: <span class="hljs-constructor">Yes</span> | <span class="hljs-constructor">Maybe</span>})} =&gt; <span class="hljs-operator">...</span>
};
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="pattern-matching-uberall"></a><a href="#pattern-matching-uberall" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Pattern-Matching überall</h3>
<p>Du kannst Pattern-Matching überall dort anwenden, wo du eine gewöhnliche „Variablendeklaration“ einsetzen würdest:</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">type</span> leftOrRight =
  | <span class="hljs-constructor">Left</span>(int)
  | <span class="hljs-constructor">Right</span>(int);

<span class="hljs-keyword">let</span> i = <span class="hljs-constructor">Left</span>(<span class="hljs-number">1</span>);

<span class="hljs-comment">/* magic! */</span>
<span class="hljs-keyword">let</span> <span class="hljs-constructor">Left</span>(v) | <span class="hljs-constructor">Right</span>(v) = i;
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="tips-tricks"></a><a href="#tips-tricks" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Tips &amp; Tricks</h2>
<p><strong>Verwende flaches Pattern-Matching wann immer du kannst</strong>. Dies ist ein echter Bug-Entferner. Beispiel unten.</p>
<p>Missbrauche den Spezialfall <code>_</code> nicht zu sehr. Dies verhindert, dass der Compiler dir mitteilt, dass du vergessen hast, einen Fall abzudecken (Vollständigkeitsprüfung), was besonders nach einem Refactoring hilfreich wäre, bei dem du einer Variante einen neuen Fall hinzufügst. Versuche <code>_</code> nur zur Vermeidung unendlich vieler Möglichkeiten zu verwenden, z. B. string, int, usw.</p>
<p>Hier ist eine Reihe von Beispielen, vom schlechtesten zum besten:</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> optionBoolToBool = opt =&gt;
  <span class="hljs-keyword">if</span> (opt <span class="hljs-operator">==</span> <span class="hljs-constructor">None</span>) {
    <span class="hljs-literal">false</span>;
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (opt <span class="hljs-operator">==</span> <span class="hljs-constructor">Some</span>(<span class="hljs-literal">true</span>)) {
    <span class="hljs-literal">true</span>;
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-literal">false</span>;
  };
</code></pre>
<p>Also das ist nur dämlich =). Lass uns dies in Pattern-Matching umwandeln:</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> optionBoolToBool = opt =&gt;
  <span class="hljs-keyword">switch</span> (opt) {
  | <span class="hljs-constructor">None</span> =&gt; <span class="hljs-literal">false</span>
  | <span class="hljs-constructor">Some</span>(a) =&gt; a ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>
  };
</code></pre>
<p>Etwas besser aber immer noch verschachtelt. Pattern-Matching erlaubt dir dies zu tun:</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> optionBoolToBool = opt =&gt;
  <span class="hljs-keyword">switch</span> (opt) {
  | <span class="hljs-constructor">None</span> =&gt; <span class="hljs-literal">false</span>
  | <span class="hljs-constructor">Some</span>(<span class="hljs-literal">true</span>) =&gt; <span class="hljs-literal">true</span>
  | <span class="hljs-constructor">Some</span>(<span class="hljs-literal">false</span>) =&gt; <span class="hljs-literal">false</span>
  };
</code></pre>
<p>Sieht viel geradliniger aus! Nun könntest versucht sein, dies zu tun:</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> optionBoolToBool = opt =&gt;
  <span class="hljs-keyword">switch</span> (opt) {
  | <span class="hljs-constructor">Some</span>(<span class="hljs-literal">true</span>) =&gt; <span class="hljs-literal">true</span>
  | _ =&gt; <span class="hljs-literal">false</span>
  };
</code></pre>
<p>Which is much more concise, but kills the exhaustiveness check mentioned above; refrain from using that. This is the best:</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> optionBoolToBool = opt =&gt;
  <span class="hljs-keyword">switch</span> (opt) {
  | <span class="hljs-constructor">Some</span>(trueOrFalse) =&gt; trueOrFalse
  | <span class="hljs-constructor">None</span> =&gt; <span class="hljs-literal">false</span>
  };
</code></pre>
<p>Es ist ganz schön schwierig an diesem Punkt im Code einen Fehler zu begehen! Wenn du ein if-else mit vielen Zweigen verwenden möchtest, bevorzuge stattdessen die Pattern-Matching. Es ist prägnanter und auch <a href="/docs/de/variant#design-decisions">performant</a>.</p>
<p>Ein weiteres Beispiel mit switch + tuple findest du <a href="/docs/de/tuple#tips-tricks">hier</a>.</p>
<h2><a class="anchor" aria-hidden="true" id="designentscheidungen"></a><a href="#designentscheidungen" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Designentscheidungen</h2>
<p>Das berüchtigte <a href="https://en.wikipedia.org/wiki/Fizz_buzz#Programming_interviews">Fizzbuzz-Problem</a> stellt merkwürdigerweise einigen Leuten ein Bein, zum Teil wegen seiner Art, den Programmierer zu lähmen, der hofft, die wenigen Bedingungszweige auf der Suche nach Eleganz zu vereinfachen / zu vereinigen, wo es keine gibt. Hoffentlich kannst du sehen, dass die visuelle Prägnanz des Pattern-Matchings uns üblicherweise <a href="/try.html?reason=PQKgBAQghgzgpgEzAewHZgBYBcsAcYBcwwATsvDlAMbIJwB0yJA5sAO4CWA1h8AGIcAXoIgBXYQGIA8gGEoAWwA2YEMABQiuFjAAzIYIBG4wWAC8YABQcAlGYB8asGBicsVDJY5h5tMAGYAGjAvHyQAVlsAb0cwAB9LAAYghNtTOzAAIgFhMWEMmPiLJLAAfVT0rP18p0KS5PLM3MFquNL7ZywSDlRmEuQdEu6sK2sYgF8AbjU1HSZPYPQARjAsZDBFhJSwaKcAKRh6RWRmCz1hI2ER0cmgA">erlaubt Entwurfslähmung zu überwinden</a> und dabei alle Vorteile (und mehr wie du gesehen hast) eines Haufens gewaltsamer <code>if-else</code>s beibehält. Es ist wirklich nichts falsch daran, alle Möglichkeiten explizit aufzulisten. Pattern-Matching entspricht <strong>vollständiger Fallunterscheidung</strong> in der Mathematik, eine stichhaltige Problemlösungstechnik, die sich als extrem bequem erweist.</p>
<p>Ein Reason-<code>switch</code> zum ersten Mal zu verwenden könnte dich spüren lassen, was du alle diese Jahre verpasst hast. Sei vorsichtig, denn es könnte andere Sprachen für dich ruinieren =).</p>
<p>Wenn du versucht hast, ein Refactoring mit einer großen, verschachtelten if-else-Logik durchzuführen, dann könntest du erkennen, dass es sehr schwierig ist, die korrekte Logik zu finden. Auf der anderen Seite entsprechen Pattern-Matching und Tupel konzeptuell einer zweidimensionalen Tabelle, in der jede Zelle unabhängig befüllt werden kann. Auf diese Weise wird sichergestellt, dass du immer, wenn du dem <code>switch</code> einen Fall hinzufügen musst, du nur auf genau diese Tabellenzelle zuzugreifen brauchst, ohne andere Zellen zu vermasseln.</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">type</span> animal = <span class="hljs-constructor">Dog</span> | <span class="hljs-constructor">Cat</span> | <span class="hljs-constructor">Bird</span>;
<span class="hljs-keyword">let</span> result = <span class="hljs-keyword">switch</span> (isBig, myAnimal) {
| (<span class="hljs-literal">true</span>, <span class="hljs-constructor">Dog</span>) =&gt; <span class="hljs-number">1</span>
| (<span class="hljs-literal">true</span>, <span class="hljs-constructor">Cat</span>) =&gt; <span class="hljs-number">2</span>
| (<span class="hljs-literal">true</span>, <span class="hljs-constructor">Bird</span>) =&gt; <span class="hljs-number">3</span>
| (<span class="hljs-literal">false</span>, <span class="hljs-constructor">Dog</span> | <span class="hljs-constructor">Cat</span>) =&gt; <span class="hljs-number">4</span>
| (<span class="hljs-literal">false</span>, <span class="hljs-constructor">Bird</span>) =&gt; <span class="hljs-number">5</span>
};
</code></pre>
<table>
<thead>
<tr><th>isBig \ myAnimal</th><th>Dog</th><th>Cat</th><th>Bird</th></tr>
</thead>
<tbody>
<tr><td>true</td><td>1</td><td>2</td><td>3</td></tr>
<tr><td>false</td><td>4</td><td>4</td><td>5</td></tr>
</tbody>
</table>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/de/destructuring"><span class="arrow-prev">← </span><span>Destructuring</span></a><a class="docs-next button" href="/docs/de/mutation"><span>Mutation</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#verwendung">Verwendung</a><ul class="toc-headings"><li><a href="#when-klauseln">When-Klauseln</a></li><li><a href="#pattern-matching-mit-exceptions">Pattern-Matching mit Exceptions</a></li><li><a href="#verschachteltes-pattern-matching">Verschachteltes Pattern-Matching</a></li><li><a href="#pattern-matching-uberall">Pattern-Matching überall</a></li></ul></li><li><a href="#tips-tricks">Tips &amp; Tricks</a></li><li><a href="#designentscheidungen">Designentscheidungen</a></li></ul></nav></div><span><script src="/js/redirectBlog.js"></script><script src="/js/pjax-api.min.js"></script><script>window.foo = new Pjax({
          areas: [
            // try to use the first query.
            '.mainContainer, .docsNavContainer .toc .navWrapper, .onPageNav',
            // fallback
            'body'
          ],
          link: '.docsNavContainer:not(.docsSliderActive) a',
          update: {
            script: false,
          }
        });
        var languagesMenuItemCopy = document.getElementById("languages-menu");
        languagesMenuItemCopy.addEventListener("click", function(e){
          e.preventDefault();
          e.stopPropagation();
          e.stopImmediatePropagation();
        });</script></span></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                
                apiKey: '966d1e412f67114a07dc0afe44b19b53',
                indexName: 'reason',
                inputSelector: '#search_input_react',
                algoliaOptions: {"facetFilters":["lang:de"]}
              });
            </script></body></html>