<!DOCTYPE html><html lang="fr"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Comparaison avec OCaml · Reason</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="&lt;p&gt;Si vous venez d&#x27;OCaml ou si vous êtes un néophyte lisant un tutoriel écrit sur OCaml, ce guide est pour vous ! Mais n&#x27;oubliez pas que &lt;a href=&quot;https://github.com/reasonml/reason-tools&quot;&gt;reason-tools&lt;/a&gt; peut convertir la syntaxe OCaml et Reason à la volée.&lt;/p&gt;
"/><meta name="docsearch:language" content="fr"/><meta property="og:title" content="Comparaison avec OCaml · Reason"/><meta property="og:type" content="website"/><meta property="og:url" content="https://reasonml.github.io/"/><meta property="og:description" content="&lt;p&gt;Si vous venez d&#x27;OCaml ou si vous êtes un néophyte lisant un tutoriel écrit sur OCaml, ce guide est pour vous ! Mais n&#x27;oubliez pas que &lt;a href=&quot;https://github.com/reasonml/reason-tools&quot;&gt;reason-tools&lt;/a&gt; peut convertir la syntaxe OCaml et Reason à la volée.&lt;/p&gt;
"/><meta name="twitter:card" content="summary"/><link rel="shortcut icon" href="/img/icon_50.png"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"/><link rel="alternate" type="application/atom+xml" href="https://reasonml.github.io/blog/atom.xml" title="Reason Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://reasonml.github.io/blog/feed.xml" title="Reason Blog RSS Feed"/><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/fr"><img class="logo" src="/img/dummy.svg" alt="Reason"/></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/docs/fr/what-and-why" target="_self">Documentation</a></li><li class=""><a href="/fr/try" target="_self">Essayer</a></li><li class=""><a href="/api/index" target="_self">API</a></li><li class=""><a href="/docs/fr/community" target="_self">Communauté</a></li><li class=""><a href="/blog/" target="_self">Blog</a></li><span><li><a id="languages-menu" href="#"><img class="languages-icon" src="/img/language.svg" alt="Languages icon"/>Français</a><div id="languages-dropdown" class="hide"><ul id="languages-dropdown-items"><li><a href="/docs/ja/comparison-to-ocaml">日本語</a></li><li><a href="/docs/en/comparison-to-ocaml">English</a></li><li><a href="/docs/de/comparison-to-ocaml">Deutsch</a></li><li><a href="/docs/es-ES/comparison-to-ocaml">Español</a></li><li><a href="/docs/ko/comparison-to-ocaml">한국어</a></li><li><a href="/docs/pt-BR/comparison-to-ocaml">Português (Brasil)</a></li><li><a href="/docs/ru/comparison-to-ocaml">Русский</a></li><li><a href="/docs/uk/comparison-to-ocaml">Українська</a></li><li><a href="/docs/zh-CN/comparison-to-ocaml">中文</a></li><li><a href="/docs/zh-TW/comparison-to-ocaml">繁體中文</a></li><li><a href="https://crowdin.com/project/reason" target="_blank" rel="noreferrer noopener">Aider à la traduction</a></li></ul></div></li><script>
        const languagesMenuItem = document.getElementById("languages-menu");
        const languagesDropDown = document.getElementById("languages-dropdown");
        languagesMenuItem.addEventListener("click", function(event) {
          event.preventDefault();

          if (languagesDropDown.className == "hide") {
            languagesDropDown.className = "visible";
          } else {
            languagesDropDown.className = "hide";
          }
        });
      </script></span><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li><li class=""><a href="https://github.com/facebook/reason" target="_self">Github</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><i></i></div><h2><i>›</i><span>Extra</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Intro</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/fr/what-and-why">Quoi &amp; Pourquoi</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Installation</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/fr/installation">Installation</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/editor-plugins">Plugins éditeurs</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/extra-goodies">Goodies supplémentaires</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Principes de base du langage</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/fr/overview">Aperçu</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/let-binding">Let binding</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/type">Type !</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/string-and-char">String &amp; Char</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/boolean">Booléen</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/integer-and-float">Entier &amp; Flottant</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/tuple">Tuple</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/record">Record</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/variant">Variant!</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/null-undefined-option">Null, Undefined &amp; Option</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/list-and-array">Listes &amp; Tableaux</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/function">Fonction</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/if-else">If-Else</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/pipe-first">Pipe First</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/more-on-type">Plus sur les types</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/destructuring">Destructuring</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/pattern-matching">Pattern Matching!</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/mutation">Mutation</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/imperative-loops">Boucles impératives</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/jsx">JSX</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/external">External</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/exception">Exception</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/object">Objet</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/module">Module</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/promise">Promesse</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">JavaScript</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/fr/interop">Interopérabilité</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/syntax-cheatsheet">Cheatsheet de la syntaxe</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/libraries">Bibliothèques</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/converting-from-js">Convertir depuis JavaScript</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Natif</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/fr/native">Natif</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/quickstart-ocaml">Démarrage rapide en natif</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/convert-from-ocaml">Convertir depuis OCaml</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Extra</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/fr/faq">Foire aux Questions</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/docs/fr/comparison-to-ocaml">Comparaison avec OCaml</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/newcomer-examples">Exemple pour Débutants</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/project-structure">Structure de projet</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              const headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                if (event.target.tagName === 'A') {
                  document.body.classList.remove('tocActive');
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://crowdin.com/project/reason/fr" target="_blank" rel="noreferrer noopener">Translate</a><h1 class="postHeaderTitle">Comparaison avec OCaml</h1></header><article><div><span><p>Si vous venez d'OCaml ou si vous êtes un néophyte lisant un tutoriel écrit sur OCaml, ce guide est pour vous ! Mais n'oubliez pas que <a href="https://github.com/reasonml/reason-tools">reason-tools</a> peut convertir la syntaxe OCaml et Reason à la volée.</p>
<h2><a class="anchor" aria-hidden="true" id="commentaires"></a><a href="#commentaires" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Commentaires</h2>
<table>
<thead>
<tr><th>OCaml</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td><code>(* OCaml (*nest*) *)</code></td><td><code>/* Reason /*nest*/ */</code></td></tr>
</tbody>
</table>
<h2><a class="anchor" aria-hidden="true" id="renommage-d-operateur"></a><a href="#renommage-d-operateur" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Renommage d'opérateur</h2>
<p>Raison supporte tous les opérateurs infixes d'OCaml, mais quelques opérateurs sont exprimés différemment. Dans Reason, l'égalité structurelle est exprimée avec <code>==</code>, et l'égalité de référence (physique) est exprimée avec <code>===</code>. En Reason, pour obtenir l'inégalité correspondante, il suffit d'échanger le premier caractère avec un caractère <code>!</code> (<code>!=</code> pour l'inégalité structurelle, et <code>!==</code> pour l'inégalité de référence).</p>
<table>
<thead>
<tr><th>Égalité</th><th>OCaml</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td>Structurelle</td><td><code>x = y</code></td><td><code>x == y</code></td></tr>
<tr><td>Référence</td><td><code>x == y</code></td><td><code>x === y</code></td></tr>
</tbody>
</table>
<table>
<thead>
<tr><th>Inégalité</th><th>OCaml</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td>Structurelle</td><td><code>x &lt;&gt; y</code></td><td><code>x != y</code></td></tr>
<tr><td>Référence</td><td><code>x != y</code></td><td><code>x !== y</code></td></tr>
</tbody>
</table>
<h2><a class="anchor" aria-hidden="true" id="scope-local"></a><a href="#scope-local" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Scope local</h2>
<p>Le scoping lexical de Reason est exactement le même que celui d'OCaml, mais les bindings let ressemblent syntaxiquement au &quot;block scope&quot; qui est plus familier à de nombreux développeurs. En Reason, ils sont créés avec des accolades <code>{}</code>, qui peuvent contenir à la fois des bindings <code>let</code> et des commandes impératives, séparées par <code>;</code>. Tous les blocs évaluent à la dernière ligne, où le point-virgule est facultatif. Les accolades <code>{}</code> ne sont nécessaires que si vous avez plus d'un élément à chaîner via <code>;</code>.</p>
<table>
  <tr>
    <th>
      OCaml
    </th>
<pre><code class="hljs">&lt;th&gt;
  Reason
&lt;/th&gt;
</code></pre>
  </tr>
  <tr>
    <td>
      <pre><code class="hljs">let _ =
  let msg = "Hello" in
  print_string msg;
  let msg2 = "Goodbye" in
  print_string msg2</code></pre>
    </td>
<pre><code class="hljs">&lt;td&gt;
  &lt;pre&gt;&lt;code&gt;{
</code></pre>
<p>let msg = &quot;Hello&quot;;
print_string(msg);
let msg2 = &quot;Goodbye&quot;;
print_string(msg2)
};</code></pre>
</td></p>
  </tr>
</table>
<p>La syntaxe <code>{}</code> en Reason supprime plusieurs points de friction communément signalés dans la syntaxe d'OCaml :</p>
<ul>
<li>Les doubles point-virgules sont complètement retirés.</li>
<li><code>begin</code>/<code>end</code> est complètement retiré.</li>
<li>Les fameux <a href="https://github.com/ocaml/ocaml/pull/278">problèmes</a> de parsing impératif ont disparu.</li>
<li>Le corps et le scope local des modules sont unifiés.</li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="scope-local-vs-corps-de-module"></a><a href="#scope-local-vs-corps-de-module" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Scope local vs Corps de module</h2>
<p>En Reason, tout ce qui peut être écrit entre les <code>{}</code> peut être dans le <a href="#local-scope">scope local</a> ou les corps de module. Vous pouvez même généralement copier/coller votre code entre ces deux contextes. En OCaml, les syntaxes pour les deux contextes sont très différentes. Le scope local requiert un trailing <code>in</code>, mais pas les corps de module. Par ailleurs, certaines déclarations impératives doivent être assignées à <code>_</code> ou <code>()</code>, voir utiliser un double <code>;;</code>.</p>
<table>
  <tr>
    <th>
      Corps de module OCaml
    </th>
<pre><code class="hljs">&lt;th&gt;
  Corps de module Reason
&lt;/th&gt;
</code></pre>
  </tr>
  <tr>
    <td>
      <pre><code class="hljs">let ten = 10
let () = imperativeFunc ten ten
let () = imperativeFunc 0 0</code></pre>
    </td>
<pre><code class="hljs">&lt;td&gt;
  &lt;pre&gt;&lt;code&gt;let ten = 10;
</code></pre>
<p>imperativeFunc(ten, ten);
imperativeFunc(0, 0);</code></pre>
</td></p>
  </tr>
  <tr>
    <td>
      <pre><code class="hljs">let ten = 10;;
imperativeFunc ten ten;;
imperativeFunc 0 0;;</code></pre>
    </td>
<pre><code class="hljs">&lt;td&gt;
  Pareil qu'au dessus
&lt;/td&gt;
</code></pre>
  </tr>
  <tr>
    <th>
      Scope local OCaml
    </th>
<pre><code class="hljs">&lt;th&gt;
  Scope local Reason
&lt;/th&gt;
</code></pre>
  </tr>
  <tr>
    <td>
      <pre><code class="hljs">let ten = 10 in
let _ = imperativeFunc ten ten in
imperativeFunc 0 0</code></pre>
    </td>
<pre><code class="hljs">&lt;td&gt;
  Pareil qu'au dessus
&lt;/td&gt;
</code></pre>
  </tr>
  <tr>
    <td>
      <pre><code class="hljs">let ten = 10 in begin
  imperativeFunc ten ten;
  imperativeFunc 0 0
end</code></pre>
    </td>
<pre><code class="hljs">&lt;td&gt;
  Pareil qu'au dessus
&lt;/td&gt;
</code></pre>
  </tr>
  <tr>
    <td>
      <pre><code class="hljs">let ten = 10 in (
  imperativeFunc ten ten;
  imperativeFunc 0 0
)</code></pre>
    </td>
<pre><code class="hljs">&lt;td&gt;
  Pareil qu'au dessus
&lt;/td&gt;
</code></pre>
  </tr>
</table>
<h2><a class="anchor" aria-hidden="true" id="tuple-et-record"></a><a href="#tuple-et-record" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Tuple et Record</h2>
<p>En Reason, les tuples s'écrivent toujours avec des parenthèses.</p>
<table>
<thead>
<tr><th>OCaml</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td><code>let tup = 4, 5</code></td><td><code>let tup = (4, 5);</code></td></tr>
<tr><td><code>let tup = ((1: int), (2:int))</code></td><td><code>let tup = (1: int, 2:int);</code></td></tr>
<tr><td><code>fun ((a: int), (b: int)) -&gt; a</code></td><td><code>((a: int, b: int)) =&gt; a;</code></td></tr>
</tbody>
</table>
<p>En Reason, les valeurs des records ressemblent à du JavaScript, utilisant <code>:</code> à la place de <code>=</code>.</p>
<table>
  <tr>
    <th>
      OCaml
    </th>
<pre><code class="hljs">&lt;th&gt;
  Reason
&lt;/th&gt;
</code></pre>
  </tr>
  <tr>
    <td>
      <pre><code class="hljs">let myRec = {x = 0; y = 10}</code></pre>
    </td>
<pre><code class="hljs">&lt;td&gt;
  &lt;pre&gt;&lt;code&gt;let myRec = {x: 0, y: 10};&lt;/code&gt;&lt;/pre&gt;
&lt;/td&gt;
</code></pre>
  </tr>
  <tr>
    <td>
      <pre><code class="hljs">let myFuncs = {
  myFun = (fun x -> x + 1);
  your = (fun a b -> a + b);
}</code></pre>
    </td>
<pre><code class="hljs">&lt;td&gt;
  &lt;pre&gt;&lt;code&gt;let myFuncs = {
</code></pre>
<p>myFun: (x) =&gt; x + 1,
your: (a, b) =&gt; a + b
};</code></pre>
</td></p>
  </tr>
</table>
<h2><a class="anchor" aria-hidden="true" id="listes"></a><a href="#listes" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Listes</h2>
<table>
<thead>
<tr><th>OCaml</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td><code>let list = [1; 2; 3]</code></td><td><code>let list = [1; 2; 3]</code></td></tr>
<tr><td><code>let list = hd :: tl</code></td><td><code>let list = [hd, ...tl];</code></td></tr>
</tbody>
</table>
<h2><a class="anchor" aria-hidden="true" id="definitions-de-type"></a><a href="#definitions-de-type" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Définitions de type</h2>
<table>
<thead>
<tr><th>Tuple OCaml</th><th>Tuple Reason</th></tr>
</thead>
<tbody>
<tr><td><code>type tuple = int * int</code></td><td><code>type tuple = (int, int);</code></td></tr>
<tr><td><code>let tup: tuple = (10, 30)</code></td><td><code>let tup: tuple = (10, 30);</code></td></tr>
</tbody>
</table>
<table>
<thead>
<tr><th>Record OCaml</th><th>Record Reason</th></tr>
</thead>
<tbody>
<tr><td><code>type r = {x: int; y: int}</code></td><td><code>type r = {x: int, y: int};</code></td></tr>
<tr><td><code>let myRec: r = {x = 0; y = 10}</code></td><td><code>let myRec: r = {x: 0, y: 10};</code></td></tr>
</tbody>
</table>
<table>
<thead>
<tr><th>Fonction OCaml</th><th>Fonction Reason</th></tr>
</thead>
<tbody>
<tr><td><code>type func = int -&gt; int</code></td><td><code>type func = int =&gt; int;</code></td></tr>
<tr><td><code>let x: func = fun a -&gt; a + 1</code></td><td><code>let x: func = (a) =&gt; a + 1;</code></td></tr>
</tbody>
</table>
<h2><a class="anchor" aria-hidden="true" id="fonctions"></a><a href="#fonctions" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Fonctions</h2>
<table>
<thead>
<tr><th>OCaml</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td><code>let x a b = e</code></td><td><code>let x = (a, b) =&gt; e</code></td></tr>
<tr><td><code>let x = fun a b -&gt; e</code></td><td><code>let x = (a, b) =&gt; e</code></td></tr>
<tr><td><code>let x = fun a -&gt; fun b -&gt; e</code></td><td><code>let x = (a, b) =&gt; e</code></td></tr>
</tbody>
</table>
<h3><a class="anchor" aria-hidden="true" id="fonctions-match-a-un-argument"></a><a href="#fonctions-match-a-un-argument" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Fonctions match à un argument</h3>
<p>OCaml a une définition de fonction (<code>function |</code>) qu'on considère équivalente à <code>function a -&gt; match a with ...</code>. Reason possède la même, mais la syntaxe ici montre plus clairement qu'il s'agit d'une extension de fonction à un seul arguement. Le match à un seul cas est une extension naturelle du lambda simple, et le lambda à plusieurs cas est une extension naturelle du lambda simple.</p>
<table>
  <tr>
    <th>
      Forme
    </th>
<pre><code class="hljs">&lt;th&gt;
  OCaml
&lt;/th&gt;

&lt;th&gt;
  Reason
&lt;/th&gt;
</code></pre>
  </tr>
  <tr>
    <td>
      Lambda
    </td>
<pre><code class="hljs">&lt;td&gt;
  &lt;pre&gt;&lt;code&gt;fun pat -&gt; e&lt;/code&gt;&lt;/pre&gt;
&lt;/td&gt;

&lt;td&gt;
  &lt;pre&gt;&lt;code&gt;fun pat =&gt; e&lt;/code&gt;&lt;/pre&gt;
&lt;/td&gt;
</code></pre>
  </tr>
  <tr>
    <td>
      Cas à un match
    </td>
<pre><code class="hljs">&lt;td&gt;
  &lt;pre&gt;&lt;code&gt;function | pat -&gt; e&lt;/code&gt;&lt;/pre&gt;
&lt;/td&gt;

&lt;td&gt;
  &lt;pre&gt;&lt;code&gt;fun | pat =&gt; e&lt;/code&gt;&lt;/pre&gt;
&lt;/td&gt;
</code></pre>
  </tr>
  <tr>
    <td>
      Plusieurs cas
    </td>
<pre><code class="hljs">&lt;td&gt;
  &lt;pre&gt;&lt;code&gt;function | pat -&gt; e
     | pat2 -&gt; e&lt;/code&gt;&lt;/pre&gt;
&lt;/td&gt;

&lt;td&gt;
  &lt;pre&gt;&lt;code&gt;fun | pat =&gt; e
| pat2 =&gt; e&lt;/code&gt;&lt;/pre&gt;
&lt;/td&gt;
</code></pre>
  </tr>
</table>
<h3><a class="anchor" aria-hidden="true" id="annotations-d-argument"></a><a href="#annotations-d-argument" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Annotations d'argument</h3>
<p>En Reason et en OCaml, les arguments sont annotés avec des types (comme pour tout le reste), les enveloppant entre parenthèses après l'ajout de <code>:typeAnnotation</code>.</p>
<pre><code class="hljs css language-reason">(arg: argType) =&gt; returnValue;
</code></pre>
<pre><code class="hljs css language-reason">(arg: argType) =&gt; (arg2: arg2Type) =&gt; returnValue;
</code></pre>
<pre><code class="hljs css language-reason">(arg: argType, arg2: arg2Type) =&gt; returnValue;
</code></pre>
<p>Reason ainsi qu'OCaml permettent d'annoter le type retourné, lorsqu'on utilise la forme du &quot;super binding let sucré&quot;.</p>
<pre><code class="hljs css language-ocaml"><span class="hljs-comment">(* OCaml *)</span>
<span class="hljs-keyword">let</span> myFunc (a:<span class="hljs-built_in">int</span>) (b:<span class="hljs-built_in">int</span>) :<span class="hljs-built_in">int</span> * <span class="hljs-built_in">int</span> = (a, b)
<span class="hljs-keyword">let</span> myFunc (a:<span class="hljs-built_in">int</span>) (b:<span class="hljs-built_in">int</span>) :<span class="hljs-built_in">int</span> <span class="hljs-built_in">list</span> = [<span class="hljs-number">1</span>]
<span class="hljs-keyword">let</span> myFunc (a:<span class="hljs-built_in">int</span>) (b:<span class="hljs-built_in">int</span>) :<span class="hljs-built_in">int</span> -&gt; <span class="hljs-built_in">int</span> = <span class="hljs-keyword">fun</span> x -&gt; x + a + b
</code></pre>
<pre><code class="hljs css language-reason"><span class="hljs-comment">/* Reason */</span>
<span class="hljs-keyword">let</span> myFunc = (a: int, b: int) :(int, int) =&gt; (a, b);
<span class="hljs-keyword">let</span> myFunc = (a: int, b: int) :list(int) =&gt; <span class="hljs-literal">[</span><span class="hljs-number">1</span><span class="hljs-literal">]</span>;
<span class="hljs-keyword">let</span> myFunc = (a: int, b: int): (int =&gt; int) =&gt; (x) =&gt; x <span class="hljs-operator">+</span> a <span class="hljs-operator">+</span> b;
</code></pre>
<p>Parce que nous utilisons <code>=&gt;</code> pour les fonctions partout en Reason, il y a un cas où nous avons besoin d'ajouter des parenthèses supplémentaires atour du type retourné, qui est lui-même un type de fonction.</p>
<h3><a class="anchor" aria-hidden="true" id="parametres-de-type"></a><a href="#parametres-de-type" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Paramètres de type</h3>
<h4><a class="anchor" aria-hidden="true" id="ocaml"></a><a href="#ocaml" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>OCaml</h4>
<p>Les applications de type en OCaml (pensez &quot;generiques&quot;), sont appliquées dans l'ordre inverse.</p>
<p>Il y a ainsi dans le langage, quelques conséquences assez peu intuitives à cela.</p>
<pre><code class="hljs css language-ocaml"><span class="hljs-keyword">let</span> x: <span class="hljs-built_in">int</span> <span class="hljs-built_in">list</span> = [<span class="hljs-number">2</span>]

<span class="hljs-keyword">type</span> listOfListOfInts = <span class="hljs-built_in">int</span> <span class="hljs-built_in">list</span> <span class="hljs-built_in">list</span>

<span class="hljs-comment">(* Parsé comme étant : *)</span>
<span class="hljs-keyword">type</span> listOfListOfInts = (<span class="hljs-built_in">int</span> <span class="hljs-built_in">list</span>) <span class="hljs-built_in">list</span>
</code></pre>
<p>Les choses deviennent encore plus étranges lorsque les constructeurs de type acceptent plusieurs paramètres. Les arguments multiples nécessitent des parenthèses et des virgules pour séparer les paramètres de type, mais ces parenthèses ne représentent pas les tuples. La forme parenthèses/virgule doit également être donnée lors de la construction d'instances de type tels que le tuple <code>(int, string) tuple</code>.</p>
<pre><code class="hljs css language-ocaml"><span class="hljs-keyword">type</span> (<span class="hljs-symbol">'a</span>, <span class="hljs-symbol">'b</span>) tuple = <span class="hljs-symbol">'a</span> * <span class="hljs-symbol">'b</span>

<span class="hljs-keyword">type</span> listOfTuplesOfStringAndInt = (<span class="hljs-built_in">string</span>, <span class="hljs-built_in">int</span>) tuple <span class="hljs-built_in">list</span>

<span class="hljs-comment">(* Parsé comme étant : *)</span>
<span class="hljs-keyword">type</span> listOfTuplesOfStringAndInt = ((<span class="hljs-built_in">string</span>, <span class="hljs-built_in">int</span>) tuple) <span class="hljs-built_in">list</span>

<span class="hljs-comment">(* Ce qui permet une liste de (tuples de (string et d'int)) *)</span>
<span class="hljs-keyword">let</span> tuples: listOfTuplesOfStringAndInt = [(<span class="hljs-string">"asdf"</span>, <span class="hljs-number">3</span>)]
</code></pre>
<h4><a class="anchor" aria-hidden="true" id="reason"></a><a href="#reason" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Reason</h4>
<p>En résumé, Reason unifie presque la totalité de la syntaxe au style d'une simple &quot;application de fonction&quot;, ce qui signifie que les paramètres de type suivent le même modèle de listes séparées par des espaces vu partout ailleurs dans la syntaxe. Le résultat de tout cela est qu'il y a moins de modèles syntaxiques à apprendre.</p>
<p>Par exemple, on peut imaginer <code>list</code> comme étant une &quot;fonction&quot; pour les types qui accepte un type et retourne un nouveau type.</p>
<table>
  <tr>
    <th>
      OCaml
    </th>
<pre><code class="hljs">&lt;th&gt;
  Reason
&lt;/th&gt;
</code></pre>
  </tr>
  <tr>
    <td>
      <pre><code class="hljs">let x: int list = [2]
type listOfListOfInts = int list list
type ('a, 'b) tup = ('a * 'b)
type pairs = (int, int) tup list
let tuples: pairs = [(2, 3)]</code></pre>
    </td>
<pre><code class="hljs">&lt;td&gt;
  &lt;pre&gt;&lt;code&gt;let x: list(int) = [2];
</code></pre>
<p>type listOfListOfInts = list(list(int));
type tup('a, 'b) = ('a, 'b);
type pairs = list(tup(int, int));
let tuples: pairs = [(2, 3)];</code></pre>
</td></p>
  </tr>
</table>
<h2><a class="anchor" aria-hidden="true" id="tuples-en-tant-que-parametres-de-type"></a><a href="#tuples-en-tant-que-parametres-de-type" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Tuples en tant que paramètres de type</h2>
<p>Parce qu'OCaml utilise des parenthèses et des virgules pour représenter plusieurs arguments de constructeurs de type, il est assez déroutant de voir que l'un des arguments d'un constructeur de type est lui-même un tuple. En OCaml, il est difficile de se rappeler la différence entre un constructeur de type acceptant plusieurs arguments et un constructeur de type acceptant un seul argument qui se trouve être un tuple.</p>
<p>Les exemples suivants montrent la différence entre passer <em>deux</em> paramètres de type à <code>pair</code> et <em>un seul</em> paramètre de type qui est un tuple.</p>
<table>
<thead>
<tr><th>OCaml</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td><code>type intPair = (int, int) pair</code></td><td><code>type intPair = pair(int, int)</code></td></tr>
<tr><td><code>type pairList = (int * int) list</code></td><td><code>type pairList = list((int, int))</code></td></tr>
</tbody>
</table>
<ul>
<li>En Reason, la syntaxe qui représente un tuple ou des types de tuples ressemble toujours à un tuple.</li>
<li>En Reason, la syntaxe qui représente un record ou des types de records ressemble toujours à un record.</li>
<li>À peu près tout le reste utilise le modèle syntaxique de l'application de fonction (arguments séparés par des virgules).</li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="variants"></a><a href="#variants" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Variants</h2>
<h5><a class="anchor" aria-hidden="true" id="ocaml-1"></a><a href="#ocaml-1" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>OCaml</h5>
<ul>
<li>OCaml s'attend déjà à ce que les types des arguments de constructeurs soient spécifiés sous la forme de tuples, donc on est un peu confus lorsque le seul argument qu'attend un constructeur <em>se trouve</em> être type de tuple.</li>
<li>Ce qui est encore plus surprenant, c'est que les constructeurs n'acceptent pas <em>réellement</em> les tuples, même si la syntaxe parait ressembler à des tuples.</li>
<li>Parfois, la syntaxe pour l'instanciation d'un constructeur avec plusieurs arguments chevauche la syntaxe pour construire une variant avec un seul argument qui se trouve être un tuple - donc on dirait <em>vraiment</em> que vous <em>êtes</em> entrain d'envoyer un tuple, alors que ce n'est pas le cas.</li>
</ul>
<h5><a class="anchor" aria-hidden="true" id="reason-1"></a><a href="#reason-1" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Reason</h5>
<ul>
<li>Les types de constructeurs de variants doivent être listés sous forme de listes séparées par des virgules, en utilisant des parenthèses pour regrouper par priorité (comme <strong>tout</strong> le reste).</li>
<li>La construction des instances de la variant (comme vous l'aurez deviné) suit le style d'application de la fonction (listes séparées par des virgules).</li>
<li>Les tuples <em>ressemblent</em> <strong>toujours</strong> à des tuples, et tout autre chose qui ressemblerait à un type … <em>est</em> un tuple.</li>
</ul>
<table>
  <tr>
    <th>
      OCaml
    </th>
<pre><code class="hljs">&lt;th&gt;
  Reason
&lt;/th&gt;
</code></pre>
  </tr>
  <tr>
    <td>
      <pre><code class="hljs">type myVariant =
  | HasNothing
  | HasSingleInt of int
  | HasSingleTuple of (int * int)
  | HasMultipleInts of int * int
  | HasMultipleTuples of (int * int) * (int * int)</code></pre>
    </td>
<pre><code class="hljs">&lt;td&gt;
  &lt;pre&gt;&lt;code&gt;type myVariant =
</code></pre>
<p>| HasNothing
| HasSingleInt(int)
| HasSingleTuple((int, int))
| HasMultipleInts(int, int)
| HasMultipleTuples((int, int), (int, int));</code></pre>
</td></p>
  </tr>
  <tr>
    <td>
      <pre><code class="hljs">let a = HasSingleInt 10
let a = HasSingleTuple (10, 10)
let a = HasMultipleInts (10, 10)
let a = HasMultipleTuples ((10, 10), (10, 10))</code></pre>
    </td>
<pre><code class="hljs">&lt;td&gt;
  &lt;pre&gt;&lt;code&gt;let a = HasSingleInt(10);
</code></pre>
<p>let a = HasSingleTuple((10, 10));
let a = HasMultipleInts(10, 10);
let a = HasMultipleTuples((10, 10), (10, 10));</code></pre>
</td></p>
  </tr>
  <tr>
    <td>
      <pre><code class="hljs">let res x = match x with
  | HasNothing -> 0
  | HasSingleInt x -> 0
  | HasSingleTuple (x, y) -> 0
  | HasMultipleInts (x, y) -> 0
  | HasMultipleTuples ((x, y), (q, r)) -> 0</code></pre>
    </td>
<pre><code class="hljs">&lt;td&gt;
  &lt;pre&gt;&lt;code&gt;let res = (x) =&gt;
</code></pre>
<p>switch (x) {
| HasNothing =&gt; 0
| HasSingleInt(x) =&gt; 0
| HasSingleTuple((x, y)) =&gt; 0
| HasMultipleInts(x, y) =&gt; 0
| HasMultipleTuples((x, y), (q, r)) =&gt; 0
};</code></pre>
</td></p>
  </tr>
</table>
<h2><a class="anchor" aria-hidden="true" id="pattern-matching"></a><a href="#pattern-matching" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Pattern Matching</h2>
<table>
  <tr>
    <th>
      OCaml
    </th>
<pre><code class="hljs">&lt;th&gt;
  Reason
&lt;/th&gt;
</code></pre>
  </tr>
  <tr>
    <td>
      <pre><code class="hljs">let res = match x with
  | A (x, y) -> match y with
    | None -> 0
    | Some i -> 10
  | B (x, y) -> 0</code></pre>
    </td>
<pre><code class="hljs">&lt;td&gt;
  &lt;pre&gt;&lt;code&gt;let res = switch (x) {
</code></pre>
<p>| A((x, y)) =&gt; switch (y) {
| None =&gt; 0
| Some(i) =&gt; 10
}
| B((x, y)) =&gt; 0
};</code></pre>
</td></p>
  </tr>
</table>
<p>Pouvez-vous repérer l'erreur dans l'exemple OCaml ? C'est l'une des erreurs les plus fréquentes chez les développeurs OCaml. Le second <code>match</code> <em>doit</em> être englobé dans des parenthèses, sinon le cas <code>Some</code> est parsé comme appartenant au <code>match</code> externe. Visuellement, c'est en fait :</p>
<pre><code class="hljs css language-ocaml"><span class="hljs-keyword">let</span> res = <span class="hljs-keyword">match</span> x <span class="hljs-keyword">with</span>
  | <span class="hljs-type">A</span> (x, y) -&gt; <span class="hljs-keyword">match</span> y <span class="hljs-keyword">with</span>
    | <span class="hljs-type">None</span> -&gt; <span class="hljs-number">0</span>
    | <span class="hljs-type">Some</span> i -&gt; <span class="hljs-number">10</span>
    | <span class="hljs-type">B</span> (x, y) -&gt; <span class="hljs-number">0</span>
</code></pre>
<p>Les <code>{}</code> obligatoires en Reason autour des <code>switch</code> cases empêchent ce problème.</p>
<h2><a class="anchor" aria-hidden="true" id="modules-et-signatures"></a><a href="#modules-et-signatures" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Modules et Signatures</h2>
<h3><a class="anchor" aria-hidden="true" id="definition"></a><a href="#definition" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Définition</h3>
<table>
  <tr>
    <th>
      OCaml
    </th>
<pre><code class="hljs">&lt;th&gt;
  Reason
&lt;/th&gt;
</code></pre>
  </tr>
  <tr>
    <td>
      <pre><code class="hljs">module type MySig = sig
  type t = int
  val x: int
end
module MyModule: MySig = struct
  type t = int
  let x = 10
end
module MyModule = struct
  module NestedModule = struct
     let msg = "hello";
  end
end</code></pre>
    </td>
<pre><code class="hljs">&lt;td&gt;
  &lt;pre&gt;&lt;code&gt;module type MySig = {
</code></pre>
<p>type t = int;
let x: int;
};
module MyModule: MySig = {
type t = int;
let x = 10;
};
module MyModule = {
module NestedModule = {
let msg = &quot;hello&quot;;
};
};</code></pre>
</td></p>
  </tr>
</table>
<h3><a class="anchor" aria-hidden="true" id="types-de-functor"></a><a href="#types-de-functor" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Types de functor</h3>
<table>
  <tr>
    <th>
      OCaml
    </th>
<pre><code class="hljs">&lt;th&gt;
  Reason
&lt;/th&gt;
</code></pre>
  </tr>
  <tr>
    <td>
      <pre><code class="hljs">module type FType =
  functor (A: ASig) ->
  functor (B: BSig) -> Result</code></pre>
    </td>
<pre><code class="hljs">&lt;td&gt;
  &lt;pre&gt;&lt;code&gt;module type FType =
</code></pre>
<p>(A: ASig) =&gt;
(B: BSig) =&gt; Result;</code></pre>
</td></p>
  </tr>
</table>
<h2><a class="anchor" aria-hidden="true" id="functors"></a><a href="#functors" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Functors</h2>
<table>
  <tr>
    <th>
      OCaml
    </th>
<pre><code class="hljs">&lt;th&gt;
  Reason
&lt;/th&gt;
</code></pre>
  </tr>
  <tr>
    <td>
      <pre><code class="hljs">module F =
  functor (A: ASig) ->
  functor (B: BSig) -> struct end</code></pre>
    </td>
<pre><code class="hljs">&lt;td&gt;
  &lt;pre&gt;&lt;code&gt;module F =
</code></pre>
<p>(A: ASig) =&gt;
(B: BSig) =&gt; {};</code></pre>
</td></p>
  </tr>
  <tr>
    <td>
      <pre><code class="hljs">module F = functor (A: ASig) (B: BSig) -> struct end</code></pre>
    </td>
<pre><code class="hljs">&lt;td&gt;
  &lt;pre&gt;&lt;code&gt;module F = (A: ASig, B: BSig) =&gt; {};&lt;/code&gt;&lt;/pre&gt;
&lt;/td&gt;
</code></pre>
  </tr>
  <tr>
    <td>
      <pre><code class="hljs">module F (A: ASig) (B: BSig) = struct end</code></pre>
    </td>
<pre><code class="hljs">&lt;td&gt;
  &lt;pre&gt;&lt;code&gt;module F = (A: ASig, B: BSig) =&gt; {};&lt;/code&gt;&lt;/pre&gt;
&lt;/td&gt;
</code></pre>
  </tr>
  <tr>
    <td>
      <pre><code class="hljs">module Res = F(A)(B)</code></pre>
    </td>
<pre><code class="hljs">&lt;td&gt;
  &lt;pre&gt;&lt;code&gt;module Res = F(A, B);&lt;/code&gt;&lt;/pre&gt;
&lt;/td&gt;
</code></pre>
  </tr>
</table>
<h2><a class="anchor" aria-hidden="true" id="ameliorations-diverses"></a><a href="#ameliorations-diverses" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Améliorations diverses</h2>
<p>OCaml ne requiert pas de parenthèses autour des séquences <code>(a;b;c;d)</code> ou des tuples <code>(x,y)</code>, ce qui finit par exclure un tas d'autres règles de syntaxe très pratiques. Vu que Reason utilise toujours les accolades <code>{}</code> pour englober des séquences ou des bindigs let, et qu'il requiert toujours des parenthèses <code>()</code> autour de tuples, beaucoup d'autres constructions de syntaxe sont exprimées de manière plus intuitive, sans nécessiter d'enveloppement supplémentaire entre parenthèses.</p>
<h3><a class="anchor" aria-hidden="true" id="les-lambdas-en-champs-de-record-n-ont-plus-besoin-de-parentheses-supplementaires"></a><a href="#les-lambdas-en-champs-de-record-n-ont-plus-besoin-de-parentheses-supplementaires" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Les lambdas en champs de record n'ont plus besoin de parenthèses supplémentaires</h3>
<p>Il s'agit d'une amélioration bienvenue parce que les erreurs de type en OCaml que l'utilisateur voyait étaient très déroutantes quand il pensait que la valeur de retour de la fonction était un tuple avec une virgule <code>,</code> infixe.</p>
<table>
  <tr>
    <th>
      OCaml
    </th>
<pre><code class="hljs">&lt;th&gt;
  Reason
&lt;/th&gt;
</code></pre>
  </tr>
  <tr>
    <td>
      <pre><code class="hljs">let myFuncs = {
  myFun = (fun x -> x + 1);
  your = (fun a b -> a + b);
}</code></pre>
    </td>
<pre><code class="hljs">&lt;td&gt;
  &lt;pre&gt;&lt;code&gt;let myFuncs = {
</code></pre>
<p>myFun: (x) =&gt; x + 1,
your: (a, b) =&gt; a + b
};</code></pre>
</td></p>
  </tr>
</table>
<h3><a class="anchor" aria-hidden="true" id="les-lambdas-en-resultats-de-match-n-ont-plus-besoin-de-parentheses-supplementaires"></a><a href="#les-lambdas-en-resultats-de-match-n-ont-plus-besoin-de-parentheses-supplementaires" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Les lambdas en résultats de match n'ont plus besoin de parenthèses supplémentaires</h3>
<table>
  <tr>
    <th>
      OCaml
    </th>
<pre><code class="hljs">&lt;th&gt;
  Reason
&lt;/th&gt;
</code></pre>
  </tr>
  <tr>
    <td>
      <pre><code class="hljs">let x = match prnt with
  | None -> fun a -> blah
  (* Extra () required ! *)
  | Some "_" -> (fun a -> ())
  | Some "ml" -> blah</code></pre>
    </td>
<pre><code class="hljs">&lt;td&gt;
  &lt;pre&gt;&lt;code&gt;let x =
</code></pre>
<p>switch (prnt) {
| None =&gt; (a) =&gt; blah
| Some(&quot;_&quot;) =&gt; (a) =&gt; ()
| Some(&quot;ml&quot;) =&gt; blah
};</code></pre>
</td></p>
  </tr>
</table>
<h3><a class="anchor" aria-hidden="true" id="les-lambdas-et-annotations-de-types-des-tuples-n-ont-plus-besoin-de-parentheses-supplementaires"></a><a href="#les-lambdas-et-annotations-de-types-des-tuples-n-ont-plus-besoin-de-parentheses-supplementaires" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Les lambdas et annotations de types des tuples n'ont plus besoin de parenthèses supplémentaires</h3>
<table>
<thead>
<tr><th>OCaml</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td><code>let tuple = ((fun x -&gt; x), 20)</code></td><td><code>let tuple = ((x) =&gt; x, 20);</code></td></tr>
<tr><td><code>let tuple = ((&quot;hi&quot;: string), (20: int))</code></td><td><code>let tuple = (&quot;hi&quot;: string, 20: int);</code></td></tr>
</tbody>
</table>
<h2><a class="anchor" aria-hidden="true" id="differences-diverses"></a><a href="#differences-diverses" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Différences diverses</h2>
<h3><a class="anchor" aria-hidden="true" id="priorite-d-as"></a><a href="#priorite-d-as" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Priorité d'<code>as</code></h3>
<p>Avec Reason, <code>as</code> à une plus grande priorité que le pipe <code>|</code>. Cela permet de créer des alias <code>as</code> pour des lignes entières dans le pattern matching.</p>
<table>
  <tr>
    <th>
      OCaml
    </th>
<pre><code class="hljs">&lt;th&gt;
  Reason
&lt;/th&gt;
</code></pre>
  </tr>
  <tr>
    <td>
      <pre><code class="hljs">let ppp = match MyThing 20 with
  | (MyThing x as ppp)
  | (YourThing x as ppp) -> ppp;</code></pre>
    </td>
<pre><code class="hljs">&lt;td&gt;
  &lt;pre&gt;&lt;code&gt;let ppp =
</code></pre>
<p>switch (MyThing(20)) {
| MyThing(x) as ppp
| YourThing(x) as ppp =&gt; ppp
};</code></pre>
</td></p>
  </tr>
</table>
<h3><a class="anchor" aria-hidden="true" id="mises-a-jour-de-champ-de-record-mutable"></a><a href="#mises-a-jour-de-champ-de-record-mutable" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Mises à jour de champ de record mutable</h3>
<p>Parce que les égalités et leurs négations ont été rendues plus cohérentes en Reason, l'opérateur <code>=</code> est disponible pour la mise à jour du champ mutable.</p>
<table>
<thead>
<tr><th>OCaml</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td><code>myRec.field &lt;- &quot;next&quot;</code></td><td><code>myRec.field &lt;- &quot;next&quot;</code></td></tr>
</tbody>
</table>
<h3><a class="anchor" aria-hidden="true" id="operateurs-prefixes"></a><a href="#operateurs-prefixes" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Opérateurs préfixes</h3>
<p>En Reason, <code>!</code> est utilisé pour le booléen <code>not</code>. Le déréférencement utilise le suffixe <code>^</code>.</p>
<table>
<thead>
<tr><th>OCaml</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td><code>let x = !(foo.bar)</code></td><td><code>let x = foo.bar^;</code></td></tr>
<tr><td><code>let x = !(foo#bar)</code></td><td><code>let x = foo#bar^;</code></td></tr>
<tr><td><code>let x = !(!foo.bar)</code></td><td><code>let x = foo^.bar^;</code></td></tr>
<tr><td><code>let x = !(!foo#bar)</code></td><td><code>let x = (foo^)#bar^;</code></td></tr>
<tr><td><code>let x = !(!(foo.bar))</code></td><td><code>let x = foo.bar^ ^;</code></td></tr>
<tr><td><code>let x = !(!(foo#bar))</code></td><td><code>let x = foo#bar^ ^;</code></td></tr>
<tr><td><code>let x = !!(foo.bar)</code></td><td><code>let x = !!foo.bar;</code></td></tr>
<tr><td><code>let x = !!(foo#bar)</code></td><td><code>let x = !!foo#bar;</code></td></tr>
<tr><td><code>let x = !~(foo.bar)</code></td><td><code>let x = !~foo.bar;</code></td></tr>
<tr><td><code>let x = !~(foo#bar)</code></td><td><code>let x = !~foo#bar;</code></td></tr>
</tbody>
</table>
<h3><a class="anchor" aria-hidden="true" id="escape-de-commentaire"></a><a href="#escape-de-commentaire" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Escape de commentaire</h3>
<p>Parce que Reason utilise des commentaires de style C, certains obscurs opérateurs préfixes/infixes customs doivent être écrits différemment. Les règles pour les opérateurs préfixes/infixes sont les mêmes que dans la syntaxe OCaml, mais avec les exceptions suivantes :</p>
<p>Plus précisément, si un caractère, à l'exception du premier, d'un opérateur préfixe/infixe est une étoile ou un slash, il faut d'abord l'échapper avec un backslash. Ceux-ci seront analysés <em>sans</em> le backslash lorsqu'ils seront ajoutés à l'AST. Lorsqu'ils sont reprint, les backslashes sont automatiquement rajoutés.</p>
<table>
<thead>
<tr><th>OCaml</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td><code>let (/*) a b = a + b</code></td><td><code>let (/\*) = (a, b) =&gt; a + b;</code></td></tr>
<tr><td><code>let x = 12 /-* 23 /-* 12</code></td><td><code>let x = 12 /-* 23 /-* 12;</code></td></tr>
<tr><td><code>let y = (/*) a b</code></td><td><code>let y = a /\* b;</code></td></tr>
<tr><td><code>let (!=*) q r = q + r</code></td><td><code>let ( !=* ) = (q, r) =&gt; q + r;</code></td></tr>
<tr><td><code>let res = q (!=*) r</code></td><td><code>let res = q(( !=* ), r);</code></td></tr>
<tr><td><code>let (!=/*) q r = q + r</code></td><td><code>let ( !=/\* ) = (q, r) =&gt; q + r;</code></td></tr>
<tr><td><code>let res = q (!=/*) r</code></td><td><code>let res = q(( !=/\* ), r);</code></td></tr>
</tbody>
</table>
<h3><a class="anchor" aria-hidden="true" id="renommage-d-operateur-1"></a><a href="#renommage-d-operateur-1" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Renommage d'opérateur</h3>
<p>Si Reason utilise <code>==</code> pour représenter le <code>=</code> d'OCaml, et utilise <code>===</code> pour représenter le <code>==</code> d'OCaml, alors comment est-ce que Reason représente le symbole <code>===</code> d'OCaml (s'il était défini) ? Reason propose une solution ! &quot;Escape&quot; le symbole triple égal !</p>
<table>
<thead>
<tr><th>Identifiant</th><th>Sens</th><th>OCaml</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td><code>&quot;===&quot;</code></td><td>Valeur custom</td><td><code>x === y</code></td><td><code>x \=== y</code></td></tr>
</tbody>
</table>
<h3><a class="anchor" aria-hidden="true" id="repl"></a><a href="#repl" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>REPL</h3>
<p>Dans la boucle d'évaluation de Reason, <a href="/docs/fr/extra-goodies#repl"><code>rtop</code></a> (une version customisée d'<a href="https://github.com/diml/utop"><code>utop</code></a>), chaque entrée est soumise via un seul point-virgule <code>;</code>. A boucle d'évalution OCaml quant à elle requiert deux points-virgules <code>;;</code>.</p>
<table>
<thead>
<tr><th>OCaml</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td><code>;;</code></td><td><code>;</code></td></tr>
</tbody>
</table>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/fr/faq"><span class="arrow-prev">← </span><span>Foire aux Questions</span></a><a class="docs-next button" href="/docs/fr/newcomer-examples"><span>Exemple pour Débutants</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#commentaires">Commentaires</a></li><li><a href="#renommage-d-operateur">Renommage d'opérateur</a></li><li><a href="#scope-local">Scope local</a></li><li><a href="#scope-local-vs-corps-de-module">Scope local vs Corps de module</a></li><li><a href="#tuple-et-record">Tuple et Record</a></li><li><a href="#listes">Listes</a></li><li><a href="#definitions-de-type">Définitions de type</a></li><li><a href="#fonctions">Fonctions</a><ul class="toc-headings"><li><a href="#fonctions-match-a-un-argument">Fonctions match à un argument</a></li><li><a href="#annotations-d-argument">Annotations d'argument</a></li><li><a href="#parametres-de-type">Paramètres de type</a></li></ul></li><li><a href="#tuples-en-tant-que-parametres-de-type">Tuples en tant que paramètres de type</a></li><li><a href="#variants">Variants</a></li><li><a href="#pattern-matching">Pattern Matching</a></li><li><a href="#modules-et-signatures">Modules et Signatures</a><ul class="toc-headings"><li><a href="#definition">Définition</a></li><li><a href="#types-de-functor">Types de functor</a></li></ul></li><li><a href="#functors">Functors</a></li><li><a href="#ameliorations-diverses">Améliorations diverses</a><ul class="toc-headings"><li><a href="#les-lambdas-en-champs-de-record-n-ont-plus-besoin-de-parentheses-supplementaires">Les lambdas en champs de record n'ont plus besoin de parenthèses supplémentaires</a></li><li><a href="#les-lambdas-en-resultats-de-match-n-ont-plus-besoin-de-parentheses-supplementaires">Les lambdas en résultats de match n'ont plus besoin de parenthèses supplémentaires</a></li><li><a href="#les-lambdas-et-annotations-de-types-des-tuples-n-ont-plus-besoin-de-parentheses-supplementaires">Les lambdas et annotations de types des tuples n'ont plus besoin de parenthèses supplémentaires</a></li></ul></li><li><a href="#differences-diverses">Différences diverses</a><ul class="toc-headings"><li><a href="#priorite-d-as">Priorité d'<code>as</code></a></li><li><a href="#mises-a-jour-de-champ-de-record-mutable">Mises à jour de champ de record mutable</a></li><li><a href="#operateurs-prefixes">Opérateurs préfixes</a></li><li><a href="#escape-de-commentaire">Escape de commentaire</a></li><li><a href="#renommage-d-operateur-1">Renommage d'opérateur</a></li><li><a href="#repl">REPL</a></li></ul></li></ul></nav></div><span><script src="/js/redirectBlog.js"></script><script src="/js/pjax-api.min.js"></script><script>window.foo = new Pjax({
          areas: [
            // try to use the first query.
            '.mainContainer, .docsNavContainer .toc .navWrapper, .onPageNav',
            // fallback
            'body'
          ],
          link: '.docsNavContainer:not(.docsSliderActive) a',
          update: {
            script: false,
          }
        });
        var languagesMenuItemCopy = document.getElementById("languages-menu");
        languagesMenuItemCopy.addEventListener("click", function(e){
          e.preventDefault();
          e.stopPropagation();
          e.stopImmediatePropagation();
        });</script></span></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                
                apiKey: '966d1e412f67114a07dc0afe44b19b53',
                indexName: 'reason',
                inputSelector: '#search_input_react',
                algoliaOptions: {"facetFilters":["lang:fr"]}
              });
            </script></body></html>