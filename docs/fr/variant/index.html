<!DOCTYPE html><html lang="fr"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Variant! · Reason</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="&lt;p&gt;Voici, le joyau de la couronne des structures de données Reason !&lt;/p&gt;
"/><meta name="docsearch:language" content="fr"/><meta property="og:title" content="Variant! · Reason"/><meta property="og:type" content="website"/><meta property="og:url" content="https://reasonml.github.io/"/><meta property="og:description" content="&lt;p&gt;Voici, le joyau de la couronne des structures de données Reason !&lt;/p&gt;
"/><meta name="twitter:card" content="summary"/><link rel="shortcut icon" href="/img/icon_50.png"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"/><link rel="alternate" type="application/atom+xml" href="https://reasonml.github.io/blog/atom.xml" title="Reason Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://reasonml.github.io/blog/feed.xml" title="Reason Blog RSS Feed"/><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/fr"><img class="logo" src="/img/dummy.svg" alt="Reason"/></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/docs/fr/what-and-why" target="_self">Documentation</a></li><li class=""><a href="/fr/try" target="_self">Essayer</a></li><li class=""><a href="/api/index" target="_self">API</a></li><li class=""><a href="/docs/fr/community" target="_self">Communauté</a></li><li class=""><a href="/blog/" target="_self">Blog</a></li><span><li><a id="languages-menu" href="#"><img class="languages-icon" src="/img/language.svg" alt="Languages icon"/>Français</a><div id="languages-dropdown" class="hide"><ul id="languages-dropdown-items"><li><a href="/docs/ja/variant">日本語</a></li><li><a href="/docs/en/variant">English</a></li><li><a href="/docs/de/variant">Deutsch</a></li><li><a href="/docs/es-ES/variant">Español</a></li><li><a href="/docs/ko/variant">한국어</a></li><li><a href="/docs/pt-BR/variant">Português (Brasil)</a></li><li><a href="/docs/ru/variant">Русский</a></li><li><a href="/docs/uk/variant">Українська</a></li><li><a href="/docs/zh-CN/variant">中文</a></li><li><a href="/docs/zh-TW/variant">繁體中文</a></li><li><a href="https://crowdin.com/project/reason" target="_blank" rel="noreferrer noopener">Aider à la traduction</a></li></ul></div></li><script>
        const languagesMenuItem = document.getElementById("languages-menu");
        const languagesDropDown = document.getElementById("languages-dropdown");
        languagesMenuItem.addEventListener("click", function(event) {
          event.preventDefault();

          if (languagesDropDown.className == "hide") {
            languagesDropDown.className = "visible";
          } else {
            languagesDropDown.className = "hide";
          }
        });
      </script></span><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li><li class=""><a href="https://github.com/facebook/reason" target="_self">Github</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><i></i></div><h2><i>›</i><span>Principes de base du langage</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Intro</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/fr/what-and-why">Quoi &amp; Pourquoi</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Installation</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/fr/installation">Installation</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/editor-plugins">Plugins éditeurs</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/extra-goodies">Goodies supplémentaires</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Principes de base du langage</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/fr/overview">Aperçu</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/let-binding">Let binding</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/type">Type !</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/string-and-char">String &amp; Char</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/boolean">Booléen</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/integer-and-float">Entier &amp; Flottant</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/tuple">Tuple</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/record">Record</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/docs/fr/variant">Variant!</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/null-undefined-option">Null, Undefined &amp; Option</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/list-and-array">Listes &amp; Tableaux</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/function">Fonction</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/if-else">If-Else</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/pipe-first">Pipe First</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/more-on-type">Plus sur les types</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/destructuring">Destructuring</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/pattern-matching">Pattern Matching!</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/mutation">Mutation</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/imperative-loops">Boucles impératives</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/jsx">JSX</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/external">External</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/exception">Exception</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/object">Objet</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/module">Module</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/promise">Promesse</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">JavaScript</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/fr/interop">Interopérabilité</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/syntax-cheatsheet">Cheatsheet de la syntaxe</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/libraries">Bibliothèques</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/converting-from-js">Convertir depuis JavaScript</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Natif</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/fr/native">Natif</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/quickstart-ocaml">Démarrage rapide en natif</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/convert-from-ocaml">Convertir depuis OCaml</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Extra</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/fr/faq">Foire aux Questions</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/comparison-to-ocaml">Comparaison avec OCaml</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/newcomer-examples">Exemple pour Débutants</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/project-structure">Structure de projet</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              const headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                if (event.target.tagName === 'A') {
                  document.body.classList.remove('tocActive');
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://crowdin.com/project/reason/fr" target="_blank" rel="noreferrer noopener">Translate</a><h1 class="postHeaderTitle">Variant!</h1></header><article><div><span><p>Voici, le joyau de la couronne des structures de données Reason !</p>
<p>La majorité des structures de données dans la plupart des langages concernent «ceci <strong>et</strong> cela». Une variant nous permet d'exprimer «ceci <strong>ou</strong> cela».</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">type</span> myResponseVariant =
  | <span class="hljs-constructor">Yes</span>
  | <span class="hljs-constructor">No</span>
  | <span class="hljs-constructor">PrettyMuch</span>;

<span class="hljs-keyword">let</span> areYouCrushingIt = <span class="hljs-constructor">Yes</span>;
</code></pre>
<p><code>Yes</code>, <code>No</code> et <code>PrettyMuch</code> ne sont pas des strings, ni des références, ou un type spécial de donnée. Il s'agit de &quot;constructeurs&quot; (ou &quot;tags&quot;). Le pipe <code>|</code> sépare chaque constructeur.</p>
<p><strong>Note</strong> : le constructeur d'une variant doit être écrit avec la première lettre en majuscule.</p>
<h2><a class="anchor" aria-hidden="true" id="utilisation"></a><a href="#utilisation" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Utilisation</h2>
<p>Avec une variant vient l'une des fonctionnalités les plus importantes de Reason, l'expression <code>switch</code>.</p>
<p>Un <code>switch</code> Reason est visuellement similaire à celui d'autres langages (aka un long <code>if/elseif/elseif</code>...). Il vous permet de vérifier tous les cas possibles d'une variant. Pour l'utiliser, énumérez chaque constructeur de la variant que vous souhaitez utiliser, chacun suivi d'un <code>=&gt;</code> et de l'expression correspondant à ce cas.</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> message =
  <span class="hljs-keyword">switch</span> (areYouCrushingIt) {
  | <span class="hljs-constructor">No</span> =&gt; <span class="hljs-string">"No worries. Keep going!"</span>
  | <span class="hljs-constructor">Yes</span> =&gt; <span class="hljs-string">"Great!"</span>
  | <span class="hljs-constructor">PrettyMuch</span> =&gt; <span class="hljs-string">"Nice!"</span>
  };
<span class="hljs-comment">/* message vaut "Great!" */</span>
</code></pre>
<p>Une variant a un pourcentage extrêmement important d'assistance du système de types. Par exemple, nous vous donnerons une erreur de type si vous avez oublié de couvrir un cas de votre variant ou si deux cas sont redondants. Assurez-vous de jeter un coup d'oeil au switch et au pattern-matching dans une <a href="/docs/fr/pattern-matching">section ultérieure</a> !</p>
<h3><a class="anchor" aria-hidden="true" id="une-variant-necessite-une-definition-explicite"></a><a href="#une-variant-necessite-une-definition-explicite" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Une variant nécessite une définition explicite</h3>
<p>Si la variant que vous utilisez est dans un fichier différent, amenez-la dans le scope comme vous le feriez <a href="/docs/fr/record#record-needs-an-explicit-definition">pour un record</a> :</p>
<pre><code class="hljs css language-reason"><span class="hljs-comment">/* Zoo.re */</span>

<span class="hljs-keyword">type</span> animal = <span class="hljs-constructor">Dog</span> | <span class="hljs-constructor">Cat</span> | <span class="hljs-constructor">Bird</span>;
</code></pre>
<pre><code class="hljs css language-reason"><span class="hljs-comment">/* example.re */</span>

<span class="hljs-keyword">let</span> pet: <span class="hljs-module-identifier">Zoo</span>.animal = <span class="hljs-constructor">Dog</span>; <span class="hljs-comment">/* preferred */</span>
<span class="hljs-comment">/* or */</span>
<span class="hljs-keyword">let</span> pet = <span class="hljs-module-identifier">Zoo</span>.<span class="hljs-constructor">Dog</span>;
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="arguments-de-constructeur"></a><a href="#arguments-de-constructeur" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Arguments de constructeur</h3>
<p>Les constructeurs de variants peuvent contenir des données supplémentaires séparées par une virgule.</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">type</span> account =
  | <span class="hljs-constructor">None</span>
  | <span class="hljs-constructor">Instagram</span>(string)
  | <span class="hljs-constructor">Facebook</span>(string, int);
</code></pre>
<p>Ici, <code>Instagram</code> contient une <code>string</code>, et <code>Facebook</code> tient une <code>string</code> et un <code>int</code>. Utilisation :</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> myAccount = <span class="hljs-constructor">Facebook</span>(<span class="hljs-string">"Josh"</span>, <span class="hljs-number">26</span>);
<span class="hljs-keyword">let</span> friendAccount = <span class="hljs-constructor">Instagram</span>(<span class="hljs-string">"Jenny"</span>);
</code></pre>
<p><strong>Remarquez comment utiliser un constructeur est sembable à un appel de fonction ?</strong> C'est comme si <code>Facebook</code> était une fonction qui acceptait deux arguments. Ce n'est pas un hasard. Il y a une raison pour laquelle les données d'un constructeur s'appellent &quot;arguments de constructeur&quot;.</p>
<p>À l'aide de <code>switch</code>, vous pouvez faire du pattern-matching (encore une fois décrit dans une section ultérieure) sur les arguments d'un constructeur :</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> greeting =
  <span class="hljs-keyword">switch</span> (myAccount) {
  | <span class="hljs-constructor">None</span> =&gt; <span class="hljs-string">"Hi!"</span>
  | <span class="hljs-constructor">Facebook</span>(name, age) =&gt; <span class="hljs-string">"Hi "</span> <span class="hljs-operator">++</span> name <span class="hljs-operator">++</span> <span class="hljs-string">", you're "</span> <span class="hljs-operator">++</span> string_of_int(age) <span class="hljs-operator">++</span> <span class="hljs-string">"-year-old."</span>
  | <span class="hljs-constructor">Instagram</span>(name) =&gt; <span class="hljs-string">"Hello "</span> <span class="hljs-operator">++</span> name <span class="hljs-operator">++</span> <span class="hljs-string">"!"</span>
  };
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="mentions-honorables"></a><a href="#mentions-honorables" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Mentions honorables</h3>
<p>La <a href="/api/index.html">librairie standard</a> expose deux importantes variants dont vous entendrez souvent parler.</p>
<h4><a class="anchor" aria-hidden="true" id="option"></a><a href="#option" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>option</code></h4>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">type</span> option('a) = <span class="hljs-constructor">None</span> | <span class="hljs-constructor">Some</span>('a);
</code></pre>
<p>C'est la convention utilisée pour simuler une valeur &quot;nulle&quot; (aka <code>undefined</code> ou <code>null</code>) d'autres langages. Grâce à cette définition de type de commodité, Reason peut rendre chaque valeur non-nulle par défaut. Un <code>int</code> sera toujours un <code>int</code>, jamais &quot;<code>int</code> <strong>ou</strong> <code>null</code> <strong>ou</strong> <code>undefined</code>&quot;. Si vous souhaitez exprimer un &quot;int nul&quot;, vous utiliserez <code>option(int)</code>, dont les valeurs possibles sont <code>None</code> ou <code>Some(int)</code>. <code>switch</code> vous force à gérer les deux cas. <strong>Par conséquent, un programme en Reason pur n'a pas d'erreurs <code>null</code></strong>.</p>
<h4><a class="anchor" aria-hidden="true" id="list"></a><a href="#list" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>list</code></h4>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">type</span> list('a) = <span class="hljs-constructor">Empty</span> | <span class="hljs-constructor">Head</span>('a, list('a));
</code></pre>
<p><em>Pas la définition de type réelle. Juste un exemple</em>.</p>
<p>Ceci signifie : &quot;une list contenant une valeur de type <code>a</code> (quelle qu'elle soit) est soit vide, soit contient cette valeur plus une autre list&quot;.</p>
<p>Reason fournit à <code>list</code> un <em>sucre syntaxique</em>. <code>[1, 2, 3]</code> est conceptuellement équivalent à <code>Head(1, Head(2, Head(3, Empty)))</code>. Encore une fois, le <code>switch</code> vous oblige à gérer chaque cas de cette variant, y compris <code>Empty</code> (aka <code>[]</code>). <strong>Ceci élimine une autre grosse catégorie de bugs d’accès</strong>.</p>
<h4><a class="anchor" aria-hidden="true" id="autres-types-semblables-a-des-variants"></a><a href="#autres-types-semblables-a-des-variants" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Autres types semblables à des variants</h4>
<p>Saviez-vous que vous pouvez utiliser <code>switch</code> sur des strings, ints, floats, arrays, et plein d'autres structures de données ? Essayez dans l'éditeur pour voir !</p>
<h2><a class="anchor" aria-hidden="true" id="conseils-astuces"></a><a href="#conseils-astuces" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Conseils &amp; astuces</h2>
<p><strong>Faîtes attention</strong> à ne pas confondre un constructeur comportant 2 arguments avec un constructeur avec un seul tuple en argument :</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">type</span> account =
  | <span class="hljs-constructor">Facebook</span>(string, int) <span class="hljs-comment">/* 2 arguments */</span>;
<span class="hljs-keyword">type</span> account2 =
  | <span class="hljs-constructor">Instagram</span>((string, int)) <span class="hljs-comment">/* 1 argument - qui se trouve être un 2-uplet */</span>;
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="les-variants-doivent-avoir-un-constructeur"></a><a href="#les-variants-doivent-avoir-un-constructeur" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Les variants doivent avoir un constructeur</h3>
<p>Si vous venez d’une langage non typé, vous pourriez être tentés d’essayer <code>type foo = int | string</code>. Ceci n'est pas possible en Reason. Vous devriez donner à chaque branche un constructeur : <code>type foo = Int(int) | String(string)</code>. Bien qu'en général, le simple fait que vous ayez besoin d'écrire ça pourrait bien être un anti-pattern. La section Décisions de conception ci-dessous l'explique plus en détails.</p>
<h3><a class="anchor" aria-hidden="true" id="interoperabilite-avec-javascript"></a><a href="#interoperabilite-avec-javascript" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Interopérabilité avec JavaScript</h3>
<p><em>Cette section suppose des connaissance sur l'<a href="https://bucklescript.github.io/docs/en/interop-overview.html">IFE</a> de BuckleScript. Sautez cette partie si vous n'avez pas encore ressenti le besoin d'utiliser des variants pour gérer des bindings de fonctions JavaScript</em>.</p>
<p>Beaucoup de librairies JavaScript utilisent des fonctions pouvant accepter de nombreux types d'arguments. Dans ces cas là, il est très tentant de les modéliser par des variants. Par exemple, supposons qu'il existe une fonction JavaScript <code>myLibrary.draw</code> qui prend un <code>number</code> ou une <code>string</code> en paramètre. Vous pourriez être tenté de la bind comme ceci :</p>
<pre><code class="hljs css language-reason"><span class="hljs-comment">/* réservé pour un usage interne */</span>
<span class="hljs-attribute">[@bs.module "myLibrary"]</span> <span class="hljs-keyword">external</span> draw : 'a =&gt; unit = <span class="hljs-string">"draw"</span>;

<span class="hljs-keyword">type</span> animal =
  | <span class="hljs-constructor">MyFloat</span>(float)
  | <span class="hljs-constructor">MyString</span>(string);

<span class="hljs-keyword">let</span> betterDraw = (animal) =&gt;
  <span class="hljs-keyword">switch</span> (animal) {
  | <span class="hljs-constructor">MyFloat</span>(f) =&gt; draw(f)
  | <span class="hljs-constructor">MyString</span>(s) =&gt; draw(s)
  };
</code></pre>
<p>Vous pourriez procéder de la sorte, mais il existe de bien meilleures solutions ! Par exemple, deux <code>external</code>s tout simplement, qui compilent vers le même appel JavaScript :</p>
<pre><code class="hljs css language-reason"><span class="hljs-attribute">[@bs.module "myLibrary"]</span> <span class="hljs-keyword">external</span> drawFloat : float =&gt; unit = <span class="hljs-string">"draw"</span>;
<span class="hljs-attribute">[@bs.module "myLibrary"]</span> <span class="hljs-keyword">external</span> drawString : string =&gt; unit = <span class="hljs-string">"draw"</span>;
</code></pre>
<p>BuckleScript fournit aussi <a href="https://bucklescript.github.io/docs/en/function.html#modeling-polymorphic-function">plusieurs autres façons</a> de le faire.</p>
<h3><a class="anchor" aria-hidden="true" id="les-types-de-variants-se-trouvent-par-nom-de-champ"></a><a href="#les-types-de-variants-se-trouvent-par-nom-de-champ" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Les types de variants se trouvent par nom de champ</h3>
<p>Veuillez vous référer à cette <a href="/docs/fr/record#record-types-are-found-by-field-name">section du record</a>. C'est pareil pour les variants : une fonction ne peut pas accepter un constructeur arbitraire partagé par deux différentes variants. Encore une fois, cette fonctionnalité existe, il s'agit de la variant polymorphique. Nous en parlerons plus dans le futur =).</p>
<h2><a class="anchor" aria-hidden="true" id="decisions-de-conception"></a><a href="#decisions-de-conception" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Décisions de conception</h2>
<p>La variant sous ses nombreuses formes (variant polymorphe, variant ouverte, GADT, etc.) est probablement <em>la</em> fonctionnalité clé d'un système de types comme celui de Reason. La variant <code>option</code> susmentionnée, par exemple, supprime le besoin de types nuls, une source majeure de bugs dans d'autres langages. Philosophiquement parlant, un problème est composé de nombreuses branches/conditions possibles. Mal gérer ces conditions est la principale source de ce que nous appelons &quot;bugs&quot;. <strong>Un système de types n'élimine pas les bugs par magie. Il souligne les conditions non traitées et vous demande de les couvrir</strong>*. La capacité à modéliser &quot;ceci ou cela&quot; correctement est cruciale.</p>
<p>Par exemple, certains se demandent comment le système de types peut empêcher les données JSON mal formatées de se propager dans leur programme. Ils ne le font pas, pas par eux-mêmes ! Mais si le parser renvoie le type <code>option</code> <code>None | Some(actualData)</code>, alors vous devriez gérer le cas <code>None</code> de façon explicite dans les prochains lieux d'appel. C'est aussi simple que ça.</p>
<p>D'un point de vue &quot;performances pures&quot;, une variant peut potentiellement accélérer considérablement la logique de votre programme. Voici un morceau de JavaScript :</p>
<pre><code class="hljs css language-js"><span class="hljs-keyword">let</span> data = <span class="hljs-string">'dog'</span>;
<span class="hljs-keyword">if</span> (data === <span class="hljs-string">'dog'</span>) {
  ...
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (data === <span class="hljs-string">'cat'</span>) {
  ...
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (data === <span class="hljs-string">'bird'</span>) {
  ...
}
</code></pre>
<p>Il y a une quantité linéaire de contrôle de branche ici (<code>O(n)</code>). Comparez ceci à l'utilisation d'une variant Reason :</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">type</span> animal = <span class="hljs-constructor">Dog</span> | <span class="hljs-constructor">Cat</span> | <span class="hljs-constructor">Bird</span>;
<span class="hljs-keyword">let</span> data = <span class="hljs-constructor">Dog</span>;
<span class="hljs-keyword">switch</span> (data) {
| <span class="hljs-constructor">Dog</span> =&gt; <span class="hljs-operator">...</span>
| <span class="hljs-constructor">Cat</span> =&gt; <span class="hljs-operator">...</span>
| <span class="hljs-constructor">Bird</span> =&gt; <span class="hljs-operator">...</span>
}
</code></pre>
<p>Le compilateur voit la variant et ensuite</p>
<ol>
<li>la transforme de façon conceptuelle en <code>type animal = 0 | 1 | 2</code></li>
<li>compile <code>switch</code> en un format constant dans le temps (<code>O(1)</code>).</li>
</ol>
<p>Vous pourriez vous demander pourquoi les langages fonctionnels typés sont souvent utilisés pour le parsing. Le switch d'un grand arbre de données de façon efficace et en toute sécurité est à peu près le meilleur scénario possible pour les variants.</p>
<!-- TODO: playground link -->
<p>Mind blown? Les variants ont une connexion profonde avec d'autres domaines des mathématiques. <a href="https://codewords.recurse.com/issues/three/algebra-and-calculus-of-algebraic-data-types">Regardez ici</a> pour vous lancer dans une exploration intéressante.</p>
<p>*Il est toujours plus agréable de résoudre le problème plutôt que de recourir à un système de types pour couvrir les défauts. En réalité, il est irréaliste de le faire pour chaque problème, ou même simplement de comprendre tous les problèmes afin de concevoir une solution. Un système de types vous permet d'apporter bon nombre de changements à votre codebase en toute sécurité, sans avoir à tout comprendre par avance. Ce qui est fort pratique pour une &quot;exploration guidée&quot;. À cet égard, les types nous permettent également de ne pas trop concevoir une API pour contourner les pièges simples des callers. Ils réduisent les couches d'abstractions nécessaires pour «faire avancer les choses», ce qui, en retour, réduit le fardeau cognitif des callers.</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/fr/record"><span class="arrow-prev">← </span><span>Record</span></a><a class="docs-next button" href="/docs/fr/null-undefined-option"><span>Null, Undefined &amp; Option</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#utilisation">Utilisation</a><ul class="toc-headings"><li><a href="#une-variant-necessite-une-definition-explicite">Une variant nécessite une définition explicite</a></li><li><a href="#arguments-de-constructeur">Arguments de constructeur</a></li><li><a href="#mentions-honorables">Mentions honorables</a></li></ul></li><li><a href="#conseils-astuces">Conseils &amp; astuces</a><ul class="toc-headings"><li><a href="#les-variants-doivent-avoir-un-constructeur">Les variants doivent avoir un constructeur</a></li><li><a href="#interoperabilite-avec-javascript">Interopérabilité avec JavaScript</a></li><li><a href="#les-types-de-variants-se-trouvent-par-nom-de-champ">Les types de variants se trouvent par nom de champ</a></li></ul></li><li><a href="#decisions-de-conception">Décisions de conception</a></li></ul></nav></div><span><script src="/js/redirectBlog.js"></script><script src="/js/pjax-api.min.js"></script><script>window.foo = new Pjax({
          areas: [
            // try to use the first query.
            '.mainContainer, .docsNavContainer .toc .navWrapper, .onPageNav',
            // fallback
            'body'
          ],
          link: '.docsNavContainer:not(.docsSliderActive) a',
          update: {
            script: false,
          }
        });
        var languagesMenuItemCopy = document.getElementById("languages-menu");
        languagesMenuItemCopy.addEventListener("click", function(e){
          e.preventDefault();
          e.stopPropagation();
          e.stopImmediatePropagation();
        });</script></span></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                
                apiKey: '966d1e412f67114a07dc0afe44b19b53',
                indexName: 'reason',
                inputSelector: '#search_input_react',
                algoliaOptions: {"facetFilters":["lang:fr"]}
              });
            </script></body></html>