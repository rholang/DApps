<!DOCTYPE html><html lang="fr"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Pattern Matching! · Reason</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="&lt;p&gt;&lt;em&gt;Assurez-vous d&#x27;avoir lu la documentation sur les &lt;a href=&quot;/docs/fr/variant&quot;&gt;Variant&lt;/a&gt; en premier&lt;/em&gt;.&lt;/p&gt;
"/><meta name="docsearch:language" content="fr"/><meta property="og:title" content="Pattern Matching! · Reason"/><meta property="og:type" content="website"/><meta property="og:url" content="https://reasonml.github.io/"/><meta property="og:description" content="&lt;p&gt;&lt;em&gt;Assurez-vous d&#x27;avoir lu la documentation sur les &lt;a href=&quot;/docs/fr/variant&quot;&gt;Variant&lt;/a&gt; en premier&lt;/em&gt;.&lt;/p&gt;
"/><meta name="twitter:card" content="summary"/><link rel="shortcut icon" href="/img/icon_50.png"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"/><link rel="alternate" type="application/atom+xml" href="https://reasonml.github.io/blog/atom.xml" title="Reason Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://reasonml.github.io/blog/feed.xml" title="Reason Blog RSS Feed"/><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/fr"><img class="logo" src="/img/dummy.svg" alt="Reason"/></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/docs/fr/what-and-why" target="_self">Documentation</a></li><li class=""><a href="/fr/try" target="_self">Essayer</a></li><li class=""><a href="/api/index" target="_self">API</a></li><li class=""><a href="/docs/fr/community" target="_self">Communauté</a></li><li class=""><a href="/blog/" target="_self">Blog</a></li><span><li><a id="languages-menu" href="#"><img class="languages-icon" src="/img/language.svg" alt="Languages icon"/>Français</a><div id="languages-dropdown" class="hide"><ul id="languages-dropdown-items"><li><a href="/docs/ja/pattern-matching">日本語</a></li><li><a href="/docs/en/pattern-matching">English</a></li><li><a href="/docs/de/pattern-matching">Deutsch</a></li><li><a href="/docs/es-ES/pattern-matching">Español</a></li><li><a href="/docs/ko/pattern-matching">한국어</a></li><li><a href="/docs/pt-BR/pattern-matching">Português (Brasil)</a></li><li><a href="/docs/ru/pattern-matching">Русский</a></li><li><a href="/docs/uk/pattern-matching">Українська</a></li><li><a href="/docs/zh-CN/pattern-matching">中文</a></li><li><a href="/docs/zh-TW/pattern-matching">繁體中文</a></li><li><a href="https://crowdin.com/project/reason" target="_blank" rel="noreferrer noopener">Aider à la traduction</a></li></ul></div></li><script>
        const languagesMenuItem = document.getElementById("languages-menu");
        const languagesDropDown = document.getElementById("languages-dropdown");
        languagesMenuItem.addEventListener("click", function(event) {
          event.preventDefault();

          if (languagesDropDown.className == "hide") {
            languagesDropDown.className = "visible";
          } else {
            languagesDropDown.className = "hide";
          }
        });
      </script></span><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li><li class=""><a href="https://github.com/facebook/reason" target="_self">Github</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><i></i></div><h2><i>›</i><span>Principes de base du langage</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Intro</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/fr/what-and-why">Quoi &amp; Pourquoi</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Installation</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/fr/installation">Installation</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/editor-plugins">Plugins éditeurs</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/extra-goodies">Goodies supplémentaires</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Principes de base du langage</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/fr/overview">Aperçu</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/let-binding">Let binding</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/type">Type !</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/string-and-char">String &amp; Char</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/boolean">Booléen</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/integer-and-float">Entier &amp; Flottant</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/tuple">Tuple</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/record">Record</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/variant">Variant!</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/null-undefined-option">Null, Undefined &amp; Option</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/list-and-array">Listes &amp; Tableaux</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/function">Fonction</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/if-else">If-Else</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/pipe-first">Pipe First</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/more-on-type">Plus sur les types</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/destructuring">Destructuring</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/docs/fr/pattern-matching">Pattern Matching!</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/mutation">Mutation</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/imperative-loops">Boucles impératives</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/jsx">JSX</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/external">External</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/exception">Exception</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/object">Objet</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/module">Module</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/promise">Promesse</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">JavaScript</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/fr/interop">Interopérabilité</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/syntax-cheatsheet">Cheatsheet de la syntaxe</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/libraries">Bibliothèques</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/converting-from-js">Convertir depuis JavaScript</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Natif</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/fr/native">Natif</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/quickstart-ocaml">Démarrage rapide en natif</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/convert-from-ocaml">Convertir depuis OCaml</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Extra</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/fr/faq">Foire aux Questions</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/comparison-to-ocaml">Comparaison avec OCaml</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/newcomer-examples">Exemple pour Débutants</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/project-structure">Structure de projet</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              const headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                if (event.target.tagName === 'A') {
                  document.body.classList.remove('tocActive');
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://crowdin.com/project/reason/fr" target="_blank" rel="noreferrer noopener">Translate</a><h1 class="postHeaderTitle">Pattern Matching!</h1></header><article><div><span><p><em>Assurez-vous d'avoir lu la documentation sur les <a href="/docs/fr/variant">Variant</a> en premier</em>.</p>
<p><strong>Nous y sommes enfin</strong> ! Le pattern matching est l’une des <em>meilleures fonctionnalités du langage</em>. Il ressemble au destructuring, mais avec encore plus d'aide de la part du système de types.</p>
<h2><a class="anchor" aria-hidden="true" id="utilisation"></a><a href="#utilisation" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Utilisation</h2>
<p>Considérons une variant :</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">type</span> payload =
  | <span class="hljs-constructor">BadResult</span>(int)
  | <span class="hljs-constructor">GoodResult</span>(string)
  | <span class="hljs-constructor">NoResult</span>;
</code></pre>
<p>Si on l'utilise avec l'expresion <code>switch</code>, on peut &quot;destructurer&quot; notre variant de la sorte :</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> data = <span class="hljs-constructor">GoodResult</span>(<span class="hljs-string">"Product shipped!"</span>);

<span class="hljs-keyword">let</span> message =
  <span class="hljs-keyword">switch</span> (data) {
  | <span class="hljs-constructor">GoodResult</span>(theMessage) =&gt; <span class="hljs-string">"Success! "</span> <span class="hljs-operator">++</span> theMessage
  | <span class="hljs-constructor">BadResult</span>(errorCode) =&gt; <span class="hljs-string">"Something's wrong. The error code is: "</span> <span class="hljs-operator">++</span> string_of_int(errorCode)
  };
</code></pre>
<p>Notez comment nous avons destructuré <code>data</code> tout en gérant chacun des différents cas. Cependant le ``switch ci-dessus vous générera un warning du compilateur :</p>
<pre><code class="hljs">Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
NoResult
</code></pre>
<p>N'est-ce pas merveilleux ? Tout en correspondant à la forme de nos données, le système de types nous a mis en garde contre un cas non traité. Cet aspect <strong>conditionnel</strong> est ce qui en fait du pattern matching plutôt que de la simple déstructuration. La plupart des structures de données avec un aspect <strong>«si ceci alors cela»</strong> fonctionnent aussi :</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">switch</span> (myList) {
| <span class="hljs-literal">[</span><span class="hljs-literal">]</span> =&gt; print_endline(<span class="hljs-string">"Empty list"</span>)
| <span class="hljs-literal">[</span>a, <span class="hljs-operator">...</span>theRest<span class="hljs-literal">]</span> =&gt; print_endline(<span class="hljs-string">"list with the head value "</span> <span class="hljs-operator">++</span> a)
};

<span class="hljs-keyword">switch</span> (myArray) {
| <span class="hljs-literal">[|</span><span class="hljs-number">1</span>, <span class="hljs-number">2</span><span class="hljs-literal">|]</span> =&gt; print_endline(<span class="hljs-string">"This is an array with item 1 and 2"</span>)
| <span class="hljs-literal">[|</span><span class="hljs-literal">|]</span> =&gt; print_endline(<span class="hljs-string">"This array has no element"</span>)
| _ =&gt; print_endline(<span class="hljs-string">"This is an array"</span>)
};
</code></pre>
<p>Le cas <code>_</code> est un cas spécial qui permet à toutes les conditions inégalées d'accéder à cette branche.</p>
<p>Vous pouvez switch sur des strings, des ints et bien d'autres. Vous pouvez même avoir plusieurs patterns vallant le même résultat !</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> reply =
  <span class="hljs-keyword">switch</span> (message) {
  | <span class="hljs-string">"Reason's pretty cool"</span> =&gt; <span class="hljs-string">"Yep"</span>
  | <span class="hljs-string">"good night"</span> =&gt; <span class="hljs-string">"See ya!"</span>
  | <span class="hljs-string">"hello"</span> | <span class="hljs-string">"hi"</span> | <span class="hljs-string">"heya"</span> | <span class="hljs-string">"hey"</span> =&gt; <span class="hljs-string">"hello to you too!"</span>
  | _ =&gt; <span class="hljs-string">"Nice to meet you!"</span>
  };
</code></pre>
<p>Combiné avec d'autres structures de données, le pattern matching peut produire un code concis, vérifié par le compilateur et performant :</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> message =
  <span class="hljs-keyword">switch</span> (data) {
  | <span class="hljs-constructor">GoodResult</span>(theMessage) =&gt; <span class="hljs-string">"Success! "</span> <span class="hljs-operator">++</span> theMessage
  | <span class="hljs-constructor">BadResult</span>(<span class="hljs-number">0</span> | <span class="hljs-number">1</span> | <span class="hljs-number">5</span>) =&gt; <span class="hljs-string">"Something's wrong. It's a server side problem."</span>
  | <span class="hljs-constructor">BadResult</span>(errorCode) =&gt; <span class="hljs-string">"Unknown error occurred. Code: "</span> <span class="hljs-operator">++</span> string_of_int(errorCode)
  | <span class="hljs-constructor">NoResult</span> =&gt; <span class="hljs-string">"Things look fine"</span>
  };
</code></pre>
<p><strong>Note</strong> : vous ne pouvez passer que des literals (c'est-à-dire des valeurs concrètes) en tant que pattern, pas de noms de let-bindings ou autres. Ce qui suit ne fonctionne pas comme espéré :</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> myMessage = <span class="hljs-string">"Hello"</span>;
<span class="hljs-keyword">switch</span> (greeting) {
| myMessage =&gt; print_endline(<span class="hljs-string">"Hi to you"</span>)
};
</code></pre>
<p>Au lieu de cela, il supposera que vous êtes entrain de match n'importe quelle string et que vous liez ceci au nom ``myMessage dans cette branche du <code>switch</code>, ce qui n'est pas ce que vous vouliez.</p>
<h3><a class="anchor" aria-hidden="true" id="clauses-when"></a><a href="#clauses-when" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Clauses when</h3>
<p>Lorsque vous avez vraiment besoin d'utiliser une logique arbitraire avec un pattern match autrement propre, vous pouvez glisser certaines clauses <code>when</code>, qui sont grosso modo un sucre syntaxique pour <code>if</code> :</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> message =
  <span class="hljs-keyword">switch</span> (data) {
  | <span class="hljs-constructor">GoodResult</span>(theMessage) =&gt; <span class="hljs-operator">...</span>
  | <span class="hljs-constructor">BadResult</span>(errorCode) when isServerError(errorCode) =&gt; <span class="hljs-operator">...</span>
  | <span class="hljs-constructor">BadResult</span>(errorCode) =&gt; <span class="hljs-operator">...</span> <span class="hljs-comment">/* sinon */</span>
  | <span class="hljs-constructor">NoResult</span> =&gt; <span class="hljs-operator">...</span>
  };
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="match-sur-les-exceptions"></a><a href="#match-sur-les-exceptions" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Match sur les exceptions</h3>
<p>Si la fonction lève une exception (couvert plus tard), vous pouvez également y appliquer un match, en plus des valeurs retournées normalement par la fonction.</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">switch</span> (<span class="hljs-module-identifier">List</span>.find((i) =&gt; i <span class="hljs-operator">===</span> theItem, myItems)) {
| item =&gt; print_endline(item)
| <span class="hljs-keyword">exception</span> <span class="hljs-constructor">Not_found</span> =&gt; print_endline(<span class="hljs-string">"No such item found!"</span>)
};
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="patterns-imbriques"></a><a href="#patterns-imbriques" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Patterns imbriqués</h3>
<p>Les <code>|</code> foncitonnent comme espéré :</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">switch</span> (student) {
| {name: <span class="hljs-string">"Jane"</span> | <span class="hljs-string">"Joe"</span>} =&gt; <span class="hljs-operator">...</span>
| {name: <span class="hljs-string">"Bob"</span>, <span class="hljs-constructor">Job</span>: <span class="hljs-constructor">Programmer</span>({fullTime: <span class="hljs-constructor">Yes</span> | <span class="hljs-constructor">Maybe</span>})} =&gt; <span class="hljs-operator">...</span>
};
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="patterns-everywhere"></a><a href="#patterns-everywhere" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Patterns Everywhere</h3>
<p>Vous pouvez placer un pattern partout où vous placeriez une &quot;déclaration de variable&quot; normale:</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">type</span> leftOrRight =
  | <span class="hljs-constructor">Left</span>(int)
  | <span class="hljs-constructor">Right</span>(int);

<span class="hljs-keyword">let</span> i = <span class="hljs-constructor">Left</span>(<span class="hljs-number">1</span>);

<span class="hljs-comment">/* magic! */</span>
<span class="hljs-keyword">let</span> <span class="hljs-constructor">Left</span>(v) | <span class="hljs-constructor">Right</span>(v) = i;
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="conseils-astuces"></a><a href="#conseils-astuces" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Conseils &amp; astuces</h2>
<p><strong>Simplifiez votre pattern-match chaque fois que vous le pouvez</strong>. Ça vous permet de supprimer bien des bugs. Exemple ci-dessous.</p>
<p>Ne pas trop abuser du cas par défaut <code>_</code>. Cela empêche le compilateur de vous dire que vous avez oublié de couvrir un cas (vérification exhaustive), ce qui serait particulièrement utile après un refactoring où vous ajoutez un nouveau cas à une variant. Essayez seulement d'utiliser <code>_</code> en dernier recours après avoir tenté d'infinies possibilités, par ex. strings, ints, etc.</p>
<p>Voici une série d'exemples, du pire au meilleur :</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> optionBoolToBool = opt =&gt;
  <span class="hljs-keyword">if</span> (opt <span class="hljs-operator">==</span> <span class="hljs-constructor">None</span>) {
    <span class="hljs-literal">false</span>;
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (opt <span class="hljs-operator">==</span> <span class="hljs-constructor">Some</span>(<span class="hljs-literal">true</span>)) {
    <span class="hljs-literal">true</span>;
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-literal">false</span>;
  };
</code></pre>
<p>OK : ceci n'est que pure folie =). Passons le tout au pattern matching :</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> optionBoolToBool = opt =&gt;
  <span class="hljs-keyword">switch</span> (opt) {
  | <span class="hljs-constructor">None</span> =&gt; <span class="hljs-literal">false</span>
  | <span class="hljs-constructor">Some</span>(a) =&gt; a ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>
  };
</code></pre>
<p>Un peu mieux, mais encore imbriqué. Le pattern matching vous permet par ailleurs de faire ceci :</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> optionBoolToBool = opt =&gt;
  <span class="hljs-keyword">switch</span> (opt) {
  | <span class="hljs-constructor">None</span> =&gt; <span class="hljs-literal">false</span>
  | <span class="hljs-constructor">Some</span>(<span class="hljs-literal">true</span>) =&gt; <span class="hljs-literal">true</span>
  | <span class="hljs-constructor">Some</span>(<span class="hljs-literal">false</span>) =&gt; <span class="hljs-literal">false</span>
  };
</code></pre>
<p>Beaucoup plus linéaire ! Maintenant, vous pourriez être tenté(e) de faire :</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> optionBoolToBool = opt =&gt;
  <span class="hljs-keyword">switch</span> (opt) {
  | <span class="hljs-constructor">Some</span>(<span class="hljs-literal">true</span>) =&gt; <span class="hljs-literal">true</span>
  | _ =&gt; <span class="hljs-literal">false</span>
  };
</code></pre>
<p>Ce qui est beaucoup plus concis, mais casse la validation exhaustive mentionnée ci-dessus. N'essayez pas de faire ça. Ceci est bien mieux :</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> optionBoolToBool = opt =&gt;
  <span class="hljs-keyword">switch</span> (opt) {
  | <span class="hljs-constructor">Some</span>(trueOrFalse) =&gt; trueOrFalse
  | <span class="hljs-constructor">None</span> =&gt; <span class="hljs-literal">false</span>
  };
</code></pre>
<p>Assez difficile de faire une erreur dans ce code à ce stade ! Chaque fois que vous souhaitez utiliser un if-else avec de nombreuses branches, préférez plutôt le pattern matching. C'est plus concis et <a href="/docs/fr/variant#design-decisions">performant</a> aussi.</p>
<p>Voyez un autre exemple avec switch + tuple <a href="/docs/fr/tuple#tips-tricks">ici</a>.</p>
<h2><a class="anchor" aria-hidden="true" id="decisions-de-conception"></a><a href="#decisions-de-conception" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Décisions de conception</h2>
<p>Le très célèbre <a href="https://en.wikipedia.org/wiki/Fizz_buzz#Programming_interviews">problème fizz buzz</a> émerveille étrangement certaines personnes. En partie grâce à sa capacité à paralyser le programmeur qui espère simplifier/unifier les quelques branches de l'état à la recherche de l'élégance là où il n'y en a pas. Espérons que vous puissiez constater qu'habituellement, la concision visuelle du pattern matching <a href="/try.html?reason=PQKgBAQghgzgpgEzAewHZgBYBcsAcYBcwwATsvDlAMbIJwB0yJA5sAO4CWA1h8AGIcAXoIgBXYQGIA8gGEoAWwA2YEMABQiuFjAAzIYIBG4wWAC8YABQcAlGYB8asGBicsVDJY5h5tMAGYAGjAvHyQAVlsAb0cwAB9LAAYghNtTOzAAIgFhMWEMmPiLJLAAfVT0rP18p0KS5PLM3MFquNL7ZywSDlRmEuQdEu6sK2sYgF8AbjU1HSZPYPQARjAsZDBFhJSwaKcAKRh6RWRmCz1hI2ER0cmgA">nous permet de surmonter la paralysie des prises de décision</a> tout en conservant tous les avantages (et plus, comme vous l'avez vu) d'un tas de <code>if-else</code>s brute-forcés. Il n'y a vraiment rien de mal à énumérer explicitement toutes les possibilités. Le pattern matching correspond à <strong>l'analyse de cas</strong> en mathématiques, une technique de résolution de problèmes valable qui s'avère extrêmement pratique.</p>
<p>Utiliser un <code>switch</code> Reason pour la première fois peut vous faire vous sentir comme s'il vous avait manqué toutes ces années. Attention, cela pourrait ruiner d'autres langages à vos yeux =).</p>
<p>Si vous avez essayé de refactorer une grande logique if-else bien imbriquée, vous pouvez vous rendre compte qu'il est très difficile d'obtenir la bonne logique. D'autre part, le couple pattern matching + tuple correspond conceptuellement à un tableau 2D, où chaque cellule peut être remplie de manière indépendante. Cela garantit que chaque fois que vous devez ajouter un cas au <code>switch</code>, vous pouvez cibler cette cellule et seulement cette cellule du tableau, sans en déranger d'autres.</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">type</span> animal = <span class="hljs-constructor">Dog</span> | <span class="hljs-constructor">Cat</span> | <span class="hljs-constructor">Bird</span>;
<span class="hljs-keyword">let</span> result = <span class="hljs-keyword">switch</span> (isBig, myAnimal) {
| (<span class="hljs-literal">true</span>, <span class="hljs-constructor">Dog</span>) =&gt; <span class="hljs-number">1</span>
| (<span class="hljs-literal">true</span>, <span class="hljs-constructor">Cat</span>) =&gt; <span class="hljs-number">2</span>
| (<span class="hljs-literal">true</span>, <span class="hljs-constructor">Bird</span>) =&gt; <span class="hljs-number">3</span>
| (<span class="hljs-literal">false</span>, <span class="hljs-constructor">Dog</span> | <span class="hljs-constructor">Cat</span>) =&gt; <span class="hljs-number">4</span>
| (<span class="hljs-literal">false</span>, <span class="hljs-constructor">Bird</span>) =&gt; <span class="hljs-number">5</span>
};
</code></pre>
<table>
<thead>
<tr><th>isBig \ myAnimal</th><th>Dog</th><th>Cat</th><th>Bird</th></tr>
</thead>
<tbody>
<tr><td>true</td><td>1</td><td>2</td><td>3</td></tr>
<tr><td>false</td><td>4</td><td>4</td><td>5</td></tr>
</tbody>
</table>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/fr/destructuring"><span class="arrow-prev">← </span><span>Destructuring</span></a><a class="docs-next button" href="/docs/fr/mutation"><span>Mutation</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#utilisation">Utilisation</a><ul class="toc-headings"><li><a href="#clauses-when">Clauses when</a></li><li><a href="#match-sur-les-exceptions">Match sur les exceptions</a></li><li><a href="#patterns-imbriques">Patterns imbriqués</a></li><li><a href="#patterns-everywhere">Patterns Everywhere</a></li></ul></li><li><a href="#conseils-astuces">Conseils &amp; astuces</a></li><li><a href="#decisions-de-conception">Décisions de conception</a></li></ul></nav></div><span><script src="/js/redirectBlog.js"></script><script src="/js/pjax-api.min.js"></script><script>window.foo = new Pjax({
          areas: [
            // try to use the first query.
            '.mainContainer, .docsNavContainer .toc .navWrapper, .onPageNav',
            // fallback
            'body'
          ],
          link: '.docsNavContainer:not(.docsSliderActive) a',
          update: {
            script: false,
          }
        });
        var languagesMenuItemCopy = document.getElementById("languages-menu");
        languagesMenuItemCopy.addEventListener("click", function(e){
          e.preventDefault();
          e.stopPropagation();
          e.stopImmediatePropagation();
        });</script></span></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                
                apiKey: '966d1e412f67114a07dc0afe44b19b53',
                indexName: 'reason',
                inputSelector: '#search_input_react',
                algoliaOptions: {"facetFilters":["lang:fr"]}
              });
            </script></body></html>