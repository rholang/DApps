<!DOCTYPE html><html lang="fr"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Fonction · Reason</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="&lt;p&gt;&lt;em&gt;Antisèche pour la syntaxe complète des fonctions à la fin&lt;/em&gt;&lt;/p&gt;
"/><meta name="docsearch:language" content="fr"/><meta property="og:title" content="Fonction · Reason"/><meta property="og:type" content="website"/><meta property="og:url" content="https://reasonml.github.io/"/><meta property="og:description" content="&lt;p&gt;&lt;em&gt;Antisèche pour la syntaxe complète des fonctions à la fin&lt;/em&gt;&lt;/p&gt;
"/><meta name="twitter:card" content="summary"/><link rel="shortcut icon" href="/img/icon_50.png"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"/><link rel="alternate" type="application/atom+xml" href="https://reasonml.github.io/blog/atom.xml" title="Reason Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://reasonml.github.io/blog/feed.xml" title="Reason Blog RSS Feed"/><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/fr"><img class="logo" src="/img/dummy.svg" alt="Reason"/></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/docs/fr/what-and-why" target="_self">Documentation</a></li><li class=""><a href="/fr/try" target="_self">Essayer</a></li><li class=""><a href="/api/index" target="_self">API</a></li><li class=""><a href="/docs/fr/community" target="_self">Communauté</a></li><li class=""><a href="/blog/" target="_self">Blog</a></li><span><li><a id="languages-menu" href="#"><img class="languages-icon" src="/img/language.svg" alt="Languages icon"/>Français</a><div id="languages-dropdown" class="hide"><ul id="languages-dropdown-items"><li><a href="/docs/ja/function">日本語</a></li><li><a href="/docs/en/function">English</a></li><li><a href="/docs/de/function">Deutsch</a></li><li><a href="/docs/es-ES/function">Español</a></li><li><a href="/docs/ko/function">한국어</a></li><li><a href="/docs/pt-BR/function">Português (Brasil)</a></li><li><a href="/docs/ru/function">Русский</a></li><li><a href="/docs/uk/function">Українська</a></li><li><a href="/docs/zh-CN/function">中文</a></li><li><a href="/docs/zh-TW/function">繁體中文</a></li><li><a href="https://crowdin.com/project/reason" target="_blank" rel="noreferrer noopener">Aider à la traduction</a></li></ul></div></li><script>
        const languagesMenuItem = document.getElementById("languages-menu");
        const languagesDropDown = document.getElementById("languages-dropdown");
        languagesMenuItem.addEventListener("click", function(event) {
          event.preventDefault();

          if (languagesDropDown.className == "hide") {
            languagesDropDown.className = "visible";
          } else {
            languagesDropDown.className = "hide";
          }
        });
      </script></span><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li><li class=""><a href="https://github.com/facebook/reason" target="_self">Github</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><i></i></div><h2><i>›</i><span>Principes de base du langage</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Intro</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/fr/what-and-why">Quoi &amp; Pourquoi</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Installation</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/fr/installation">Installation</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/editor-plugins">Plugins éditeurs</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/extra-goodies">Goodies supplémentaires</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Principes de base du langage</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/fr/overview">Aperçu</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/let-binding">Let binding</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/type">Type !</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/string-and-char">String &amp; Char</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/boolean">Booléen</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/integer-and-float">Entier &amp; Flottant</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/tuple">Tuple</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/record">Record</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/variant">Variant!</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/null-undefined-option">Null, Undefined &amp; Option</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/list-and-array">Listes &amp; Tableaux</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/docs/fr/function">Fonction</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/if-else">If-Else</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/pipe-first">Pipe First</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/more-on-type">Plus sur les types</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/destructuring">Destructuring</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/pattern-matching">Pattern Matching!</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/mutation">Mutation</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/imperative-loops">Boucles impératives</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/jsx">JSX</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/external">External</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/exception">Exception</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/object">Objet</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/module">Module</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/promise">Promesse</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">JavaScript</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/fr/interop">Interopérabilité</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/syntax-cheatsheet">Cheatsheet de la syntaxe</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/libraries">Bibliothèques</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/converting-from-js">Convertir depuis JavaScript</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Natif</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/fr/native">Natif</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/quickstart-ocaml">Démarrage rapide en natif</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/convert-from-ocaml">Convertir depuis OCaml</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Extra</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/fr/faq">Foire aux Questions</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/comparison-to-ocaml">Comparaison avec OCaml</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/newcomer-examples">Exemple pour Débutants</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/project-structure">Structure de projet</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              const headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                if (event.target.tagName === 'A') {
                  document.body.classList.remove('tocActive');
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://crowdin.com/project/reason/fr" target="_blank" rel="noreferrer noopener">Translate</a><h1 class="postHeaderTitle">Fonction</h1></header><article><div><span><p><em>Antisèche pour la syntaxe complète des fonctions à la fin</em></p>
<p>Nous n'avons pas encore parlé des fonctions jusqu'ici, incroyable non ?</p>
<p>Les fonctions sont déclarées avec une flèche et renvoient l'expression.</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> greet = (name) =&gt; <span class="hljs-string">"Hello "</span> <span class="hljs-operator">++</span> name;
</code></pre>
<p>Ceci déclare un fonction et lui assigne le nom <code>greet</code>, que vous pouvez appeler comme ceci :</p>
<pre><code class="hljs css language-reason">greet(<span class="hljs-string">"world!"</span>); <span class="hljs-comment">/* "Hello world!" */</span>
</code></pre>
<p>Quand une fonction prend plusieurs arguments, ceux-ci sont séparés par une virgule :</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> add = (x, y, z) =&gt; x <span class="hljs-operator">+</span> y <span class="hljs-operator">+</span> z;
add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">/* 6 */</span>
</code></pre>
<p>On met le corps de fonctions plus longues a l'intérieur d'un bloc :</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> greetMore = (name) =&gt; {
  <span class="hljs-keyword">let</span> part1 = <span class="hljs-string">"Hello"</span>;
  part1 <span class="hljs-operator">++</span> <span class="hljs-string">" "</span> <span class="hljs-operator">++</span> name
};
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="aucun-argument"></a><a href="#aucun-argument" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Aucun argument</h2>
<p>Une fonction prends toujours un argument; cependant, parfois, on utilise des fonctions pour leurs <em>effets de bord</em>, et nous n'avons dans ce cas aucun argument a leur passer. Dans d'autres langages, on ne donnerait &quot;aucun argument&quot;. En Reason, toute fonction prend au moins un argument; conventionnellement, on passe dans ce cas la valeur <code>()</code>, appelée &quot;unit&quot;.</p>
<pre><code class="hljs css language-reason"><span class="hljs-comment">/* reçoit &amp; destructure l'argument "unit" */</span>
<span class="hljs-keyword">let</span> logSomething = () =&gt; {
  print_endline(<span class="hljs-string">"hello"</span>);
  print_endline(<span class="hljs-string">"world"</span>)
};

<span class="hljs-comment">/* appelle la fonction avec la valeur de type "unit" */</span>
logSomething();
</code></pre>
<p><code>()</code> est une valeur tout a fait normale, la seule valeur de type <code>unit</code>. Reason lui donne une syntaxe spéciale par commodité.</p>
<h2><a class="anchor" aria-hidden="true" id="arguments-labellises"></a><a href="#arguments-labellises" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Arguments labellisés</h2>
<p>Les fonctions multi-arguments, en particulier celles dont les arguments sont du même type, peuvent être source de confusion lors des appels.</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> addCoordinates = (x, y) =&gt; {
  <span class="hljs-comment">/* use x and y here */</span>
};
<span class="hljs-comment">/* ... */</span>
addCoordinates(<span class="hljs-number">5</span>, <span class="hljs-number">6</span>); <span class="hljs-comment">/* which is x, which is y? */</span>
</code></pre>
<p>En OCaml/Reason, vous pouvez attacher des labels à un argument en préfixant le nom avec le symbole <code>~</code> :</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> addCoordinates = (~x, ~y) =&gt; {
  <span class="hljs-comment">/* use x and y here */</span>
};
<span class="hljs-comment">/* ... */</span>
addCoordinates(~x=<span class="hljs-number">5</span>, ~y=<span class="hljs-number">6</span>);
</code></pre>
<p>Étant donné que nous avons la curryfication (plus à ce sujet ci-dessous), nous pouvons fournir les arguments <strong>dans n'importe quel ordre</strong> :</p>
<pre><code class="hljs css language-reason">addCoordinates(~y=<span class="hljs-number">6</span>, ~x=<span class="hljs-number">5</span>);
</code></pre>
<p>La partie <code>~x</code> de la déclaration signifie que la fonction accepte un argument avec le label <code>x</code>, et peut y référer dans le corps de la fonction avec le même nom. Vous pouvez également faire référence aux arguments dans le corps de la fonction par un nom différent, par soucis de concision :</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> drawCircle = (~radius <span class="hljs-keyword">as</span> r, ~color <span class="hljs-keyword">as</span> c) =&gt; {
  setColor(c);
  startAt(r, r);
  <span class="hljs-comment">/* ... */</span>
};

drawCircle(~radius=<span class="hljs-number">10</span>, ~color=<span class="hljs-string">"red"</span>);
</code></pre>
<p>En effet, <code>(~radius)</code> est juste un raccourci (appelé <strong>punning</strong>) pour <code>(~radius as radius)</code>.</p>
<p>Voici la syntaxe pour typer des arguements :</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> drawCircle = (~radius <span class="hljs-keyword">as</span> r: int, ~color <span class="hljs-keyword">as</span> c: string) =&gt; <span class="hljs-operator">...</span>;
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="curryfication"></a><a href="#curryfication" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Curryfication</h3>
<p>Les fonctions Reason peuvent être automatiquement appelées <strong>en partie</strong> :</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> add = (x, y) =&gt; x <span class="hljs-operator">+</span> y;
<span class="hljs-keyword">let</span> addFive = add(<span class="hljs-number">5</span>);
<span class="hljs-keyword">let</span> eleven = addFive(<span class="hljs-number">6</span>);
<span class="hljs-keyword">let</span> twelve = addFive(<span class="hljs-number">7</span>);
</code></pre>
<p>En fait, le <code>add</code> ci-dessus n'est rien d'autre que du <em>sucre syntaxique</em> pour :</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> add = (x) =&gt; (y) =&gt; x <span class="hljs-operator">+</span> y;
</code></pre>
<p>OCaml optimise ceci pour <a href="https://reasonml.github.io/en/try.html?reason=DYUwLgBAhgJjEF4IAoAeBKRA+FBPTCOqEA1BLgNwBQVA9AFQTAD2zA1tJGABYgTMBXMAAchAQmhwAYgEsAbnxkBnaBAD6SmQDsA5qDUQAZgK0BjMDOZaIpqMGAT6tKqEiwYshYkkxkAVnRqF3AITWIkd08QZABGQKA">éviter l'allocation inutile de fonctions</a> (2 fonctions ici pour ainsi dire) chaque fois qu'il le peut ! De cette façon, nous obtenons</p>
<ul>
<li>une belle syntaxe</li>
<li>la curryfication sans effort supplémentaire (chaque fonction prend un seul argument, en fait !)</li>
<li>aucun coût de performance</li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="arguments-labellises-optionnels"></a><a href="#arguments-labellises-optionnels" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Arguments labellisés optionnels</h2>
<p>Les arguments labellisés d'une fonction peuvent être rendus facultatifs lors de sa déclaration. Vous pouvez ensuite les omettre lors de l'appel de la fonction.</p>
<pre><code class="hljs css language-reason"><span class="hljs-comment">/* radius est facultatif */</span>
<span class="hljs-keyword">let</span> drawCircle = (~color, ~radius=?, ()) =&gt; {
  setColor(color);
  <span class="hljs-keyword">switch</span> (radius) {
  | <span class="hljs-constructor">None</span> =&gt; startAt(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)
  | <span class="hljs-constructor">Some</span>(r_) =&gt; startAt(r_, r_)
  }
};
</code></pre>
<p>Lorsqu'il est fourni dans cette syntaxe, <code>radius</code> est <strong>englobé</strong> dans le type <code>option</code> de la librairie standard, qui vaut par défaut <code>None</code>. S'il est fourni, <code>radius</code> sera enveloppé d'un <code>Some</code>. Donc la valeur du type de <code>radius</code> vaut soit <code>None</code> soit <code>Some int</code> ici.</p>
<p><strong>Note</strong> : <code>None | Some(foo)</code> est un type de structure de données appelé variant et est décrit <a href="/docs/fr/variant">en amont</a>. Ce type de variant particulier est fourni par la librairie standard. C'est ce qu'ont appelle l'<code>option</code>. Sa définition ressemble à : <code>type option('a) = None | Some('a)</code>.</p>
<p><strong>Notez</strong> l'unit <code>()</code> à la fin de <code>drawCircle</code>. Écrire cette fonction en particulier sans l’unit <code>()</code> poserait le problème suivant. Parce que <code>radius</code> et <code>color</code> sont tous deux labellisés, la fonction peut être curryfié, et les arguments peuvent être appliqués sans ordre spécifique, il n'est pas évident de comprendre ce que siginifie :</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> whatIsThis = drawCircle(~color);
</code></pre>
<p>Est-ce que <code>whatIsThis</code> est une fonction <code>drawCircle</code> curryfiée, qui attend que l'argument optionnel <code>radius</code> soit appliqué ? Ou a-t-elle finie son application car <code>radius</code> est optionnel ? Pour résoudre cette confusion, ajoutez un argument positionnel (aka non-labellisé) à <code>drawCircle</code> (par convention <code>()</code>), et OCaml, en règle générale, supposera que l'argument marqué optionnel est omis lorsque l'argument positionnel est fourni.</p>
<p>Parce que nous n'envoyons pas l'unit, OCaml sait que nous voulons curryfier la fonction.</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> curriedFunction = drawCircle(~color);
</code></pre>
<p>Parce que nous <em>fournissons</em> l'unit, OCaml sait que nous omettons délibérément le paramètre <code>radius</code> et la fonction est exécutée.</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> circle = drawCircle(~color, ());
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="optionnel-passe-explicitement"></a><a href="#optionnel-passe-explicitement" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Optionnel passé explicitement</h3>
<p>Parfois, vous pouvez vouloir transférer une valeur à une fonction sans savoir si la valeur est <code>None</code> ou <code>Some(a)</code>. Naïvement, vous feriez :</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> result =
  <span class="hljs-keyword">switch</span> (payloadRadius) {
  | <span class="hljs-constructor">None</span> =&gt; drawCircle(~color, ())
  | <span class="hljs-constructor">Some</span>(r) =&gt; drawCircle(~color, ~radius=r, ())
  };
</code></pre>
<p>Cela devient rapidement fastidieux. Nous fournissons un raccourci :</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> result = drawCircle(~color, ~radius=?payloadRadius, ());
</code></pre>
<p>Ceci signifie &quot;Je comprends que <code>radius</code> est optionnel, et que lorsque je lui passe une valeur, il doit s'agir d'un <code>int</code>. Mais je ne sais pas si la valeur que je passe est <code>None</code> ou <code>Some(val)</code>, alors je vais te passer tout le wrapper <code>option</code>&quot;.</p>
<h3><a class="anchor" aria-hidden="true" id="optionnel-avec-valeur-par-defaut"></a><a href="#optionnel-avec-valeur-par-defaut" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Optionnel avec valeur par défaut</h3>
<p>Il est aussi possible de définir une valeur par défaut pour les arguments labellisés optionnels. Dans ce cas, ils ne sont pas englobés dans un type <code>option</code>.</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> drawCircle = (~radius=<span class="hljs-number">1</span>, ~color, ()) =&gt; {
  setColor(color);
  startAt(radius, radius)
};
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="fonctions-recursives"></a><a href="#fonctions-recursives" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Fonctions récursives</h3>
<p>Par défaut, un valeur ne peut pas voir un binding qui pointe sur elle, mais on peut rendre cela possible en incluant le mot-clé <code>rec</code> dans un binding <code>let</code>. Cela permet aux fonctions de pouvoir accéder à elles-mêmes et de s'appeler, nous donnant ainsi le Pouvoir de la Récursivité.</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> <span class="hljs-keyword">rec</span> neverTerminate = () =&gt; neverTerminate();
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="fonctions-mutuellement-recursives"></a><a href="#fonctions-mutuellement-recursives" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Fonctions mutuellement récursives</h3>
<p>Les fonctions mutuellement récursives commencent comme un simple fonction récursive en utilisant le mot-clé <code>rec</code>, et sont chaînées avec <code>and</code> :</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> <span class="hljs-keyword">rec</span> callSecond = () =&gt; callFirst()
<span class="hljs-keyword">and</span> callFirst = () =&gt; callSecond();
</code></pre>
<p><strong>Notez</strong> qu'il n'y a aucun point-virgule à la fin de la première ligne, ni de <code>let</code> à la seconde.</p>
<h2><a class="anchor" aria-hidden="true" id="conseils-astuces"></a><a href="#conseils-astuces" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Conseils &amp; astuces</h2>
<p>Antisèche pour la syntaxe des fonctions :</p>
<h3><a class="anchor" aria-hidden="true" id="declaration"></a><a href="#declaration" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Déclaration</h3>
<pre><code class="hljs css language-reason"><span class="hljs-comment">/* fonction anonyme. Listé par soucis d'exhaustivité uniquement */</span>
(x) =&gt; (y) =&gt; <span class="hljs-number">1</span>;
<span class="hljs-comment">/* sucre syntaxique pour la deéclaration ci-dessus */</span>
(x, y) =&gt; <span class="hljs-number">1</span>;
<span class="hljs-comment">/* assigné à un nom */</span>
<span class="hljs-keyword">let</span> add = (x, y) =&gt; <span class="hljs-number">1</span>;

<span class="hljs-comment">/* avec labels */</span>
<span class="hljs-keyword">let</span> add = (~first <span class="hljs-keyword">as</span> x, ~second <span class="hljs-keyword">as</span> y) =&gt; x <span class="hljs-operator">+</span> y;
<span class="hljs-comment">/* avec punning */</span>
<span class="hljs-keyword">let</span> add = (~first, ~second) =&gt; first <span class="hljs-operator">+</span> second;

<span class="hljs-comment">/* avec labels et valeur par defaut */</span>
<span class="hljs-keyword">let</span> add = (~first <span class="hljs-keyword">as</span> x=<span class="hljs-number">1</span>, ~second <span class="hljs-keyword">as</span> y=<span class="hljs-number">2</span>) =&gt; x <span class="hljs-operator">+</span> y;
<span class="hljs-comment">/* avec punning */</span>
<span class="hljs-keyword">let</span> add = (~first=<span class="hljs-number">1</span>, ~second=<span class="hljs-number">2</span>) =&gt; first <span class="hljs-operator">+</span> second;

<span class="hljs-comment">/* optionnel */</span>
<span class="hljs-keyword">let</span> add = (~first <span class="hljs-keyword">as</span> x=?, ~second <span class="hljs-keyword">as</span> y=?) =&gt; <span class="hljs-keyword">switch</span> (x) {<span class="hljs-operator">...</span>};
<span class="hljs-comment">/* avec punning */</span>
<span class="hljs-keyword">let</span> add = (~first=?, ~second=?) =&gt; <span class="hljs-keyword">switch</span> (first) {<span class="hljs-operator">...</span>};
</code></pre>
<h4><a class="anchor" aria-hidden="true" id="avec-annotation-de-type"></a><a href="#avec-annotation-de-type" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Avec annotation de type</h4>
<pre><code class="hljs css language-reason"><span class="hljs-comment">/* fonction anonyme */</span>
(x: int) =&gt; (y: int): int =&gt; <span class="hljs-number">1</span>;
<span class="hljs-comment">/* sucre syntaxique de la version ci-dessus */</span>
(x: int, y: int): int =&gt; <span class="hljs-number">1</span>;
<span class="hljs-comment">/* assigner à un nom */</span>
<span class="hljs-keyword">let</span> add = (x: int, y: int): int =&gt; <span class="hljs-number">1</span>;

<span class="hljs-comment">/* avec labels */</span>
<span class="hljs-keyword">let</span> add = (~first <span class="hljs-keyword">as</span> x: int, ~second <span class="hljs-keyword">as</span> y: int) : int =&gt; x <span class="hljs-operator">+</span> y;

<span class="hljs-comment">/* labels avec valeur par défaut */</span>
<span class="hljs-keyword">let</span> add = (~first <span class="hljs-keyword">as</span> x: int=<span class="hljs-number">1</span>, ~second <span class="hljs-keyword">as</span> y: int=<span class="hljs-number">2</span>) : int =&gt; x <span class="hljs-operator">+</span> y;

<span class="hljs-comment">/* optionnel */</span>
<span class="hljs-keyword">let</span> add = (~first <span class="hljs-keyword">as</span> x: option(int)=?, ~second <span class="hljs-keyword">as</span> y: option(int)=?) : int =&gt; <span class="hljs-keyword">switch</span> x {<span class="hljs-operator">...</span>};
<span class="hljs-comment">/* avec sucre syntaxique pour le punning */</span>
<span class="hljs-comment">/* notez que l'appelant passerait un `int` et non `option int` */</span>
<span class="hljs-comment">/* À l'intérieur de la fonction, `first` et `second` sont des `option int`. */</span>
<span class="hljs-keyword">let</span> add = (~first: option(int)=?, ~second: option(int)=?) : int =&gt; <span class="hljs-keyword">switch</span> first {<span class="hljs-operator">...</span>};
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="appel"></a><a href="#appel" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Appel</h3>
<pre><code class="hljs css language-reason"><span class="hljs-comment">/* appel anonyme. Listé uniquement par soucis d'exhaustivité */</span>
add(x)(y);

<span class="hljs-comment">/* sucre syntaxique de la version ci-dessus. */</span>
add(x, y);

<span class="hljs-comment">/* avec labels */</span>
add(~first=<span class="hljs-number">1</span>, ~second=<span class="hljs-number">2</span>);

<span class="hljs-comment">/* avec sucre syntaxique pour le punning */</span>
add(~first, ~second);

<span class="hljs-comment">/* appel avec valeur par défaut. Pareil qu'un appel normal */</span>
add(~first=<span class="hljs-number">1</span>, ~second=<span class="hljs-number">2</span>);

<span class="hljs-comment">/* appel avec optionnel explicite */</span>
add(~first=?<span class="hljs-constructor">Some</span>(<span class="hljs-number">1</span>), ~second=?<span class="hljs-constructor">Some</span>(<span class="hljs-number">2</span>));

<span class="hljs-comment">/* avec le punning */</span>
add(~first?, ~second?);
</code></pre>
<h4><a class="anchor" aria-hidden="true" id="avec-annotation-de-type-1"></a><a href="#avec-annotation-de-type-1" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Avec annotation de type</h4>
<pre><code class="hljs css language-reason"><span class="hljs-comment">/* appel anonyme */</span>
add(x: int)(y: int);

<span class="hljs-comment">/* avec labels */</span>
add(~first=<span class="hljs-number">1</span>: int, ~second=<span class="hljs-number">2</span>: int);

<span class="hljs-comment">/* avec sucre syntaxique pour le punning */</span>
add(~first: int, ~second: int);

<span class="hljs-comment">/* appel avec valeur par défaut. Pareil qu'un appel normal */</span>
add(~first=<span class="hljs-number">1</span>: int, ~second=<span class="hljs-number">2</span>: int);

<span class="hljs-comment">/* appel avec optionnel explicite */</span>
add(~first=?<span class="hljs-constructor">Some</span>(<span class="hljs-number">1</span>): option(int), ~second=?<span class="hljs-constructor">Some</span>(<span class="hljs-number">2</span>): option(int));

<span class="hljs-comment">/* avec sucre syntaxique pour le punning */</span>
 <span class="hljs-operator">+</span>add(~first: option(int)?, ~second: option(int)?);
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="signature-de-type-autonome"></a><a href="#signature-de-type-autonome" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Signature de type autonome</h3>
<pre><code class="hljs css language-reason"><span class="hljs-comment">/* premier argument de type, second argument de type, type retourné */</span>
<span class="hljs-keyword">type</span> foo = int =&gt; int =&gt; int;
<span class="hljs-comment">/* sucre syntaxique de la version ci-dessus */</span>
<span class="hljs-keyword">type</span> foo = (int, int) =&gt; int;

<span class="hljs-comment">/* avec labels */</span>
<span class="hljs-keyword">type</span> foo = (~first: int, ~second: int) =&gt; int;

<span class="hljs-comment">/* avec labels */</span>
<span class="hljs-keyword">type</span> foo = (~first: int=?, ~second: int=?, unit) =&gt; int;
</code></pre>
<h4><a class="anchor" aria-hidden="true" id="dans-les-fichiers-d-interface"></a><a href="#dans-les-fichiers-d-interface" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Dans les fichiers d'interface</h4>
<p>Pour annoter une fonction à partir du fichier d'implémentation (<code>.re</code>) :</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> add: int =&gt; int =&gt; int;
<span class="hljs-comment">/* sucre syntaxique de la version ci-dessus */</span>
<span class="hljs-keyword">let</span> add: (int, int) =&gt; int;
</code></pre>
<p>Mêmes règles que la section précédente, à l'exception du remplacement de <code>type foo = bar</code> par <code>let add: bar</code>.</p>
<p><strong>Ne confondez pas</strong> ceci avec une exportation réelle d'un type dans le fichier d'interface. <code>let add: bar</code> annote un valeur <code>bar</code> existante depuis le fichier d'implémentation. <code>type foo = bar</code> exporte un type de même forme à partir du fichier d'implémentation.</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/fr/list-and-array"><span class="arrow-prev">← </span><span>Listes &amp; Tableaux</span></a><a class="docs-next button" href="/docs/fr/if-else"><span>If-Else</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#aucun-argument">Aucun argument</a></li><li><a href="#arguments-labellises">Arguments labellisés</a><ul class="toc-headings"><li><a href="#curryfication">Curryfication</a></li></ul></li><li><a href="#arguments-labellises-optionnels">Arguments labellisés optionnels</a><ul class="toc-headings"><li><a href="#optionnel-passe-explicitement">Optionnel passé explicitement</a></li><li><a href="#optionnel-avec-valeur-par-defaut">Optionnel avec valeur par défaut</a></li><li><a href="#fonctions-recursives">Fonctions récursives</a></li><li><a href="#fonctions-mutuellement-recursives">Fonctions mutuellement récursives</a></li></ul></li><li><a href="#conseils-astuces">Conseils &amp; astuces</a><ul class="toc-headings"><li><a href="#declaration">Déclaration</a></li><li><a href="#appel">Appel</a></li><li><a href="#signature-de-type-autonome">Signature de type autonome</a></li></ul></li></ul></nav></div><span><script src="/js/redirectBlog.js"></script><script src="/js/pjax-api.min.js"></script><script>window.foo = new Pjax({
          areas: [
            // try to use the first query.
            '.mainContainer, .docsNavContainer .toc .navWrapper, .onPageNav',
            // fallback
            'body'
          ],
          link: '.docsNavContainer:not(.docsSliderActive) a',
          update: {
            script: false,
          }
        });
        var languagesMenuItemCopy = document.getElementById("languages-menu");
        languagesMenuItemCopy.addEventListener("click", function(e){
          e.preventDefault();
          e.stopPropagation();
          e.stopImmediatePropagation();
        });</script></span></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                
                apiKey: '966d1e412f67114a07dc0afe44b19b53',
                indexName: 'reason',
                inputSelector: '#search_input_react',
                algoliaOptions: {"facetFilters":["lang:fr"]}
              });
            </script></body></html>