<!DOCTYPE html><html lang="ja"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Variant! · Reason</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="&lt;p&gt;注目、これが Reason のデータ構造の王冠の宝石です！&lt;/p&gt;
"/><meta name="docsearch:language" content="ja"/><meta property="og:title" content="Variant! · Reason"/><meta property="og:type" content="website"/><meta property="og:url" content="https://reasonml.github.io/"/><meta property="og:description" content="&lt;p&gt;注目、これが Reason のデータ構造の王冠の宝石です！&lt;/p&gt;
"/><meta name="twitter:card" content="summary"/><link rel="shortcut icon" href="/img/icon_50.png"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"/><link rel="alternate" type="application/atom+xml" href="https://reasonml.github.io/blog/atom.xml" title="Reason Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://reasonml.github.io/blog/feed.xml" title="Reason Blog RSS Feed"/><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/ja"><img class="logo" src="/img/dummy.svg" alt="Reason"/></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/docs/ja/what-and-why" target="_self">Docs</a></li><li class=""><a href="/ja/try" target="_self">Try</a></li><li class=""><a href="/api/index" target="_self">API</a></li><li class=""><a href="/docs/ja/community" target="_self">Community</a></li><li class=""><a href="/blog/" target="_self">Blog</a></li><span><li><a id="languages-menu" href="#"><img class="languages-icon" src="/img/language.svg" alt="Languages icon"/>日本語</a><div id="languages-dropdown" class="hide"><ul id="languages-dropdown-items"><li><a href="/docs/en/variant">English</a></li><li><a href="/docs/de/variant">Deutsch</a></li><li><a href="/docs/es-ES/variant">Español</a></li><li><a href="/docs/fr/variant">Français</a></li><li><a href="/docs/ko/variant">한국어</a></li><li><a href="/docs/pt-BR/variant">Português (Brasil)</a></li><li><a href="/docs/ru/variant">Русский</a></li><li><a href="/docs/uk/variant">Українська</a></li><li><a href="/docs/zh-CN/variant">中文</a></li><li><a href="/docs/zh-TW/variant">繁體中文</a></li><li><a href="https://crowdin.com/project/reason" target="_blank" rel="noreferrer noopener">Help Translate</a></li></ul></div></li><script>
        const languagesMenuItem = document.getElementById("languages-menu");
        const languagesDropDown = document.getElementById("languages-dropdown");
        languagesMenuItem.addEventListener("click", function(event) {
          event.preventDefault();

          if (languagesDropDown.className == "hide") {
            languagesDropDown.className = "visible";
          } else {
            languagesDropDown.className = "hide";
          }
        });
      </script></span><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li><li class=""><a href="https://github.com/facebook/reason" target="_self">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><i></i></div><h2><i>›</i><span>Language Basics</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Intro</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/ja/what-and-why">What &amp; Why</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Setup</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/ja/installation">Installation</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/editor-plugins">Editor Plugins</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/extra-goodies">Extra Goodies</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Language Basics</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/ja/overview">Overview</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/let-binding">Let Binding</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/type">Type!</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/string-and-char">String &amp; Char</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/boolean">Boolean</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/integer-and-float">Integer &amp; Float</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/tuple">Tuple</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/record">Record</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/docs/ja/variant">Variant!</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/null-undefined-option">Null, Undefined &amp; Option</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/list-and-array">List &amp; Array</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/function">Function</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/if-else">If-Else</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/pipe-first">Pipe First</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/more-on-type">More on Type</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/destructuring">Destructuring</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/pattern-matching">Pattern Matching!</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/mutation">Mutation</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/imperative-loops">Imperative Loops</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/jsx">JSX</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/external">External</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/exception">Exception</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/object">Object</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/module">Module</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/promise">Promise</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">JavaScript</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/ja/interop">Interop</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/syntax-cheatsheet">Syntax Cheatsheet</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/libraries">Libraries</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/converting-from-js">Converting from JS</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Native</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/ja/native">Native</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/quickstart-ocaml">Native Quickstart</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/convert-from-ocaml">Converting from OCaml</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Extra</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/ja/faq">Frequently Asked Questions</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/comparison-to-ocaml">Comparison to OCaml</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/newcomer-examples">Newcomer Examples</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/project-structure">Project Structure</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              const headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                if (event.target.tagName === 'A') {
                  document.body.classList.remove('tocActive');
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://crowdin.com/project/reason/ja" target="_blank" rel="noreferrer noopener">Translate</a><h1 class="postHeaderTitle">Variant!</h1></header><article><div><span><p>注目、これが Reason のデータ構造の王冠の宝石です！</p>
<p>ほとんどの言語のほとんどのデータ構造は「これ<strong>と</strong>あれ」しか表現できませんが、ヴァリアントは「これ<strong>か</strong>あれ」を表現できます。</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">type</span> myResponseVariant =
  | <span class="hljs-constructor">Yes</span>
  | <span class="hljs-constructor">No</span>
  | <span class="hljs-constructor">PrettyMuch</span>;

<span class="hljs-keyword">let</span> areYouCrushingIt = <span class="hljs-constructor">Yes</span>;
</code></pre>
<p><code>Yes</code>、<code>No</code>、そして<code>PrettyMuch</code> は文字列ではなく、リファレンスでもなく、その他の特殊なデータ型でもありません。 これらは「コンストラクタ」（または「タグ」）と呼ばれています。 <code>|</code> は、各コンストラクタを区切ります。</p>
<p><strong>注意</strong>: ヴァリアントのコンストラクタは大文字にする必要があります。</p>
<h2><a class="anchor" aria-hidden="true" id="使い方"></a><a href="#使い方" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>使い方</h2>
<p>ヴァリアントに加えて、Reason の最も重要な機能の１つに、<code>switch</code> 式があります。</p>
<p>Reason の <code>switch</code> は、見た目的に他の言語の<code>switch</code> に似ています（大きな <code>if/elseif/elseif...</code> として知られる）。 それはヴァリアントのすべてのケースをチェックすることができます。 それを使用するには、使用したい特定のヴァリアントのすべてのコンストラクタを列挙し、それぞれの後ろに <code>=&gt;</code> とそのケースに対応する式を記述します。</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> message =
  <span class="hljs-keyword">switch</span> (areYouCrushingIt) {
  | <span class="hljs-constructor">No</span> =&gt; <span class="hljs-string">"No worries. Keep going!"</span>
  | <span class="hljs-constructor">Yes</span> =&gt; <span class="hljs-string">"Great!"</span>
  | <span class="hljs-constructor">PrettyMuch</span> =&gt; <span class="hljs-string">"Nice!"</span>
  };
<span class="hljs-comment">/* message は "Great!" */</span>
</code></pre>
<p>ヴァリアントには、非常にたくさんの型システム支援があります。 例えば、ヴァリアントの全ケースを網羅し忘れたり、2つのケースが重複したりした場合、型エラーを返します。 <a href="/docs/ja/pattern-matching">後のセクション</a>で switch とパターンマッチングを必ず確認してください！</p>
<h3><a class="anchor" aria-hidden="true" id="ヴァリアントは明示的な定義が必要"></a><a href="#ヴァリアントは明示的な定義が必要" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>ヴァリアントは明示的な定義が必要</h3>
<p>もし使用するヴァリアントが別のファイルにある場合、<a href="/docs/ja/record#record-needs-an-explicit-definition">レコードの時</a>と同様に、それをスコープに入れてください:</p>
<pre><code class="hljs css language-reason"><span class="hljs-comment">/* Zoo.re */</span>

<span class="hljs-keyword">type</span> animal = <span class="hljs-constructor">Dog</span> | <span class="hljs-constructor">Cat</span> | <span class="hljs-constructor">Bird</span>;
</code></pre>
<pre><code class="hljs css language-reason"><span class="hljs-comment">/* example.re */</span>

<span class="hljs-keyword">let</span> pet: <span class="hljs-module-identifier">Zoo</span>.animal = <span class="hljs-constructor">Dog</span>; <span class="hljs-comment">/* preferred */</span>
<span class="hljs-comment">/* or */</span>
<span class="hljs-keyword">let</span> pet = <span class="hljs-module-identifier">Zoo</span>.<span class="hljs-constructor">Dog</span>;
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="コンストラクタ引数"></a><a href="#コンストラクタ引数" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>コンストラクタ引数</h3>
<p>ヴァリアントのコンストラクタはスペースで区切られた追加データを保持することができます。</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">type</span> account =
  | <span class="hljs-constructor">None</span>
  | <span class="hljs-constructor">Instagram</span>(string)
  | <span class="hljs-constructor">Facebook</span>(string, int);
</code></pre>
<p>ここでは、<code>Instagram</code> は、<code>string</code> を保持し、<code>Facebook</code> は、<code>string</code> と <code>int</code> を保持しています。使い方:</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> myAccount = <span class="hljs-constructor">Facebook</span>(<span class="hljs-string">"Josh"</span>, <span class="hljs-number">26</span>);
<span class="hljs-keyword">let</span> friendAccount = <span class="hljs-constructor">Instagram</span>(<span class="hljs-string">"Jenny"</span>);
</code></pre>
<p><strong>コンストラクタを使用するのは関数を呼び出すようなものだと気づきましたか</strong>？ <code>Facebook</code> は2つの引数を受け取る関数であるかのようでした。 これは偶然ではありません。その理由として、コンストラクタのデータは「コンストラクタ引数」と呼ばれます。</p>
<p><code>switch</code> を使用して、コンストラクタの引数をパターンマッチ（再度、後のセクションで説明します）できます:</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> greeting =
  <span class="hljs-keyword">switch</span> (myAccount) {
  | <span class="hljs-constructor">None</span> =&gt; <span class="hljs-string">"Hi!"</span>
  | <span class="hljs-constructor">Facebook</span>(name, age) =&gt; <span class="hljs-string">"Hi "</span> <span class="hljs-operator">++</span> name <span class="hljs-operator">++</span> <span class="hljs-string">", you're "</span> <span class="hljs-operator">++</span> string_of_int(age) <span class="hljs-operator">++</span> <span class="hljs-string">"-year-old."</span>
  | <span class="hljs-constructor">Instagram</span>(name) =&gt; <span class="hljs-string">"Hello "</span> <span class="hljs-operator">++</span> name <span class="hljs-operator">++</span> <span class="hljs-string">"!"</span>
  };
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="特筆事項"></a><a href="#特筆事項" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>特筆事項</h3>
<p><a href="/api/index.html">標準ライブラリ</a> では、今後よく耳にすることになるであろう2つの重要なヴァリアントを公開しています。</p>
<h4><a class="anchor" aria-hidden="true" id="option"></a><a href="#option" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>option</code></h4>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">type</span> option('a) = <span class="hljs-constructor">None</span> | <span class="hljs-constructor">Some</span>('a);
</code></pre>
<p>これは他の言語で「nullable（null 許容）」（別名 <code>undefined</code> や <code>null</code>）値をシミュレートするために使用するものです。 この便利な型定義のおかげで、Reason はすべての値をデフォルトで non-nullable（null 非許容）にすることができます。 <code>int</code> は常に int であり、決して「<code>int</code> <strong>または ** <code>null</code> <strong>または</strong> <code>undefined</code>」にはなりません。 「null を許容する int」を表現したければ、<code>None</code> か <code>Some(int)</code> で書き分けられる <code>option(int)</code> を使用します。 <code>switch</code> は両方の場合を処理することを強制します。したがって、</strong>純粋な Reason プログラムには null エラーがありません**。</p>
<h4><a class="anchor" aria-hidden="true" id="list"></a><a href="#list" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>list</code></h4>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">type</span> list('a) = <span class="hljs-constructor">Empty</span> | <span class="hljs-constructor">Head</span>('a, list('a));
</code></pre>
<p><em>実際の型定義ではありません。単なる例示です</em>。</p>
<p>これは「a （なんでも）型の値を保持するリストは、空かその値と別のリストを保持しているかのどちらかである」と言っています。</p>
<p>Reason には <code>list</code> のシンタックスシュガーがあります。 <code>[1, 2, 3]</code> は、概念的には <code>Head(1, Head(2, Head(3, Empty)))</code> と同等です。 繰り返しますが、<code>switch</code> は <code>Empty</code>（別名 <code>[]</code>）を含むヴァリアントのすべての場合を処理することを強制します。 <strong>これは別の大きな問題である access bugs を排除します</strong>。</p>
<h4><a class="anchor" aria-hidden="true" id="他のヴァリアントのような型"></a><a href="#他のヴァリアントのような型" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>他のヴァリアントのような型</h4>
<p>string、int、float、array、そして、その他ほとんどのデータ構造で<code>switch</code> が使用できることをご存知でしたか？試してみましょう！</p>
<h2><a class="anchor" aria-hidden="true" id="ヒントとコツ"></a><a href="#ヒントとコツ" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>ヒントとコツ</h2>
<p>2つの引数を持つコンストラクタと、1つのタプル引数を持つコンストラクタとを混同しないように<strong>注意してください</strong>。</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">type</span> account =
  | <span class="hljs-constructor">Facebook</span>(string, int) <span class="hljs-comment">/* 2 arguments */</span>;
<span class="hljs-keyword">type</span> account2 =
  | <span class="hljs-constructor">Instagram</span>((string, int)) <span class="hljs-comment">/* 1 argument - happens to be a 2-tuple */</span>;
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="ヴァリアントにはコンストラクタが必要"></a><a href="#ヴァリアントにはコンストラクタが必要" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>ヴァリアントにはコンストラクタが必要</h3>
<p>あなたが型指定をしない言語から来ているなら、<code>type foo = int | string</code> と書きたい衝動に駆られるかもしれません。 これは Reason ではできません。各選択肢にコンストラクタを提供する必要があります: <code>type foo = Int(int) | String(string)</code>。 通常、これを必要とすることはアンチパターンになるかもしれません。 下部の設計方針のセクションで詳細を説明します。</p>
<h3><a class="anchor" aria-hidden="true" id="javascript-との相互運用"></a><a href="#javascript-との相互運用" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>JavaScript との相互運用</h3>
<p><em>このセクションは BuckleScript の <a href="https://bucklescript.github.io/docs/en/interop-overview.html">FFI</a> の知識があることを前提としています。 もし、まだ JS の関数にラップするためにヴァリアントを使用することにもやもやを感じていないなら、読み飛ばしてください</em>。</p>
<p>かなりの数の JS ライブラリは、引数に様々な型を受け入れることができる関数を使用します。 これらのケースでは、それらをヴァリアントとしてモデル化するのに非常に魅力的です。 例えば、<code>number</code> か <code>string</code> のいずれかを受け取る <code>myLibrary.draw</code> という JS 関数があるとします。 あなたはそれを次のようにバインドしたくなるかもしれません。</p>
<pre><code class="hljs css language-reason"><span class="hljs-comment">/* 内部で使用するために予約する */</span>
<span class="hljs-attribute">[@bs.module "myLibrary"]</span> <span class="hljs-keyword">external</span> draw : 'a =&gt; unit = <span class="hljs-string">"draw"</span>;

<span class="hljs-keyword">type</span> animal =
  | <span class="hljs-constructor">MyFloat</span>(float)
  | <span class="hljs-constructor">MyString</span>(string);

<span class="hljs-keyword">let</span> betterDraw = (animal) =&gt;
  <span class="hljs-keyword">switch</span> (animal) {
  | <span class="hljs-constructor">MyFloat</span>(f) =&gt; draw(f)
  | <span class="hljs-constructor">MyString</span>(s) =&gt; draw(s)
  };
</code></pre>
<p>確かに上記でも良いのですが、もっと良い方法があります！例えば単に同じ JS 呼び出しにコンパイルされる2つの <code>external</code> です。</p>
<pre><code class="hljs css language-reason"><span class="hljs-attribute">[@bs.module "myLibrary"]</span> <span class="hljs-keyword">external</span> drawFloat : float =&gt; unit = <span class="hljs-string">"draw"</span>;
<span class="hljs-attribute">[@bs.module "myLibrary"]</span> <span class="hljs-keyword">external</span> drawString : string =&gt; unit = <span class="hljs-string">"draw"</span>;
</code></pre>
<p>BuckleScript にもこれをするための<a href="https://bucklescript.github.io/docs/en/function.html#modeling-polymorphic-function">いくつかの方法</a>があります。</p>
<h3><a class="anchor" aria-hidden="true" id="ヴァリアントの型はフィールドの名前で特定される"></a><a href="#ヴァリアントの型はフィールドの名前で特定される" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>ヴァリアントの型はフィールドの名前で特定される</h3>
<p><a href="/docs/ja/record#record-types-are-found-by-field-name">レコードのセクション</a>を参照してください。 ヴァリアントも同じです。関数は2つの異なるヴァリアントによって共有する任意のコンストラクタを許容しません。 この場合もやはり、そのような機能が存在します。それはポリモーフィックヴァリアントと呼ばれています。 これについてはこの先話します =)</p>
<h2><a class="anchor" aria-hidden="true" id="設計方針"></a><a href="#設計方針" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>設計方針</h2>
<p>さまざまな形態のヴァリアント（ポリモーフィックヴァリアント、オープンヴァリアント、GADT など）は、おそらく Reason のような型システムの<em>いわゆる</em>特徴です。 前述の <code>option</code> ヴァリアントは、例えば、多言語のバグの主要な原因となる nullable 型の必要性を排除します。 哲学的に言うと、問題は多数の取り得る分岐/条件によって構成されます。 それらの条件の誤用は、私たちがバグと呼ぶものの大半です。 <strong>型システムは魔法のようにバグを排除しません。処理されていない条件を指摘し、それらを網羅するように要請します</strong>。 「あれこれ」を正しくモデル化する能力は非常に重要です。</p>
<p>例えば、一部の人々は、型システムがどのようにして、プログラムに渡されたひどいフォーマットの JSON データを安全に取り除くことができるのか疑問に思います。 型システムそれ自身は何もしません！ しかし、パーサが <code>None | Some(actualData)</code> のような <code>option</code> 型を返す場合、呼び出す箇所で明示的に <code>None</code> の場合を処理しなければなりません。 それがすべてです。</p>
<p>性能面で、ヴァリアントはあなたのプログラムロジックを驚くほどスピードアップできる可能性を秘めています。ここに JavaScript の一部があります。</p>
<pre><code class="hljs css language-js"><span class="hljs-keyword">let</span> data = <span class="hljs-string">'dog'</span>;
<span class="hljs-keyword">if</span> (data === <span class="hljs-string">'dog'</span>) {
  ...
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (data === <span class="hljs-string">'cat'</span>) {
  ...
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (data === <span class="hljs-string">'bird'</span>) {
  ...
}
</code></pre>
<p>ここには線形の計算量の分岐チェックがあります（<code>O(n)</code>）。これを Reason のヴァリアントを使用した場合とで比較してください。</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">type</span> animal = <span class="hljs-constructor">Dog</span> | <span class="hljs-constructor">Cat</span> | <span class="hljs-constructor">Bird</span>;
<span class="hljs-keyword">let</span> data = <span class="hljs-constructor">Dog</span>;
<span class="hljs-keyword">switch</span> (data) {
| <span class="hljs-constructor">Dog</span> =&gt; <span class="hljs-operator">...</span>
| <span class="hljs-constructor">Cat</span> =&gt; <span class="hljs-operator">...</span>
| <span class="hljs-constructor">Bird</span> =&gt; <span class="hljs-operator">...</span>
}
</code></pre>
<p>コンパイラはヴァリアントを見て、</p>
<ol>
<li>概念的にそれらを<code>type animal = 0 | 1 | 2</code> に変えます。</li>
<li><code>switch</code> を定数時間の形式（<code>O(1)</code>）にコンパイルします。</li>
</ol>
<p>なぜ型付け関数型言語は parsing のために頻繁に使われるのか不思議に思うかもしれません。大きな木を効率的かつ安全に切り替えることは、ヴァリアントのための最良のシナリオです。</p>
<!-- TODO: playground link -->
<p>まだ驚かない？ ヴァリアントは数学の他の分野と深い関わりを持ちます。興味深い探求のために <a href="https://codewords.recurse.com/issues/three/algebra-and-calculus-of-algebraic-data-types">ここを見て</a>ください。</p>
<p>落とし穴をカバーするために型システムに頼るよりも、問題を設計することが常に良い選択です。実際には、すべてのプログラムでそれをすること、または、闇雲にすべての問題を完全に理解して解決策を設計することは非現実的です。 型システムを使うと、前もってすべてを理解しなくても、コードベースの変更を安全に行うことができます。 これはガイド付き探索に最適です。 この点でも、型によって呼び出し元の単純な落とし穴を回避するだけの過度な API 設計をする必要がありません。 彼らは「事を遂行する」ために必要な抽象レイヤを減らし、見返りに呼び出し元の認知的負荷を軽減します。</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/ja/record"><span class="arrow-prev">← </span><span>Record</span></a><a class="docs-next button" href="/docs/ja/null-undefined-option"><span>Null, Undefined &amp; Option</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#使い方">使い方</a><ul class="toc-headings"><li><a href="#ヴァリアントは明示的な定義が必要">ヴァリアントは明示的な定義が必要</a></li><li><a href="#コンストラクタ引数">コンストラクタ引数</a></li><li><a href="#特筆事項">特筆事項</a></li></ul></li><li><a href="#ヒントとコツ">ヒントとコツ</a><ul class="toc-headings"><li><a href="#ヴァリアントにはコンストラクタが必要">ヴァリアントにはコンストラクタが必要</a></li><li><a href="#javascript-との相互運用">JavaScript との相互運用</a></li><li><a href="#ヴァリアントの型はフィールドの名前で特定される">ヴァリアントの型はフィールドの名前で特定される</a></li></ul></li><li><a href="#設計方針">設計方針</a></li></ul></nav></div><span><script src="/js/redirectBlog.js"></script><script src="/js/pjax-api.min.js"></script><script>window.foo = new Pjax({
          areas: [
            // try to use the first query.
            '.mainContainer, .docsNavContainer .toc .navWrapper, .onPageNav',
            // fallback
            'body'
          ],
          link: '.docsNavContainer:not(.docsSliderActive) a',
          update: {
            script: false,
          }
        });
        var languagesMenuItemCopy = document.getElementById("languages-menu");
        languagesMenuItemCopy.addEventListener("click", function(e){
          e.preventDefault();
          e.stopPropagation();
          e.stopImmediatePropagation();
        });</script></span></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                
                apiKey: '966d1e412f67114a07dc0afe44b19b53',
                indexName: 'reason',
                inputSelector: '#search_input_react',
                algoliaOptions: {"facetFilters":["lang:ja"]}
              });
            </script></body></html>